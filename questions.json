{"questions":[{"id":"duplicate-integer","name":"Duplicate Integer","description":"Given an integer array `nums`, return `true` if any value appears **more than once** in the array, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: nums = [1, 2, 3, 3]\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: nums = [1, 2, 3, 4]\n\nOutput: false\n```\n","difficulty":"Easy","concepts":["Hash Usage"],"solutions":{"python":"class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n        hashset = set()\n\n        for n in nums:\n            if n in hashset:\n                return True\n            hashset.add(n)\n        return False\n    ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {boolean}\n     */\n    hasDuplicate(nums) {\n        const numsSet = new Set();\n        for (const num of nums) {\n            if (numsSet.has(num)) return true;\n\n            numsSet.add(num);\n        }\n\n        return false;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool hasDuplicate(vector<int>& nums) {\n        unordered_set<int> s;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            if (s.find(nums[i]) != s.end()) {\n                return true;\n            }\n            s.insert(nums[i]);\n        }\n        \n        return false;\n    }\n};\n","java":"class Solution {\n    public boolean hasDuplicate(int[] nums) {\n        Set<Integer> uniques = new HashSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (uniques.contains(nums[i])) {\n                return true;\n            }\n            uniques.add(nums[i]);\n        }\n        return false;\n    }\n}\n","csharp":"public class Solution {\n    public bool hasDuplicate(int[] nums) {\n        HashSet<int> set = new HashSet<int>();\n        \n        foreach (int x in nums){\n            if (set.Contains(x)) return true;\n            set.Add(x);\n        }\n        return false;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def hasDuplicate(self, nums: List[int]) -> bool:\n         ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {boolean}\n     */\n    hasDuplicate(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    bool hasDuplicate(vector<int>& nums) {\n\n    }\n};\n","java":"class Solution {\n    public boolean hasDuplicate(int[] nums) {\n \n    }\n}\n","csharp":"public class Solution {\n    public bool hasDuplicate(int[] nums) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/3OamzN90kPg"},{"id":"count-connected-components","name":"Count Connected Components","description":"There is an undirected graph with `n` nodes. There is also an `edges` array, where `edges[i] = [a, b]` means that there is an edge between node `a` and node `b` in the graph.\n\nThe nodes are numbered from `0` to `n - 1`.\n\nReturn the total number of connected components in that graph.\n\n**Example 1:**\n\n```java\nInput:\nn=3\nedges=[[0,1], [0,2]]\n\nOutput:\n1\n```\n\n**Example 2:**\n\n```java\nInput:\nn=6\nedges=[[0,1], [1,2], [2,3], [4,5]]\n\nOutput:\n2\n```\n\n**Constraints:**\n* `1 <= n <= 100`\n* `0 <= edges.length <= n * (n - 1) / 2`\n","difficulty":"Medium","concepts":["Union-Find"],"solutions":{"python":"class UnionFind:\n\n    def __init__(self):\n        self.f = {}\n\n    def findParent(self, x: int) -> int:\n        y = self.f.get(x, x)\n        if x != y:\n            y = self.f[x] = self.findParent(y)\n        return y\n\n    def union(self, x: int, y: int):\n\n        self.f[self.findParent(x)] = self.findParent(y)\n\nclass Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        dsu = UnionFind()\n        for a, b in edges:\n            dsu.union(a, b)\n        return len(set(dsu.findParent(x) for x in range(n)))\n    ","javascript":"class Solution {\n    constructor() {\n        this.parent = [];\n        this.rank = [];\n    }\n\n    /**\n     * @param {number} n\n     * @param {number[][]} edges\n     * @returns {number}\n     */\n    countComponents(n, edges) {\n        this.parent = new Array(n);\n        this.rank = new Array(n);\n\n        for (let i = 0; i < n; i++) {\n            this.parent[i] = i;\n            this.rank[i] = 1;\n        }\n\n        let result = n;\n        for (let i = 0; i < edges.length; i++) {\n            if (this.union(edges[i][0], edges[i][1]) === 1) {\n                result--;\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * @param {number} node\n     * @returns {number}\n     */\n    find(node) {\n        let result = node;\n\n        while (this.parent[result] !== result) {\n            this.parent[result] = this.parent[this.parent[result]];\n            result = this.parent[result];\n        }\n\n        return result;\n    }\n\n    /**\n     * @param {number} n1\n     * @param {number} n2\n     * @returns {number}\n     */\n    union(n1, n2) {\n        let p1 = this.find(n1);\n        let p2 = this.find(n2);\n\n        if (p1 === p2) {\n            return 0;\n        }\n\n        if (this.rank[p2] > this.rank[p1]) {\n            this.parent[p1] = p2;\n            this.rank[p2] += this.rank[p1];\n        } else {\n            this.parent[p2] = p1;\n            this.rank[p1] += this.rank[p2];\n        }\n\n        return 1;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n        vector<int> parents;\n        vector<int> ranks;\n        for (int i = 0; i < n; i++) {\n            parents.push_back(i);\n            ranks.push_back(1);\n        }\n        \n        int result = n;\n        for (int i = 0; i < edges.size(); i++) {\n            int n1 = edges[i][0];\n            int n2 = edges[i][1];\n            result -= doUnion(parents, ranks, n1, n2);\n        }\n        return result;\n    }\n    \nprivate:\n    int doFind(vector<int>& parents, int n) {\n        int p = parents[n];\n        while (p != parents[p]) {\n            parents[p] = parents[parents[p]];\n            p = parents[p];\n        }\n        return p;\n    }\n    \n    int doUnion(vector<int>& parents, vector<int>& ranks, int n1, int n2) {\n        int p1 = doFind(parents, n1);\n        int p2 = doFind(parents, n2);\n        if (p1 == p2) {\n            return 0;\n        }\n        \n        if (ranks[p1] > ranks[p2]) {\n            parents[p2] = p1;\n            ranks[p1] += ranks[p2];\n        } else {\n            parents[p1] = p2;\n            ranks[p2] += ranks[p1];\n        }\n        \n        return 1;\n    }\n};\n","java":"class Solution {\n\n    private int[] parent;\n    private int[] rank;\n\n    public int countComponents(int n, int[][] edges) {\n        parent = new int[n];\n        rank = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n\n        int result = n;\n        for (int i = 0; i < edges.length; i++) {\n            if (union(edges[i][0], edges[i][1]) == 1) {\n                result--;\n            }\n        }\n\n        return result;\n    }\n\n    private int find(int node) {\n        int result = node;\n\n        while (parent[result] != result) {\n            parent[result] = parent[parent[result]];\n            result = parent[result];\n        }\n\n        return result;\n    }\n\n    private int union(int n1, int n2) {\n        int p1 = this.find(n1);\n        int p2 = this.find(n2);\n\n        if (p1 == p2) {\n            return 0;\n        }\n\n        if (rank[p2] > rank[p1]) {\n            parent[p1] = p2;\n            rank[p2] += rank[p1];\n        } else {\n            parent[p2] = p1;\n            rank[p1] += rank[p2];\n        }\n\n        return 1;\n    }\n}\n","csharp":"public class Solution {\n\n    private int[] parent;\n    private int[] rank;\n\n    public int CountComponents(int n, int[][] edges) {\n        parent = new int[n];\n        rank = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 1;\n        }\n\n        int result = n;\n        for (int i = 0; i < edges.Length; i++) {\n            if (Union(edges[i][0], edges[i][1]) == 1) {\n                result--;\n            }\n        }\n\n        return result;\n    }\n\n    private int Find(int node) {\n        int result = node;\n\n        while (parent[result] != result) {\n            parent[result] = parent[parent[result]];\n            result = parent[result];\n        }\n\n        return result;\n    }\n\n    private int Union(int n1, int n2) {\n        int p1 = Find(n1);\n        int p2 = Find(n2);\n\n        if (p1 == p2) {\n            return 0;\n        }\n\n        if (rank[p2] > rank[p1]) {\n            parent[p1] = p2;\n            rank[p2] += rank[p1];\n        } else {\n            parent[p2] = p1;\n            rank[p1] += rank[p2];\n        }\n\n        return 1;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def countComponents(self, n: int, edges: List[List[int]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @param {number[][]} edges\n     * @returns {number}\n     */\n    countComponents(n, edges) {}\n}\n","cpp":"class Solution {\npublic:\n    int countComponents(int n, vector<vector<int>>& edges) {\n\n    }\n};\n","java":"class Solution {\n    public int countComponents(int n, int[][] edges) {\n\n    }\n}\n","csharp":"public class Solution {\n    public int CountComponents(int n, int[][] edges) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/8f1XPm4WOUc"},{"id":"valid-tree","name":"Valid Tree","description":"Given `n` nodes labeled from `0` to `n - 1` and a list of **undirected** edges (each edge is a pair of nodes), write a function to check whether these edges make up a valid tree.\n\n**Example 1:**\n\n```java\nInput:\nn = 5\nedges = [[0, 1], [0, 2], [0, 3], [1, 4]]\n\nOutput:\ntrue\n```\n\n**Example 2:**\n\n```java\nInput:\nn = 5\nedges = [[0, 1], [1, 2], [2, 3], [1, 3], [1, 4]]\n\nOutput:\nfalse\n```\n\n**Note:**\n* You can assume that no duplicate edges will appear in edges. Since all edges are `undirected`, `[0, 1]` is the same as `[1, 0]` and thus will not appear together in edges.\n\n**Constraints:**\n* `1 <= n <= 100`\n* `0 <= edges.length <= n * (n - 1) / 2`\n","difficulty":"Medium","concepts":["Adjacency List"],"solutions":{"python":"class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        if not n:\n            return True\n        adj = {i: [] for i in range(n)}\n        for n1, n2 in edges:\n            adj[n1].append(n2)\n            adj[n2].append(n1)\n\n        visit = set()\n\n        def dfs(i: int, prev: int) -> bool:\n            if i in visit:\n                return False\n\n            visit.add(i)\n            for j in adj[i]:\n                if j == prev:\n                    continue\n                if not dfs(j, i):\n                    return False\n            return True\n\n        return dfs(0, -1) and n == len(visit)\n    ","javascript":"class Solution {\n    constructor() {\n        this.adjacencyList = new Map();\n    }\n\n    /**\n     * @param {number} n\n     * @param {number[][]} edges\n     * @returns {boolean}\n     */\n    validTree(n, edges) {\n        this.adjacencyList.clear();\n\n        if (n == 1) return edges.length == 0;\n\n        if (edges.length == 0) return false;\n\n        for (let edge of edges) {\n            let node1 = edge[0];\n            let node2 = edge[1];\n            if (!this.adjacencyList.has(node1))\n                this.adjacencyList.set(node1, []);\n            if (!this.adjacencyList.has(node2))\n                this.adjacencyList.set(node2, []);\n            this.adjacencyList.get(node1).push(node2);\n            this.adjacencyList.get(node2).push(node1);\n        }\n\n        let visited = new Set();\n\n        if (!this.depthFirstSearch(0, -1, visited)) return false;\n\n        return visited.size === n;\n    }\n\n    /**\n     * @param {number} node\n     * @param {number} previous\n     * @param {Set} visited\n     * @returns {boolean}\n     */\n    depthFirstSearch(node, previous, visited) {\n        if (visited.has(node)) return false;\n\n        visited.add(node);\n\n        for (let neighbor of this.adjacencyList.get(node)) {\n            if (neighbor === previous) continue;\n\n            if (!this.depthFirstSearch(neighbor, node, visited)) return false;\n        }\n\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool validTree(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> adj(n);\n        for (int i = 0; i < edges.size(); i++) {\n            vector<int> edge = edges[i];\n            adj[edge[0]].push_back(edge[1]);\n            adj[edge[1]].push_back(edge[0]);\n        }\n        \n        vector<bool> visited(n);\n        if (hasCycle(adj, visited, -1, 0)) {\n            return false;\n        }\n        \n        for (int i = 0; i < visited.size(); i++) {\n            if (!visited[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \nprivate:\n    bool hasCycle(vector<vector<int>>& adj, vector<bool>& visited, int parent, int child) {\n        if (visited[child]) {\n            return true;\n        }\n        visited[child] = true;\n    \n        for (int i = 0; i < adj[child].size(); i++) {\n            int curr = adj[child][i];\n            if (curr != parent && hasCycle(adj, visited, child, curr)) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n","java":"class Solution {\n\n    private Map<Integer, List<Integer>> adjacencyList = new HashMap<>();\n\n    public boolean validTree(int n, int[][] edges) {\n        adjacencyList.clear();  \n    \n        if (n == 1) return edges.length == 0;\n    \n        if (edges.length == 0) return false;\n    \n        for (int[] edge : edges) {\n            int node1 = edge[0];\n            int node2 = edge[1];\n            adjacencyList.putIfAbsent(node1, new ArrayList<>());\n            adjacencyList.putIfAbsent(node2, new ArrayList<>());\n            adjacencyList.get(node1).add(node2);\n            adjacencyList.get(node2).add(node1);\n        }\n    \n        Set<Integer> visited = new HashSet<>();\n    \n        if (!depthFirstSearch(edges[0][0], -1, visited)) return false;\n    \n        return visited.size() == n;\n    }\n\n    private boolean depthFirstSearch(int node, int previous, Set<Integer> visited) {\n        if (visited.contains(node)) return false;\n\n        visited.add(node);\n\n        for (int neighbor : adjacencyList.get(node)) {\n            if (neighbor == previous) continue;\n\n            if (!depthFirstSearch(neighbor, node, visited)) return false;\n        }\n\n        return true;\n    }\n}\n","csharp":"public class Solution {\n   \n    public bool ValidTree(int n, int[][] edges) {\n            if (n == 0) return true;\n\n            var adj = new HashSet<int>[n];\n\n            for (int i = 0; i < n; i++) {\n                adj[i] = new HashSet<int>();\n            }\n            foreach (var edge in edges) {\n                var e1 = edge[0];\n                var e2 = edge[1];\n                adj[e1].Add(e2); adj[e2].Add(e1);\n            }\n            var visited = new bool[n];\n\n            var res = DfsValidTree(adj, 0, visited);\n\n            if (visited.Any(c => !c)) return false;\n            return res;\n    }\n\n    private bool DfsValidTree(HashSet<int>[] adj, int current, bool[] visited) {\n        if (visited[current]) return false;\n        visited[current] = true;\n\n        var nextLevel = adj[current];\n        foreach (var level in nextLevel) {\n            adj[level].Remove(current);\n            if (!DfsValidTree(adj, level, visited)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def validTree(self, n: int, edges: List[List[int]]) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @param {number[][]} edges\n     * @returns {boolean}\n     */\n    validTree(n, edges) {}\n}\n","cpp":"class Solution {\npublic:\n    bool validTree(int n, vector<vector<int>>& edges) {\n\n    }\n};\n","java":"class Solution {\n    public boolean validTree(int n, int[][] edges) {\n\n    }\n}\n","csharp":"public class Solution {\n    public bool ValidTree(int n, int[][] edges) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/bXsUuownnoQ"},{"id":"foreign-dictionary","name":"Foreign Dictionary","description":"There is a foreign language which uses the latin alphabet, but the order among letters is *not* \"a\", \"b\", \"c\" ... \"z\" as in English.\n\nYou receive a list of *non-empty* strings `words` from the dictionary, where the words are **sorted lexicographically** based on the rules of this new language. \n\nDerive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return **any** of them.\n\nA string `a` is lexicographically smaller than a string `b` if either of the following is true:\n* The first letter where they differ is smaller in `a` than in `b`.\n* There is no index `i` such that `a[i] != b[i]` *and* `a.length < b.length`.\n\n**Example 1:**\n\n```java\nInput: [\"z\",\"o\"]\n\nOutput: \"zo\"\n```\n\nExplanation:\nFrom \"z\" and \"o\", we know 'z' < 'o', so return \"zo\".\n\n**Example 2:**\n\n```java\nInput: [\"hrn\",\"hrf\",\"er\",\"enn\",\"rfnn\"]\n\nOutput: \"hernf\"\n```\n\nExplanation:\n* from \"hrn\" and \"hrf\", we know 'n' < 'f'\n* from \"hrf\" and \"er\", we know 'h' < 'e'\n* from \"er\" and \"enn\", we know get 'r' < 'n'\n* from \"enn\" and \"rfnn\" we know 'e'<'r'\n* so one possibile solution is \"hernf\"\n\n**Constraints:**\n* The input `words` will contain characters only from lowercase `'a'` to `'z'`.\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 100`\n","difficulty":"Hard","concepts":["Adjacency List","Topological Sort"],"solutions":{"python":"class Solution:\n    def foreignDictionary(self, words: List[str]) -> str:\n        adj = {char: set() for word in words for char in word}\n\n        for i in range(len(words) - 1):\n            w1, w2 = words[i], words[i + 1]\n            minLen = min(len(w1), len(w2))\n            if len(w1) > len(w2) and w1[:minLen] == w2[:minLen]:\n                return \"\"\n            for j in range(minLen):\n                if w1[j] != w2[j]:\n                    adj[w1[j]].add(w2[j])\n                    break\n\n        visited = {}  # {char: bool} False visited, True current path\n        res = []\n\n        def dfs(char):\n            if char in visited:\n                return visited[char]\n\n            visited[char] = True\n\n            for neighChar in adj[char]:\n                if dfs(neighChar):\n                    return True\n\n            visited[char] = False\n            res.append(char)\n\n        for char in adj:\n            if dfs(char):\n                return \"\"\n\n        res.reverse()\n        return \"\".join(res)\n","javascript":"class Solution {\n    /**\n     * @param {string[]} words\n     * @returns {string}\n     */\n    foreignDictionary(words) {\n        let adj = {};\n        words.forEach(word => {\n            for (let char of word) {\n                adj[char] = new Set();\n            }\n        });\n\n        for (let i = 0; i < words.length - 1; i++) {\n            let w1 = words[i],\n                w2 = words[i + 1];\n            let minLen = Math.min(w1.length, w2.length);\n            if (\n                w1.length > w2.length &&\n                w1.substring(0, minLen) === w2.substring(0, minLen)\n            ) {\n                return '';\n            }\n            for (let j = 0; j < minLen; j++) {\n                if (w1[j] !== w2[j]) {\n                    adj[w1[j]].add(w2[j]);\n                    break;\n                }\n            }\n        }\n\n        let state = {}; // 0 = unvisited, 1 = visiting, 2 = visited\n        let res = [];\n\n        /**\n         * @param {string} char\n         * @returns {boolean}\n         */\n        function dfs(char) {\n            if (state[char] === 1) {\n                // Node is being visited, found a cycle\n                return true;\n            }\n            if (state[char] === 2) {\n                // Node has already been visited, no need to visit again\n                return false;\n            }\n\n            state[char] = 1; // Mark as visiting\n            for (let neighChar of adj[char]) {\n                if (dfs(neighChar)) {\n                    return true;\n                }\n            }\n            state[char] = 2; // Mark as visited\n            res.push(char);\n            return false;\n        }\n\n        for (let char in adj) {\n            if (!state[char] && dfs(char)) {\n                return '';\n            }\n        }\n\n        res.reverse();\n        return res.join('');\n    }\n}\n","cpp":"class Solution {\npublic:\n    unordered_map<char, unordered_set<char>> adj;\n    unordered_map<char, bool> visited;\n    string result;\n\n    string foreignDictionary(vector<string>& words) {\n        for (const auto& word : words) {\n            for (char ch : word) {\n                adj[ch];\n            }\n        }\n\n        for (size_t i = 0; i < words.size() - 1; ++i) {\n            const string& w1 = words[i], & w2 = words[i + 1];\n            size_t minLen = min(w1.length(), w2.length());\n            if (w1.length() > w2.length() && w1.substr(0, minLen) == w2.substr(0, minLen)) {\n                return \"\";\n            }\n            for (size_t j = 0; j < minLen; ++j) {\n                if (w1[j] != w2[j]) {\n                    adj[w1[j]].insert(w2[j]);\n                    break;\n                }\n            }\n        }\n\n        for (const auto& pair : adj) {\n            if (dfs(pair.first)) {\n                return \"\";\n            }\n        }\n\n        reverse(result.begin(), result.end());\n        return result;\n    }\n\n    bool dfs(char ch) {\n        if (visited.find(ch) != visited.end()) {\n            return visited[ch];\n        }\n\n        visited[ch] = true;\n        for (char next : adj[ch]) {\n            if (dfs(next)) {\n                return true;\n            }\n        }\n        visited[ch] = false;\n        result.push_back(ch);\n        return false;\n    }\n};\n","java":"class Solution {\n    private Map<Character, Set<Character>> adj;\n    private Map<Character, Boolean> visited;\n    private List<Character> result;\n\n    public String foreignDictionary(String[] words) {\n        adj = new HashMap<>();\n        for (String word : words) {\n            for (char c : word.toCharArray()) {\n                adj.putIfAbsent(c, new HashSet<>());\n            }\n        }\n\n        for (int i = 0; i < words.length - 1; i++) {\n            String w1 = words[i], w2 = words[i + 1];\n            int minLen = Math.min(w1.length(), w2.length());\n            if (w1.length() > w2.length() && w1.substring(0, minLen).equals(w2.substring(0, minLen))) {\n                return \"\";\n            }\n            for (int j = 0; j < minLen; j++) {\n                if (w1.charAt(j) != w2.charAt(j)) {\n                    adj.get(w1.charAt(j)).add(w2.charAt(j));\n                    break;\n                }\n            }\n        }\n\n        visited = new HashMap<>();\n        result = new ArrayList<>();\n        for (char c : adj.keySet()) {\n            if (dfs(c)) {\n                return \"\";\n            }\n        }\n\n        Collections.reverse(result);\n        StringBuilder sb = new StringBuilder();\n        for (char c : result) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    private boolean dfs(char ch) {\n        if (visited.containsKey(ch)) {\n            return visited.get(ch);\n        }\n\n        visited.put(ch, true);\n        for (char next : adj.get(ch)) {\n            if (dfs(next)) {\n                return true;\n            }\n        }\n        visited.put(ch, false);\n        result.add(ch);\n        return false;\n    }\n}\n","csharp":"public class Solution {\n    private Dictionary<char, HashSet<char>> adj;\n    private Dictionary<char, bool> visited;\n    private List<char> result;\n\n    public string foreignDictionary(string[] words) {\n        adj = new Dictionary<char, HashSet<char>>();\n        foreach (var word in words) {\n            foreach (var c in word) {\n                if (!adj.ContainsKey(c)) {\n                    adj[c] = new HashSet<char>();\n                }\n            }\n        }\n\n        for (int i = 0; i < words.Length - 1; i++) {\n            var w1 = words[i];\n            var w2 = words[i + 1];\n            int minLen = Math.Min(w1.Length, w2.Length);\n            if (w1.Length > w2.Length && w1.Substring(0, minLen) == w2.Substring(0, minLen)) {\n                return \"\";\n            }\n            for (int j = 0; j < minLen; j++) {\n                if (w1[j] != w2[j]) {\n                    adj[w1[j]].Add(w2[j]);\n                    break;\n                }\n            }\n        }\n\n        visited = new Dictionary<char, bool>();\n        result = new List<char>();\n        foreach (var c in adj.Keys) {\n            if (dfs(c)) {\n                return \"\";\n            }\n        }\n\n        result.Reverse();\n        var sb = new StringBuilder();\n        foreach (var c in result) {\n            sb.Append(c);\n        }\n        return sb.ToString();\n    }\n\n    private bool dfs(char ch) {\n        if (visited.ContainsKey(ch)) {\n            return visited[ch];\n        }\n\n        visited[ch] = true;\n        foreach (var next in adj[ch]) {\n            if (dfs(next)) {\n                return true;\n            }\n        }\n        visited[ch] = false;\n        result.Add(ch);\n        return false;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def foreignDictionary(self, words: List[str]) -> str:\n        ","javascript":"class Solution {\n    /**\n     * @param {string[]} words\n     * @returns {string}\n     */\n    foreignDictionary(words) {}\n}\n","cpp":"class Solution {\npublic:\n    string foreignDictionary(vector<string>& words) {\n        \n    }\n};\n","java":"class Solution {\n    public String foreignDictionary(String[] words) {\n      \n    }\n}\n","csharp":"public class Solution {\n    public string foreignDictionary(string[] words) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/6kTZYvNNyps"},{"id":"is-anagram","name":"Is Anagram","description":"Given two strings `s` and `t`, return `true` if the two strings are anagrams of each other, otherwise return `false`.\n\nAn **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\n**Example 1:**\n\n```java\nInput: s = \"racecar\", t = \"carrace\"\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: s = \"jar\", t = \"jam\"\n\nOutput: false\n```\n\n**Constraints:**\n* `s` and `t` consist of lowercase English letters.\n","difficulty":"Easy","concepts":["Hash Usage"],"solutions":{"python":"class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        if len(s) != len(t):\n            return False\n\n        countS, countT = {}, {}\n\n        for i in range(len(s)):\n            countS[s[i]] = 1 + countS.get(s[i], 0)\n            countT[t[i]] = 1 + countT.get(t[i], 0)\n        return countS == countT\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} t\n     * @return {boolean}\n     */\n    isAnagram(s, t) {\n        if (s.length !== t.length) {\n            return false;\n        }\n\n        const countS = {};\n        const countT = {};\n\n        for (let i = 0; i < s.length; i++) {\n            countS[s[i]] = 1 + (countS[s[i]] || 0);\n            countT[t[i]] = 1 + (countT[t[i]] || 0);\n        }\n\n        for (const key in countS) {\n            if (countS[key] !== countT[key]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        if(s.size() != t.size()) return false;\n        \n        unordered_map<char,int> s_count;\n        unordered_map<char,int> t_count;\n        \n        for(int i = 0; i < s.size(); i++){\n            s_count[s[i]]++;\n            t_count[t[i]]++;\n        }\n        \n        for(int i = 0; i < s_count.size(); i++){\n            if(s_count[i] != t_count[i]) return false;\n        }\n        return true;\n    }\n};","java":"class Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) return false;\n\n        int[] store = new int[26];\n\n        for (int i = 0; i < s.length(); i++) {\n            store[s.charAt(i) - 'a']++;\n            store[t.charAt(i) - 'a']--;\n        }\n\n        for (int n : store) if (n != 0) return false;\n\n        return true;\n    }\n}\n","csharp":"public class Solution {\n    public bool IsAnagram(string s, string t) {\n        if (s.Length != t.Length) return false;\n\n        int[] store = new int[26];\n\n        for (int i = 0; i < s.Length; i++) {\n            store[s[i] - 'a']++;\n            store[t[i] - 'a']--;\n        }\n\n        foreach (int n in store) if (n != 0) return false;\n\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isAnagram(self, s: str, t: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} t\n     * @return {boolean}\n     */\n    isAnagram(s, t) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isAnagram(String s, String t) {\n\n    }\n}\n","csharp":"public class Solution {\n    public bool IsAnagram(string s, string t) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/9UtInBqnCgA"},{"id":"two-integer-sum","name":"Two Integer Sum","description":"Given an array of integers `nums` and an integer `target`, return the indices `i` and `j` such that `nums[i] + nums[j] == target` and `i != j`.\n    \nYou may assume that *every* input has exactly one pair of indices `i` and `j` that satisfy the condition.\n\nReturn the answer with the smaller index first. \n\n**Example 1:**\n\n```java\nInput: \nnums = [3,4,5,6], target = 7\n\nOutput: [0,1]\n```\n\nExplanation: `nums[0] + nums[1] == 7`, so we return `[0, 1]`.\n\n**Example 2:**\n\n```java\nInput: nums = [4,5,6], target = 10\n\nOutput: [0,2]\n```\n\n**Example 3:**\n\n```java\nInput: nums = [5,5], target = 10\n\nOutput: [0,1]\n```\n\n**Constraints:**\n* `2 <= nums.length <= 1000`\n* `-10,000,000 <= nums[i] <= 10,000,000`\n* `-10,000,000 <= target <= 10,000,000`\n","difficulty":"Easy","concepts":["Hash Usage"],"solutions":{"python":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        prevMap = {}  # val -> index\n\n        for i, n in enumerate(nums):\n            diff = target - n\n            if diff in prevMap:\n                return [prevMap[diff], i]\n            prevMap[n] = i\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number[]}\n     */\n    twoSum(nums, target) {\n        const map = new Map();\n\n        for (let index = 0; index < nums.length; index++) {\n            const num = nums[index];\n            const complement = target - num;\n            const sumIndex = map.get(complement);\n\n            const isTarget = map.has(complement);\n            if (isTarget) {\n                return [index, sumIndex];\n            }\n\n            map.set(num, index);\n        }\n\n        return [-1, -1];\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        unordered_map<int, int> mp; \n\n        for (int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if (mp.find(complement) != mp.end()) {\n                return {mp[complement], i};\n            }\n            mp.insert({nums[i], i});\n        }\n        return {};\n    }\n};\n","java":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> prevMap = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            int diff = target - num;\n\n            if (prevMap.containsKey(diff)) {\n                return new int[] { prevMap.get(diff), i };\n            }\n\n            prevMap.put(num, i);\n        }\n\n        return new int[] {};\n    }\n}\n","csharp":"public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n        Dictionary<int, int> indices = new Dictionary<int, int>();\n\n        for (int i = 0; i < nums.Length; i++) {\n            var diff = target - nums[i];\n            if (indices.ContainsKey(diff)) {\n                return new int[] {indices[diff], i};\n            }\n            indices[nums[i]] = i;\n        }\n        return null;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def twoSum(self, nums: List[int], target: int) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number[]}\n     */\n    twoSum(nums, target) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] TwoSum(int[] nums, int target) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/KLlXCFG5TnA"},{"id":"is-palindrome","name":"Is Palindrome","description":"Given a string `s`, return `true` if it is a **palindrome**, otherwise return `false`.\n    \nA **palindrome** is a string that reads the same forward and backward. It is also case-insensitive and ignores all non-alphanumeric characters.\n\n**Example 1:**\n\n```java\nInput: s = \"Was it a car or a cat I saw?\"\n\nOutput: true\n```\n\nExplanation: After considering only alphanumerical characters we have \"wasitacaroracatisaw\", which is a palindrome.\n\n**Example 2:**\n\n```java\nInput: s = \"tab a cat\"\n\nOutput: false\n```\n\nExplanation: \"tabacat\" is not a palindrome.\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `s` is made up of only printable ASCII characters.\n","difficulty":"Easy","concepts":["Two Pointers"],"solutions":{"python":"class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        l, r = 0, len(s) - 1\n\n        while l < r:\n            while l < r and not self.alphaNum(s[l]):\n                l += 1\n            while r > l and not self.alphaNum(s[r]):\n                r -= 1\n            if s[l].lower() != s[r].lower():\n                return False\n            l, r = l + 1, r - 1\n        return True\n    \n    def alphaNum(self, c):\n        return (ord('A') <= ord(c) <= ord('Z') or \n                ord('a') <= ord(c) <= ord('z') or \n                ord('0') <= ord(c) <= ord('9'))\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {boolean}\n     */\n    isPalindrome(s) {\n        let l = 0;\n        let r = s.length - 1;\n\n        while (l < r) {\n            while (l < r && !this.alphaNum(s[l])) {\n                l++;\n            }\n            while (r > l && !this.alphaNum(s[r])) {\n                r--;\n            }\n            if (s[l].toLowerCase() !== s[r].toLowerCase()) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n\n    /**\n     * @param {string} c\n     * @return {boolean}\n     */\n    alphaNum(c) {\n        const charCode = c.charCodeAt(0);\n        return (\n            (65 <= charCode && charCode <= 90) ||\n            (97 <= charCode && charCode <= 122) ||\n            (48 <= charCode && charCode <= 57)\n        );\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isPalindrome(string s) {\n        int l = 0;\n        int r = s.size() - 1;\n        \n        while (l < r) {\n            while (!isalnum(s[l]) && l < r) {\n                l++;\n            }\n            while (!isalnum(s[r]) && l < r) {\n                r--;\n            }\n            if (tolower(s[l]) != tolower(s[r])) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n};\n","java":"class Solution {\n    public boolean isPalindrome(String s) {\n        int l = 0;\n        int r = s.length() - 1;\n        while (l < r) {      \n            while (l < r && !Character.isLetterOrDigit(s.charAt(l))) {\n                l++;\n            }\n            while (l < r && !Character.isLetterOrDigit(s.charAt(r))) {\n                r--;\n            }\n            if (Character.toLowerCase(s.charAt(l)) != Character.toLowerCase(s.charAt(r))) {\n                return false;\n            }\n            l++;\n            r--;    \n        }  \n        return true;\n    }\n}\n","csharp":"public class Solution {\n    public bool IsPalindrome(string s) {\n        int left = 0;\n        int right = s.Length - 1;\n\n        while (left < right) {\n            if (!char.IsLetterOrDigit(s[left])) {\n                left++;\n            } else if (!char.IsLetterOrDigit(s[right])) {\n                right--;\n            } else {\n                if (char.ToLower(s[left]) != char.ToLower(s[right])) {\n                    return false;\n                }\n                left++;\n                right--;\n            }\n        }\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isPalindrome(self, s: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {boolean}\n     */\n    isPalindrome(s) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isPalindrome(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isPalindrome(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsPalindrome(string s) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/jJXJ16kPFWg"},{"id":"islands-and-treasure","name":"Islands and Treasure","description":"You are given a $m \\times n$ 2D `grid` initialized with these three possible values:\n\n1. `-1` - A water cell that *can not* be traversed.\n2. `0` - A treasure chest.\n3. `INF` - A land cell that *can* be traversed. We use the integer `2^31 - 1 = 2147483647` to represent `INF`.\n\nFill each land cell with the distance to its nearest treasure chest. If a land cell cannot reach a treasure chest than the value should remain `INF`.\n\nAssume the grid can only be traversed up, down, left, or right.\n\n**Example 1:**\n\n```java\nInput: [\n  [2147483647,-1,0,2147483647],\n  [2147483647,2147483647,2147483647,-1],\n  [2147483647,-1,2147483647,-1],\n  [0,-1,2147483647,2147483647]\n]\n\nOutput: [\n  [3,-1,0,1],\n  [2,2,1,-1],\n  [1,-1,2,-1],\n  [0,-1,3,4]\n]\n```\n\n**Example 2:**\n\n```java\nInput: [\n  [0,-1],\n  [2147483647,2147483647]\n]\n\nOutput: [\n  [0,-1],\n  [1,2]\n]\n```\n\n**Constraints:**\n* `m == grid.length`\n* `n == grid[i].length`\n* `1 <= m, n <= 100`\n* `grid[i][j]` is one of `{-1, 0, 2147483647}`\n","difficulty":"Medium","concepts":["Matrix BFS"],"solutions":{"python":"class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n        q = deque()\n\n        def addCell(r, c):\n            if (\n                min(r, c) < 0\n                or r == ROWS\n                or c == COLS\n                or (r, c) in visit\n                or grid[r][c] == -1\n            ):\n                return\n            visit.add((r, c))\n            q.append([r, c])\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if grid[r][c] == 0:\n                    q.append([r, c])\n                    visit.add((r, c))\n\n        dist = 0\n        while q:\n            for i in range(len(q)):\n                r, c = q.popleft()\n                grid[r][c] = dist\n                addCell(r + 1, c)\n                addCell(r - 1, c)\n                addCell(r, c + 1)\n                addCell(r, c - 1)\n            dist += 1\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     */\n    islandsAndTreasure(grid) {\n        let ROWS = grid.length;\n        let COLS = grid[0].length;\n        let visit = new Set();\n        let q = [];\n\n        /**\n         * @param {number} r\n         * @param {number} c\n         */\n        function addCell(r, c) {\n            if (\n                Math.min(r, c) < 0 ||\n                r === ROWS ||\n                c === COLS ||\n                visit.has(r + ',' + c) ||\n                grid[r][c] === -1\n            ) {\n                return;\n            }\n            visit.add(r + ',' + c);\n            q.push([r, c]);\n        }\n\n        for (let r = 0; r < ROWS; r++) {\n            for (let c = 0; c < COLS; c++) {\n                if (grid[r][c] === 0) {\n                    q.push([r, c]);\n                    visit.add(r + ',' + c);\n                }\n            }\n        }\n\n        let dist = 0;\n        while (q.length > 0) {\n            for (let i = 0, len = q.length; i < len; i++) {\n                let [r, c] = q.shift();\n                grid[r][c] = dist;\n                addCell(r + 1, c);\n                addCell(r - 1, c);\n                addCell(r, c + 1);\n                addCell(r, c - 1);\n            }\n            dist += 1;\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    void islandsAndTreasure(vector<vector<int>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        queue<pair<int, int>> q;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    q.push({i, j});\n                }\n            }\n        }\n        \n        vector<vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        while (!q.empty()) {\n            int row = q.front().first;\n            int col = q.front().second;\n            q.pop();\n            \n            for (int i = 0; i < 4; i++) {\n                int x = row + dirs[i][0];\n                int y = col + dirs[i][1];\n                \n                if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] != INT_MAX) {\n                    continue;\n                }\n                \n                grid[x][y] = grid[row][col] + 1;\n                q.push({x, y});\n            }\n        }\n    }\n};\n","java":"class Solution {\n    public void islandsAndTreasure(int[][] grid) {\n        Queue<int[]> q = new LinkedList<>();\n        int m = grid.length;\n        int n = grid[0].length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) q.add(new int[] { i, j });\n            }\n        }\n        if (q.size() == 0) return;\n        int[][] dirs = { { -1, 0 }, { 0, -1 }, { 1, 0 }, { 0, 1 } };\n        while (!q.isEmpty()) {\n            int[] cur = q.poll();\n            int row = cur[0];\n            int col = cur[1];\n            for (int[] dir : dirs) {\n                int x = row + dir[0];\n                int y = col + dir[1];\n                if (\n                    x >= m ||\n                    y >= n ||\n                    x < 0 ||\n                    y < 0 ||\n                    grid[x][y] != Integer.MAX_VALUE\n                ) continue;\n                q.add(new int[] { x, y });\n\n                grid[x][y] = grid[row][col] + 1;\n            }\n        }\n    }\n}\n","csharp":"public class Solution {\n    public void islandsAndTreasure(int[][] grid) {\n        Queue<int[]> q = new Queue<int[]>();\n        int m = grid.Length;\n        int n = grid[0].Length;\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) q.Enqueue(new int[] { i, j });\n            }\n        }\n\n        if (q.Count == 0) return;\n        \n        int[][] dirs = { new int[] { -1, 0 }, new int[] { 0, -1 }, new int[] { 1, 0 }, new int[] { 0, 1 } };\n        while (q.Count > 0) {\n            int[] cur = q.Dequeue();\n            int row = cur[0];\n            int col = cur[1];\n            foreach (int[] dir in dirs) {\n                int x = row + dir[0];\n                int y = col + dir[1];\n                if (\n                    x >= m ||\n                    y >= n ||\n                    x < 0 ||\n                    y < 0 ||\n                    grid[x][y] != int.MaxValue\n                ) continue;\n                q.Enqueue(new int[] { x, y });\n\n                grid[x][y] = grid[row][col] + 1;\n            }\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def islandsAndTreasure(self, grid: List[List[int]]) -> None:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     */\n    islandsAndTreasure(grid) {}\n}\n","cpp":"class Solution {\npublic:\n    void islandsAndTreasure(vector<vector<int>>& grid) {\n        \n    }\n};\n","java":"class Solution {\n    public void islandsAndTreasure(int[][] grid) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public void islandsAndTreasure(int[][] grid) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/e69C6xhiSQE"},{"id":"buy-and-sell-crypto","name":"Buy and Sell Crypto","description":"You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.\n\nYou may choose a **single day** to buy one NeetCoin and choose a **different day in the future** to sell it.\n\nReturn the maximum profit you can achieve. You may choose to **not make any transactions**, in which case the profit would be `0`.\n\n**Example 1:**\n\n```java\nInput: prices = [10,1,5,6,7,1]\n\nOutput: 6\n```\nExplanation: Buy `prices[1]` and sell `prices[4]`, `profit = 7 - 1 = 6`.\n\n**Example 2:**\n\n```java\nInput: prices = [10,8,7,5,2]\n\nOutput: 0\n```\n\nExplanation: No profitable transactions can be made, thus the max profit is 0.\n\n**Constraints:**\n* `1 <= prices.length <= 100`\n* `0 <= prices[i] <= 100`\n","difficulty":"Easy","concepts":["Sliding Window Fixed Size","Sliding Window Variable Size"],"solutions":{"python":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        res = 0\n        \n        lowest = prices[0]\n        for price in prices:\n            if price < lowest:\n                lowest = price\n            res = max(res, price - lowest)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} prices\n     * @return {number}\n     */\n    maxProfit(prices) {\n        let min = prices[0];\n        let max = min;\n        let value = 0;\n        for (let i = 0; i < prices.length; i++) {\n            if (i != prices.length - 1 && prices[i] <= min) {\n                max = min = prices[i];\n            } else if (prices[i] > max) {\n                max = prices[i];\n            }\n            value = max - min > value ? max - min : value;\n        }\n        return value;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        int maxP = 0, l = 0, r = 0;\n        while (r < prices.size()){\n            if (prices[r] > prices[l])\n                maxP = max(maxP, prices[r] - prices[l]);\n            else\n                l = r;\n            ++r;\n        }\n        return maxP;\n    }\n};\n","java":"class Solution {\n    public int maxProfit(int[] prices) {\n        int left = 0;\n        int right = 1;\n        int maxProfit = 0;\n        while (right < prices.length) {\n            if (prices[left] < prices[right]) {\n                maxProfit = Math.max(maxProfit, prices[right] - prices[left]);\n            } else {\n                left = right;\n            }\n            right++;\n        }\n        return maxProfit;\n    }\n}\n","csharp":"public class Solution {\n    public int MaxProfit(int[] prices) {\n        int maxProfit = 0;\n        int minPrice = prices[0];\n\n        for (int i = 1; i < prices.Length; i++) {\n            int currPrice = prices[i];\n            minPrice = Math.Min(minPrice, currPrice);\n            maxProfit = Math.Max(maxProfit, currPrice - minPrice);\n        }\n        return maxProfit;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} prices\n     * @return {number}\n     */\n    maxProfit(prices) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};\n","java":"class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/1pkOgXD63yU"},{"id":"validate-parentheses","name":"Validate Parentheses","description":"You are given a string `s` consisting of the following characters: `'('`, `')'`, `'{'`, `'}'`, `'['` and `']'`.\n\nThe input string `s` is valid if and only if:\n\n1. Every open bracket is closed by the same type of close bracket.\n2. Open brackets are closed in the correct order.\n3. Every close bracket has a corresponding open bracket of the same type.\n\nReturn `true` if `s` is a valid string, and `false` otherwise.\n\n**Example 1:**\n\n```java\nInput: s = \"[]\"\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: s = \"([{}])\"\n\nOutput: true\n```\n\n**Example 3:**\n\n```java\nInput: s = \"[(])\"\n\nOutput: false\n```\n\nExplanation: The brackets are not closed in the correct order.\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n","difficulty":"Easy","concepts":["Stacks"],"solutions":{"python":"class Solution:\n    def isValid(self, s: str) -> bool:\n        Map = {\")\": \"(\", \"]\": \"[\", \"}\": \"{\"}\n        stack = []\n\n        for c in s:\n            if c not in Map:\n                stack.append(c)\n                continue\n            if not stack or stack[-1] != Map[c]:\n                return False\n            stack.pop()\n\n        return not stack\n    ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {boolean}\n     */\n    isValid(s) {\n        const stack = [];\n        const map = {\n            '}': '{',\n            ']': '[',\n            ')': '(',\n        };\n\n        for (const char of s) {\n            const isBracket = char in map;\n            if (!isBracket) {\n                stack.push(char);\n                continue;\n            }\n\n            const isEqual = stack[stack.length - 1] === map[char];\n            if (isEqual) {\n                stack.pop();\n                continue;\n            }\n\n            return false;\n        }\n\n        return stack.length === 0;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isValid(string s) {\n        stack<char> open;\n        unordered_map<char, char> parens = {\n            {')', '('},\n            {']', '['},\n            {'}', '{'},\n        };\n        \n        for (const auto& c : s) {\n            if (parens.find(c) != parens.end()) {\n                if (open.empty()) {\n                    return false;\n                }\n\n                if (open.top() != parens[c]) {\n                    return false;\n                }\n\n                open.pop();\n            } else {\n                open.push(c);\n            }\n        }\n        \n        return open.empty();\n    }\n};\n","java":"class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> brackets = new Stack<>();\n        Map<Character, Character> bracketLookup = new HashMap<>(3);\n\n        bracketLookup.put(')', '(');\n        bracketLookup.put('}', '{');\n        bracketLookup.put(']', '[');\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (bracketLookup.containsKey(c)) {\n                if (!brackets.isEmpty() && bracketLookup.get(c).equals(brackets.peek())) {\n                    brackets.pop();\n                } else {\n                    return false;\n                }\n            } else {\n                brackets.push(c);\n            }\n        }\n\n        return brackets.isEmpty();\n    }\n}\n","csharp":"public class Solution {\n    public bool IsValid(string s) {\n        var stack = new Stack<char>();\n        var pairs = new Dictionary<char, char>() {\n            [')'] = '(',\n            [']'] = '[',\n            ['}'] = '{'\n        };\n\n        foreach (char c in s) {\n            if (!pairs.ContainsKey(c)) {\n                stack.Push(c);\n            } else if (stack.Count == 0 || stack.Pop() != pairs[c]) {\n                return false;\n            }\n        }\n\n        return stack.Count == 0;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isValid(self, s: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {boolean}\n     */\n    isValid(s) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isValid(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isValid(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsValid(string s) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/WTzjTskDFMg"},{"id":"find-minimum-in-rotated-sorted-array","name":"Find Minimum in Rotated Sorted Array","description":"You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:\n\n* `[3,4,5,6,1,2]` if it was rotated `4` times.\n* `[1,2,3,4,5,6]` if it was rotated `6` times.\n\nNotice that rotating the array `4` times moves the last four elements of the array to the beginning. Rotating the array `6` times produces the original array.\n\nAssuming all elements in the rotated sorted array `nums` are **unique**, return the minimum element of this array.\n\nA solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?\n\n**Example 1:**\n\n```java\nInput: nums = [3,4,5,6,1,2]\n\nOutput: 1\n```\n\n**Example 2:**\n\n```java\nInput: nums = [4,5,0,1,2,3]\n\nOutput: 0\n```\n\n**Example 3:**\n\n```java\nInput: nums = [4,5,6,7]\n\nOutput: 4\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n","difficulty":"Medium","concepts":["Search Array"],"solutions":{"python":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        start , end = 0, len(nums) - 1 \n        curr_min = float(\"inf\")\n        \n        while start  <  end :\n            mid = start + (end - start ) // 2\n            curr_min = min(curr_min,nums[mid])\n            \n            # right has the min \n            if nums[mid] > nums[end]:\n                start = mid + 1\n                \n            # left has the  min \n            else:\n                end = mid - 1 \n                \n        return min(curr_min,nums[start])\n    ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    findMin(nums) {\n        let [left, right] = [0, nums.length - 1];\n\n        while (left < right) {\n            const mid = (left + right) >> 1;\n            const guess = nums[mid];\n            const [leftNum, rightNum] = [nums[left], nums[right]];\n\n            const isTarget = leftNum < rightNum;\n            if (isTarget) return leftNum;\n\n            const isTargetGreater = leftNum <= guess;\n            if (isTargetGreater) left = mid + 1;\n\n            const isTargetLess = guess < leftNum;\n            if (isTargetLess) right = mid;\n        }\n\n        return nums[left];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int findMin(vector<int> &nums) {\n        int res = nums[0];\n        int l = 0;\n        int r = nums.size() - 1;\n\n        while (l <= r) {\n            if (nums[l] < nums[r]) {\n                res = min(res, nums[l]);\n                break;\n            }\n            int mid = l + (r - l) / 2;\n            res = min(res, nums[mid]);\n\n            if (nums[mid] >= nums[l]) {\n                l = mid + 1; \n            }\n            else {\n                r = mid - 1;\n            }\n        }\n\n        return res;\n    }\n};\n","java":"class Solution {\n    public int findMin(int[] nums) {\n        int l = 0;\n        int r = nums.length - 1;\n\n        while (l <= r) {\n            if (nums[l] <= nums[r]) {\n                return nums[l];\n            }\n\n            int mid = (l + r) / 2;\n            if (nums[mid] >= nums[l]) {\n                l = mid + 1;\n            } else {\n                r = mid;\n            }\n        }\n        return 0;\n    }\n}\n","csharp":"public class Solution {\n    public int FindMin(int[] nums) {\n        int left = 0, right = nums.Length - 1;\n        while (left <= right) {\n            if (nums[left] <= nums[right]) {\n                return nums[left];\n            }\n            int mid = (left + right) / 2;\n            if (nums[mid] >= nums[left]) {\n                left = mid + 1;\n            }\n            else {\n                right = mid;\n            }\n        }\n        return 0;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findMin(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    findMin(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int findMin(vector<int> &nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int findMin(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int FindMin(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/nIVW4P8b1VA"},{"id":"reverse-a-linked-list","name":"Reverse a Linked List","description":"Given the beginning of a singly linked list `head`, reverse the list, and return the new beginning of the list.\n\n**Example 1:**\n\n```java\nInput: head = [0,1,2,3]\n\nOutput: [3,2,1,0]\n```\n\n**Example 2:**\n\n```java\nInput: head = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The length of the list <= 1000`.\n* `-1000 <= Node.val <= 1000`\n","difficulty":"Easy","concepts":["Singly Linked Lists"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: ListNode) -> ListNode:\n        prev, curr = None, head\n\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n        return prev\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @return {ListNode}\n     */\n    reverseList(head) {\n        let [prev, curr, next] = [null, head, null];\n\n        while (curr) {\n            next = curr.next;\n            curr.next = prev;\n\n            prev = curr;\n            curr = next;\n        }\n\n        return prev;\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (head == NULL || head->next == NULL)\n            return head;\n\n        ListNode *prev = NULL;\n        ListNode *curr = head;\n\n        while (curr != NULL) {\n            ListNode *temp = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = temp;\n        }\n        return prev;\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode current = head;\n        ListNode previous = null;\n        ListNode nextCurrent = null;\n    \n        while (current != null) {\n            nextCurrent = current.next;\n            current.next = previous;\n            previous = current;\n            current = nextCurrent;\n        }\n\n        return previous;\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n \npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        ListNode prev = null, curr = head;\n\n        while (curr != null) {\n            var temp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = temp;\n        }\n        return prev;\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @return {ListNode}\n     */\n    reverseList(head) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        \n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n \npublic class Solution {\n    public ListNode ReverseList(ListNode head) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/G0_I-ZF0S38"},{"id":"invert-a-binary-tree","name":"Invert a Binary Tree","description":"You are given the root of a binary tree `root`. Invert the binary tree and return its root.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ac124ee6-207f-41f6-3aaa-dfb35815f200/public)\n\n```java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [1,3,2,7,6,5,4]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e39e8d4f-9946-4f99-ee3d-0d4df08d4d00/public)\n\n```java\nInput: root = [3,2,1]\n\nOutput: [3,1,2]\n```\n\n**Example 3:**\n\n```java\nInput: root = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The number of nodes in the tree <= 100`.\n* `-100 <= Node.val <= 100`\n","difficulty":"Easy","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        if not root: return None\n\n        root.left, root.right = root.right, root.left\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {TreeNode}\n     */\n    invertTree(root) {\n        if (root === null) return null;\n\n        const node = new TreeNode(root.val);\n\n        node.right = this.invertTree(root.left);\n        node.left = this.invertTree(root.right);\n\n        return node;\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if (root == nullptr) return nullptr;\n\n        TreeNode* node = new TreeNode(root->val);\n        \n        node->right = invertTree(root->left);\n        node->left = invertTree(root->right);\n\n        return node;\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) return null;\n        \n        TreeNode node = new TreeNode(root.val);\n\n        node.right = invertTree(root.left);\n        node.left = invertTree(root.right);\n        \n        return node;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode InvertTree(TreeNode root) {\n        if (root == null) return null;\n\n        TreeNode node = new TreeNode(root.val);\n        \n        node.right = InvertTree(root.left);\n        node.left = InvertTree(root.right);\n\n        return node;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {TreeNode}\n     */\n    invertTree(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode InvertTree(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/OnSn2XEQ4MY"},{"id":"implement-prefix-tree","name":"Implement Prefix Tree","description":"A **prefix tree** (also known as a trie) is a tree data structure used to efficiently store and retrieve keys in a set of strings. Some applications of this data structure include auto-complete and spell checker systems.\n\nImplement the PrefixTree class:\n* `PrefixTree()` Initializes the prefix tree object.\n* `void insert(String word)` Inserts the string `word` into the prefix tree.\n* `boolean search(String word)` Returns `true` if the string `word` is in the prefix tree (i.e., was inserted before), and `false` otherwise.\n* `boolean startsWith(String prefix)` Returns `true` if there is a previously inserted string `word` that has the prefix `prefix`, and `false` otherwise.\n\n**Example 1:**\n\n```java\nInput: \n[\"Trie\", \"insert\", \"dog\", \"search\", \"dog\", \"search\", \"do\", \"startsWith\", \"do\", \"insert\", \"do\", \"search\", \"do\"]\n\nOutput:\n[null, null, true, false, true, null, true]\n\nExplanation:\nPrefixTree prefixTree = new PrefixTree();\nprefixTree.insert(\"dog\");\nprefixTree.search(\"dog\");    // return true\nprefixTree.search(\"do\");     // return false\nprefixTree.startsWith(\"do\"); // return true\nprefixTree.insert(\"do\");\nprefixTree.search(\"do\");     // return true\n```\n\n**Constraints:**\n* `1 <= word.length, prefix.length <= 1000`\n* `word` and `prefix` are made up of lowercase English letters.\n","difficulty":"Medium","concepts":["Trie"],"solutions":{"python":"class PrefixTreeNode:\n    def __init__(self):\n        self.children = [None] * 26\n        self.end = False\n\nclass PrefixTree:\n    def __init__(self):\n        self.root = PrefixTreeNode()\n\n    def insert(self, word: str) -> None:\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] == None:\n                curr.children[i] = PrefixTreeNode()\n            curr = curr.children[i]\n        curr.end = True\n\n    def search(self, word: str) -> bool:\n        curr = self.root\n        for c in word:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] == None:\n                return False\n            curr = curr.children[i]\n        return curr.end\n\n    def startsWith(self, prefix: str) -> bool:\n        curr = self.root\n        for c in prefix:\n            i = ord(c) - ord(\"a\")\n            if curr.children[i] == None:\n                return False\n            curr = curr.children[i]\n        return True\n","javascript":"class PrefixTreeNode {\n    constructor() {\n        this.children = {};\n        this.isWord = false;\n    }\n}\n\nclass PrefixTree {\n    constructor() {\n        this.root = new PrefixTreeNode();\n    }\n\n    /**\n     * @param {string} word\n     * @return {void}\n     */\n    insert(word) {\n        let node = this.root;\n\n        for (const char of word) {\n            const child = node.children[char] || new PrefixTreeNode();\n            node.children[char] = child;\n            node = child;\n        }\n\n        node.isWord = true;\n    }\n\n    /**\n     * @param {string} word\n     * @return {boolean}\n     */\n    search(word) {\n        let node = this.root;\n\n        for (const char of word) {\n            const child = node.children[char] || null;\n\n            if (!child) return false;\n\n            node = child;\n        }\n\n        return node.isWord;\n    }\n\n    /**\n     * @param {string} prefix\n     * @return {boolean}\n     */\n    startsWith(prefix) {\n        let node = this.root;\n\n        for (const char of prefix) {\n            const child = node.children[char] || null;\n\n            if (!child) return false;\n\n            node = child;\n        }\n\n        return true;\n    }\n}\n","cpp":"class PrefixTreeNode {\npublic:\n    PrefixTreeNode* children[26];\n    bool isWord;\n    \n    PrefixTreeNode() {\n        for (int i = 0; i < 26; i++) {\n            children[i] = NULL;\n        }\n        isWord = false;\n    }\n};\n\nclass PrefixTree {\npublic:\n    PrefixTree() {\n        root = new PrefixTreeNode();\n    }\n    \n    void insert(string word) {\n        PrefixTreeNode* node = root;\n        int curr = 0;\n        \n        for (int i = 0; i < word.size(); i++) {\n            curr = word[i] - 'a';\n            if (node->children[curr] == NULL) {\n                node->children[curr] = new PrefixTreeNode();\n            }\n            node = node->children[curr];\n        }\n        \n        node->isWord = true;\n    }\n    \n    bool search(string word) {\n        PrefixTreeNode* node = root;\n        int curr = 0;\n        \n        for (int i = 0; i < word.size(); i++) {\n            curr = word[i] - 'a';\n            if (node->children[curr] == NULL) {\n                return false;\n            }\n            node = node->children[curr];\n        }\n        \n        return node->isWord;\n    }\n    \n    bool startsWith(string prefix) {\n        PrefixTreeNode* node = root;\n        int curr = 0;\n        \n        for (int i = 0; i < prefix.size(); i++) {\n            curr = prefix[i] - 'a';\n            if (node->children[curr] == NULL) {\n                return false;\n            }\n            node = node->children[curr];\n        }\n        \n        return true;\n    }\n    \nprivate:\n    PrefixTreeNode* root;\n};\n","java":"class PrefixTree {\n    \n    PrefixTreeNode root;\n\n    public PrefixTree() {\n        root = new PrefixTreeNode('\\0'); \n    }\n\n    class PrefixTreeNode {\n\n        private char value;\n        private boolean isWord;\n        private PrefixTreeNode[] children;\n\n        public PrefixTreeNode(char val) {\n            this.value = val;\n            this.isWord = false;\n            this.children = new PrefixTreeNode[26];\n        }\n    }\n\n    public void insert(String word) {\n        PrefixTreeNode curr = root;\n        for (char x : word.toCharArray()) {\n            if (curr.children[x - 'a'] == null) {\n                curr.children[x - 'a'] = new PrefixTreeNode(x);\n            }\n            curr = curr.children[x - 'a'];\n        }\n        curr.isWord = true;\n    }\n\n    public boolean search(String word) {\n        PrefixTreeNode res = getLast(word);\n        return (res != null && res.isWord);\n    }\n\n    //helper method\n    private PrefixTreeNode getLast(String word) {\n        PrefixTreeNode curr = root;\n        for (char x : word.toCharArray()) {\n            if (curr.children[x - 'a'] == null) {\n                return null;\n            }\n\n            curr = curr.children[x - 'a'];\n        }\n        return curr;\n    }\n\n    public boolean startsWith(String prefix) {\n        PrefixTreeNode res = getLast(prefix);\n        if (res == null) return false;\n        return true;\n    }\n}\n","csharp":"public class PrefixTreeNode {\n    public PrefixTreeNode() {\n        childrenMap = new Dictionary<char, PrefixTreeNode>();\n    }\n    public Dictionary<char, PrefixTreeNode> childrenMap { get; set; }\n    public bool isWord{ get; set; }\n}\n\npublic class PrefixTree {\n\n    private PrefixTreeNode root;\n\n    public PrefixTree() {\n        root = new PrefixTreeNode();\n    }\n    \n    public void Insert(string word) {\n        var cur = root;\n        foreach(var c in word) {\n            if(!cur.childrenMap.ContainsKey(c)) {\n                cur.childrenMap[c] = new PrefixTreeNode();\n            }\n            cur = cur.childrenMap[c];\n        }\n        cur.isWord = true;\n    }\n    \n    public bool Search(string word) {\n        var node = traverse(word);\n        return node != null && node.isWord;\n    }\n    \n    public bool StartsWith(string prefix) {\n        var node = traverse(prefix);\n        return node!= null;\n    }\n    \n    private PrefixTreeNode traverse(string path) {\n        var cur = root;\n        \n        foreach(var c in path) {\n            if(cur.childrenMap.ContainsKey(c)){\n                cur = cur.childrenMap[c];\n            }\n            else {\n                return null;\n            }\n        }\n        return cur;\n    }\n}\n"},"starterCode":{"python":"class PrefixTree:\n\n    def __init__(self):\n        \n\n    def insert(self, word: str) -> None:\n\n\n    def search(self, word: str) -> bool:\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        \n        ","javascript":"class PrefixTree {\n    constructor() {}\n\n    /**\n     * @param {string} word\n     * @return {void}\n     */\n    insert(word) {}\n\n    /**\n     * @param {string} word\n     * @return {boolean}\n     */\n    search(word) {}\n\n    /**\n     * @param {string} prefix\n     * @return {boolean}\n     */\n    startsWith(prefix) {}\n}\n","cpp":"class PrefixTree {\npublic:\n    PrefixTree() {\n        \n    }\n    \n    void insert(string word) {\n        \n    }\n    \n    bool search(string word) {\n        \n    }\n    \n    bool startsWith(string prefix) {\n        \n    }\n};\n","java":"class PrefixTree {\n\n    public PrefixTree() {\n         \n    }\n\n    public void insert(String word) {\n\n    }\n\n    public boolean search(String word) {\n\n    }\n\n    public boolean startsWith(String prefix) {\n\n    }\n}\n","csharp":"public class PrefixTree {\n\n    public PrefixTree() {\n        \n    }\n    \n    public void Insert(string word) {\n        \n    }\n    \n    public bool Search(string word) {\n        \n    }\n    \n    public bool StartsWith(string prefix) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/oobqoCJlHA0"},{"id":"find-median-in-a-data-stream","name":"Find Median in a Data Stream","description":"The **[median](https://en.wikipedia.org/wiki/Median)** is the middle value in a sorted list of integers. For lists of *even* length, there is no middle value, so the median is the [mean](https://en.wikipedia.org/wiki/Mean) of the two middle values.\n\nFor example:\n* For `arr = [1,2,3]`, the median is `2`.\n* For `arr = [1,2]`, the median is `(1 + 2) / 2 = 1.5`\n\nImplement the MedianFinder class:\n\n* `MedianFinder()` initializes the `MedianFinder` object.\n* `void addNum(int num)` adds the integer `num` from the data stream to the data structure.\n* `double findMedian()` returns the median of all elements so far.\n\n**Example 1:**\n\n```java\nInput:\n[\"MedianFinder\", \"addNum\", \"1\", \"findMedian\", \"addNum\", \"3\" \"findMedian\", \"addNum\", \"2\", \"findMedian\"]\n\nOutput:\n[null, null, 1.0, null, 2.0, null, 2.0]\n\nExplanation:\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.findMedian(); // return 1.0\nmedianFinder.addNum(3);    // arr = [1, 3]\nmedianFinder.findMedian(); // return 2.0\nmedianFinder.addNum(2);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n```\n\n**Constraints:**\n* `-100,000 <= num <= 100,000`\n* `findMedian` will only be called after adding at least one integer to the data structure.\n","difficulty":"Hard","concepts":["Heap Properties","Push and Pop","Two Heaps"],"solutions":{"python":"class MedianFinder:\n    def __init__(self):\n        # two heaps, large, small, minheap, maxheap\n        # heaps should be equal size\n        self.small, self.large = [], []  # maxHeap, minHeap (python default)\n\n    def addNum(self, num: int) -> None:\n        if self.large and num > self.large[0]:\n            heapq.heappush(self.large, num)\n        else:\n            heapq.heappush(self.small, -1 * num)\n\n        if len(self.small) > len(self.large) + 1:\n            val = -1 * heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) > len(self.small) + 1:\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -1 * val)\n\n    def findMedian(self) -> float:\n        if len(self.small) > len(self.large):\n            return -1 * self.small[0]\n        elif len(self.large) > len(self.small):\n            return self.large[0]\n        return (-1 * self.small[0] + self.large[0]) / 2.0\n","javascript":"/**\n * const { PriorityQueue, MaxPriorityQueue, MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass MedianFinder {\n    constructor() {\n        this.small = new PriorityQueue((a, b) => b - a); // Max heap for smaller half\n        this.large = new PriorityQueue((a, b) => a - b); // Min heap for larger half\n    }\n\n    /**\n     * Adds a number into the data structure.\n     * @param {number} num\n     */\n    addNum(num) {\n        if (this.large.isEmpty() || num > this.large.front()) {\n            this.large.enqueue(num);\n        } else {\n            this.small.enqueue(num);\n        }\n\n        // Balance the heaps to make sure their sizes differ by no more than 1\n        if (this.small.size() > this.large.size() + 1) {\n            this.large.enqueue(this.small.dequeue());\n        } else if (this.large.size() > this.small.size() + 1) {\n            this.small.enqueue(this.large.dequeue());\n        }\n    }\n\n    /**\n     * Finds the median of all numbers added so far.\n     * @return {number}\n     */\n    findMedian() {\n        if (this.small.size() > this.large.size()) {\n            return this.small.front();\n        } else if (this.large.size() > this.small.size()) {\n            return this.large.front();\n        } else {\n            // If both heaps are of the same size, the median is the average of the two heap tops\n            return (this.small.front() + this.large.front()) / 2.0;\n        }\n    }\n}\n","cpp":"class MedianFinder {\npublic:\n    MedianFinder() {\n        \n    }\n    \n    void addNum(int num) {\n        if (lower.empty()) {\n            lower.push(num);\n            return;\n        }\n        \n        if (lower.size() > higher.size()) {\n            if (lower.top() > num) {\n                higher.push(lower.top());\n                lower.pop();\n                lower.push(num);\n            } else {\n                higher.push(num);\n            }\n        } else {\n            if (num > higher.top()) {\n                lower.push(higher.top());\n                higher.pop();\n                higher.push(num);\n            } else {\n                lower.push(num);\n            }\n        }\n    }\n    \n    double findMedian() {\n        double result = 0.0;\n        \n        if (lower.size() == higher.size()) {\n            result = lower.top() + (higher.top() - lower.top()) / 2.0;\n        } else {\n            if (lower.size() > higher.size()) {\n                result = lower.top();\n            } else {\n                result = higher.top();\n            }\n        }\n        \n        return result;\n    }\nprivate:\n    priority_queue<int> lower;\n    priority_queue<int, vector<int>, greater<int>> higher;\n};\n","java":"class MedianFinder {\n\n    private Queue<Integer> smallHeap; //small elements - maxHeap\n    private Queue<Integer> largeHeap; //large elements - minHeap\n\n    public MedianFinder() {\n        smallHeap = new PriorityQueue<>((a, b) -> b - a);\n        largeHeap = new PriorityQueue<>((a, b) -> a - b);\n    }\n\n    public void addNum(int num) {\n        smallHeap.add(num);\n        if (\n            smallHeap.size() - largeHeap.size() > 1 ||\n            !largeHeap.isEmpty() &&\n            smallHeap.peek() > largeHeap.peek()\n        ) {\n            largeHeap.add(smallHeap.poll());\n        }\n        if (largeHeap.size() - smallHeap.size() > 1) {\n            smallHeap.add(largeHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (smallHeap.size() == largeHeap.size()) {\n            return (double) (largeHeap.peek() + smallHeap.peek()) / 2;\n        } else if (smallHeap.size() > largeHeap.size()) {\n            return (double) smallHeap.peek();\n        } else {\n            return (double) largeHeap.peek();\n        }\n    }\n}\n","csharp":"public class MedianFinder {\n\n    private PriorityQueue<int, int> small; // Max heap for the smaller half\n    private PriorityQueue<int, int> large; // Min heap for the larger half\n\n    public MedianFinder() {\n        small = new PriorityQueue<int, int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));\n        large = new PriorityQueue<int, int>();\n    }\n    \n    public void AddNum(int num) {\n        if (large.Count != 0 && num > large.Peek()) {\n            large.Enqueue(num, num);\n        } else {\n            small.Enqueue(num, num);\n        }\n\n        // Ensure the heaps are balanced\n        if (small.Count > large.Count + 1) {\n            int val = small.Dequeue();\n            large.Enqueue(val, val);\n        } else if (large.Count > small.Count + 1) {\n            int val = large.Dequeue();\n            small.Enqueue(val, val);\n        }\n    }\n    \n    public double FindMedian() {\n        if (small.Count > large.Count) {\n            return small.Peek();\n        } else if (large.Count > small.Count) {\n            return large.Peek();\n        }\n        \n        int smallTop = small.Peek();\n        return (smallTop + large.Peek()) / 2.0;\n    }\n}\n"},"starterCode":{"python":"class MedianFinder:\n\n    def __init__(self):\n        \n\n    def addNum(self, num: int) -> None:\n        \n\n    def findMedian(self) -> float:\n        \n        ","javascript":"class MedianFinder {\n    constructor() {}\n\n    /**\n     *\n     * @param {number} num\n     * @return {void}\n     */\n    addNum(num) {}\n\n    /**\n     * @return {number}\n     */\n    findMedian() {}\n}\n","cpp":"class MedianFinder {\npublic:\n    MedianFinder() {\n        \n    }\n    \n    void addNum(int num) {\n        \n    }\n    \n    double findMedian() {\n        \n    }\n};\n","java":"class MedianFinder {\n\n    public MedianFinder() {\n        \n    }\n    \n    public void addNum(int num) {\n        \n    }\n    \n    public double findMedian() {\n        \n    }\n}\n","csharp":"public class MedianFinder {\n\n    public MedianFinder() {\n        \n    }\n    \n    public void AddNum(int num) {\n        \n    }\n    \n    public double FindMedian() {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/itmhHWaHupI"},{"id":"combination-target-sum","name":"Combination Target Sum","description":"You are given an array of **distinct** integers `nums` and a target integer `target`. Your task is to return a list of all **unique combinations** of `nums` where the chosen numbers sum to `target`.\n\nThe **same** number may be chosen from `nums` an **unlimited number of times**. Two combinations are the same if the frequency of each of the chosen numbers is the same, otherwise they are different.\n\nYou may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.\n\n**Example 1:**\n\n```java\nInput: \nnums = [2,5,6,9] \ntarget = 9\n\nOutput: [[2,2,5],[9]]\n```\n\nExplanation:\n2 + 2 + 5 = 9. We use 2 twice, and 5 once.\n9 = 9. We use 9 once.\n\n**Example 2:**\n\n```java\nInput: \nnums = [3,4,5]\ntarget = 16\n\nOutput: [[3,3,3,3,4],[3,3,5,5],[4,4,4,4],[3,4,4,5]]\n```\n\n**Example 3:**\n\n```java\nInput: \nnums = [3]\ntarget = 5\n\nOutput: []\n```\n\n**Constraints:**\n* All elements of `nums` are **distinct**.\n* `1 <= nums.length <= 20`\n* `2 <= nums[i] <= 30`\n* `2 <= target <= 30`\n","difficulty":"Medium","concepts":["Tree Maze","Combinations"],"solutions":{"python":"class Solution:\n    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:\n        res = []\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if i >= len(nums) or total > target:\n                return\n\n            cur.append(nums[i])\n            dfs(i, cur, total + nums[i])\n            cur.pop()\n            dfs(i + 1, cur, total)\n\n        dfs(0, [], 0)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @returns {number[][]}\n     */\n    combinationSum(nums, target) {\n        let ans = [];\n        let cur = [];\n        this.backtrack(nums, target, ans, cur, 0);\n        return ans;\n    }\n\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @param {number[][]} ans\n     * @param {number[]} cur\n     * @param {number} index\n     */\n    backtrack(nums, target, ans, cur, index) {\n        if (target === 0) {\n            ans.push([...cur]);\n        } else if (target < 0 || index >= nums.length) {\n            return;\n        } else {\n            cur.push(nums[index]);\n            this.backtrack(nums, target - nums[index], ans, cur, index);\n\n            cur.pop();\n            this.backtrack(nums, target, ans, cur, index + 1);\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\n        vector<int> curr;\n        vector<vector<int>> res;\n        helper(nums, target, 0, curr, res);\n        return res;\n    }\n\nprivate:\n    void helper(vector<int>& cands, int target, int i, vector<int>& curr,  vector<vector<int>>& res) {\n        if (i >= cands.size() || target < 0)\n            return;\n\n        if (target == 0) {\n            res.push_back(curr);\n            return;\n        }\n\n        curr.push_back(cands[i]);\n        \n        helper(cands, target - cands[i], i, curr, res);\n\n        curr.pop_back();\n\n        helper(cands, target, i + 1, curr, res);\n    }\n};\n","java":"class Solution {\n\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\n        List<Integer> cur = new ArrayList();\n        backtrack(nums, target, ans, cur, 0);\n        return ans;\n    }\n\n    public void backtrack(\n        int[] nums,\n        int target,\n        List<List<Integer>> ans,\n        List<Integer> cur,\n        int index\n    ) {\n        if (target == 0) {\n            ans.add(new ArrayList(cur));\n        } else if (target < 0 || index >= nums.length) {\n            return;\n        } else {\n            cur.add(nums[index]);\n            backtrack(nums, target - nums[index], ans, cur, index);\n\n            cur.remove(cur.get(cur.size() - 1));\n            backtrack(nums, target, ans, cur, index + 1);\n        }\n    }\n}\n","csharp":"public class Solution {\n    \n    List<List<int>> result = new List<List<int>>();\n\n    public void backtrack(int index, List<int> path, int total, int[] nums, int target) {\n        if(total == target) {\n            result.Add(path.ToList());\n            return;\n        }\n        \n        if(total > target || index >= nums.Length) return;\n        \n        path.Add(nums[index]);\n        backtrack(index, \n                  path, \n                  total + nums[index], \n                  nums, \n                  target);\n        \n        path.Remove(path.Last());\n        \n        backtrack(index + 1, \n                  path, \n                  total, \n                  nums, \n                  target);\n        \n    }\n    public List<List<int>> CombinationSum(int[] nums, int target) {\n        backtrack(0, new List<int>(), 0, nums, target);\n        return result;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def combinationSum(self, nums: List[int], target: int) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @returns {number[][]}\n     */\n    combinationSum(nums, target) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> combinationSum(vector<int>& nums, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> CombinationSum(int[] nums, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/GBKI9VSKdGg"},{"id":"count-number-of-islands","name":"Count Number of Islands","description":"Given a 2D grid `grid` where `'1'` represents land and `'0'` represents water, count and return the number of islands.\n\nAn **island** is formed by connecting adjacent lands horizontally or vertically and is surrounded by water. You may assume water is surrounding the grid (i.e., all the edges are water).   \n\n**Example 1:**\n\n```java\nInput: grid = [\n    [\"0\",\"1\",\"1\",\"1\",\"0\"],\n    [\"0\",\"1\",\"0\",\"1\",\"0\"],\n    [\"1\",\"1\",\"0\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"0\",\"0\"]\n  ]\nOutput: 1\n```\n\n**Example 2:**\n\n```java\nInput: grid = [\n    [\"1\",\"1\",\"0\",\"0\",\"1\"],\n    [\"1\",\"1\",\"0\",\"0\",\"1\"],\n    [\"0\",\"0\",\"1\",\"0\",\"0\"],\n    [\"0\",\"0\",\"0\",\"1\",\"1\"]\n  ]\nOutput: 4\n```\n\n\n**Constraints:**\n* `1 <= grid.length, grid[i].length <= 100`\n* `grid[i][j]` is `'0'` or `'1'`.\n","difficulty":"Medium","concepts":["Matrix DFS","Matrix BFS"],"solutions":{"python":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        if not grid or not grid[0]:\n            return 0\n\n        islands = 0\n        visit = set()\n        rows, cols = len(grid), len(grid[0])\n\n        def dfs(r, c):\n            if (\n                r not in range(rows)\n                or c not in range(cols)\n                or grid[r][c] == \"0\"\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n            for dr, dc in directions:\n                dfs(r + dr, c + dc)\n\n        for r in range(rows):\n            for c in range(cols):\n                if grid[r][c] == \"1\" and (r, c) not in visit:\n                    islands += 1\n                    dfs(r, c)\n        return islands\n","javascript":"class Solution {\n    /**\n     * @param {character[][]} grid\n     * @return {number}\n     */\n    numIslands(grid) {\n        let count = 0;\n        for (let i = 0; i < grid.length; i++) {\n            for (let j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] === '1') {\n                    this.dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    /**\n     * @param {character[][]} grid\n     * @param {number} i\n     * @param {number} j\n     */\n    dfs(grid, i, j) {\n        if (\n            i < 0 ||\n            j < 0 ||\n            i >= grid.length ||\n            j >= grid[0].length ||\n            grid[i][j] === '0'\n        ) {\n            return;\n        }\n        grid[i][j] = '0';\n        this.dfs(grid, i + 1, j);\n        this.dfs(grid, i, j + 1);\n        this.dfs(grid, i - 1, j);\n        this.dfs(grid, i, j - 1);\n    }\n}\n","cpp":"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        int result = 0;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j, m, n);\n                    result++;\n                }\n            }\n        }\n        \n        return result;\n    }\nprivate:\n    void dfs(vector<vector<char>>& grid, int i, int j, int m, int n) {\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == '0') {\n            return;\n        }\n        grid[i][j] = '0';\n        \n        dfs(grid, i - 1, j, m, n);\n        dfs(grid, i + 1, j, m, n);\n        dfs(grid, i, j - 1, m, n);\n        dfs(grid, i, j + 1, m, n);\n    }\n};\n","java":"class Solution {\n\n    public int numIslands(char[][] grid) {\n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '1') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public void dfs(char[][] grid, int i, int j) {\n        if (\n            i < 0 ||\n            j < 0 ||\n            i >= grid.length ||\n            j >= grid[0].length ||\n            grid[i][j] == '0'\n        ) {\n            return;\n        }\n        grid[i][j] = '0';\n        dfs(grid, i + 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j - 1);\n    }\n}\n","csharp":"public class Solution {\n\n    public int NumIslands(char[][] grid) {\n        int count = 0;\n        for (int i = 0; i < grid.Length; i++) {\n            for (int j = 0; j < grid[0].Length; j++) {\n                if (grid[i][j] == '1') {\n                    Dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    public void Dfs(char[][] grid, int i, int j) {\n        if (\n            i < 0 ||\n            j < 0 ||\n            i >= grid.Length ||\n            j >= grid[0].Length ||\n            grid[i][j] == '0'\n        ) {\n            return;\n        }\n        grid[i][j] = '0';\n        Dfs(grid, i + 1, j);\n        Dfs(grid, i, j + 1);\n        Dfs(grid, i - 1, j);\n        Dfs(grid, i, j - 1);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {character[][]} grid\n     * @return {number}\n     */\n    numIslands(grid) {}\n}\n","cpp":"class Solution {\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        \n    }\n};\n","java":"class Solution {\n    public int numIslands(char[][] grid) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int NumIslands(char[][] grid) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/pV2kpPD66nE"},{"id":"climbing-stairs","name":"Climbing Stairs","description":"You are given an integer `n` representing the number of steps to reach the top of a staircase. You can climb with either `1` or `2` steps at a time.\n    \nReturn the number of distinct ways to climb to the top of the staircase.   \n\n**Example 1:**\n\n```java\nInput: n = 2\n\nOutput: 2\n```\n\nExplanation:\n1. `1 + 1 = 2`\n2. `2 = 2`\n\n**Example 2:**\n\n```java\nInput: n = 3\n\nOutput: 3\n```\n\nExplanation:\n1. `1 + 1 + 1 = 3`\n2. `1 + 2 = 3`\n3. `2 + 1 = 3`\n\n**Constraints:**\n* `1 <= n <= 30`\n","difficulty":"Easy","concepts":["Fibonacci Sequence","Tree Maze","1-Dimension DP"],"solutions":{"python":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n <= 3:\n            return n\n        n1, n2 = 2, 3\n\n        for i in range(4, n + 1):\n            temp = n1 + n2\n            n1 = n2\n            n2 = temp\n        return n2\n","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {number}\n     */\n    climbStairs(n) {\n        if (n <= 3) {\n            return n;\n        }\n        let n1 = 2;\n            let n2 = 3;\n        for (let i = 4; i <= n; i++) {\n            const temp = n1 + n2;\n            n1 = n2;\n            n2 = temp;\n        }\n        return n2;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int climbStairs(int n) {\n        if (n == 1) {\n            return 1;\n        }\n        if (n == 2) {\n            return 2;\n        }\n        \n        int first = 1;\n        int second = 2;\n        \n        int result = 0;\n        \n        for (int i = 2; i < n; i++) {\n            result = first + second;\n            first = second;\n            second = result;\n        }\n        \n        return result;\n    }\n};\n","java":"class Solution {\n    public int climbStairs(int n) {\n        int a = 1;\n        int b = 1;\n\n        for (int i = 0; i < n - 1; i++) {\n            int temp = a + b;\n            a = b;\n            b = temp;\n        }\n        return b;\n    }\n}\n","csharp":"public class Solution {\n    public int ClimbStairs(int n) {     \n        int one = 1;\n        int two = 1;\n        \n        for(int i = 0; i < n - 1; i++) {\n            int temp = one;\n            one = one + two;\n            two = temp;\n        }\n        \n        return one;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {number}\n     */\n    climbStairs(n) {}\n}\n","cpp":"class Solution {\npublic:\n    int climbStairs(int n) {\n        \n    }\n};\n","java":"class Solution {\n    public int climbStairs(int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int ClimbStairs(int n) {     \n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Y0lT9Fck7qI"},{"id":"count-paths","name":"Count Paths","description":"There is an `m x n` grid where you are allowed to move either down or to the right at any point in time.\n\nGiven the two integers `m` and `n`, return the number of possible unique paths that can be taken from the top-left corner of the grid (`grid[0][0]`) to the bottom-right corner (`grid[m - 1][n - 1]`).\n\nYou may assume the output will fit in a **32-bit** integer.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7eddce4e-2fc4-4c3a-bb0f-9d1060243500/public)\n\n```java\nInput: m = 3, n = 6\n\nOutput: 21\n```\n\n**Example 2:**\n\n```java\nInput: m = 3, n = 3\n\nOutput: 6\n```\n\n**Constraints:**\n* `1 <= m, n <= 100`\n","difficulty":"Medium","concepts":["Matrix DFS","2-Dimension DP"],"solutions":{"python":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        row = [1] * n\n\n        for i in range(m - 1):\n            newRow = [1] * n\n            for j in range(n - 2, -1, -1):\n                newRow[j] = newRow[j + 1] + row[j]\n            row = newRow\n        return row[0]\n","javascript":"class Solution {\n    /**\n     * @param {number} m\n     * @param {number} n\n     * @return {number}\n     */\n    uniquePaths(m, n) {\n        let row = new Array(n).fill(1);\n\n        for (let i = 0; i < m - 1; i++) {\n            const newRow = new Array(n).fill(1);\n            for (let j = n - 2; j >= 0; j--) {\n                newRow[j] = newRow[j + 1] + row[j];\n            }\n            row = newRow;\n        }\n        return row[0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        vector<int> row(n, 1);\n\n        for (int i = 0; i < m - 1; ++i) {\n            vector<int> newRow(n, 1);\n            for (int j = n - 2; j >= 0; --j) {\n                newRow[j] = newRow[j + 1] + row[j];\n            }\n            row = newRow;\n        }\n        return row[0];\n    }\n};\n","java":"class Solution {\n    public int uniquePaths(int m, int n) {\n        int[] row = new int[n];\n        Arrays.fill(row, 1);\n\n        for (int i = 0; i < m - 1; i++) {\n            int[] newRow = new int[n];\n            Arrays.fill(newRow, 1);\n            for (int j = n - 2; j >= 0; j--) {\n                newRow[j] = newRow[j + 1] + row[j];\n            }\n            row = newRow;\n        }\n        return row[0];\n    }\n}\n","csharp":"public class Solution {\n    public int UniquePaths(int m, int n) {\n        var row = new int[n];\n        Array.Fill(row, 1);\n        foreach (var i in Enumerable.Range(0, m - 1)) {\n            var newRow = new int[n];\n            Array.Fill(newRow, 1);\n            for (int j = n - 2; j >=0; j--) { \n                    newRow[j] = newRow[j + 1] + row[j];\n            }\n            row = newRow;\n        }\n        return row[0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} m\n     * @param {number} n\n     * @return {number}\n     */\n    uniquePaths(m, n) {}\n}\n","cpp":"class Solution {\npublic:\n    int uniquePaths(int m, int n) {\n        \n    }\n};\n","java":"class Solution {\n    public int uniquePaths(int m, int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int UniquePaths(int m, int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/IlEsdxuD4lY"},{"id":"maximum-subarray","name":"Maximum Subarray","description":"Given an array of integers `nums`, find the subarray with the largest sum and return the sum.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\n**Example 1:**\n\n```java\nInput: nums = [2,-3,4,-2,2,1,-1,4]\n\nOutput: 8\n```\n\nExplanation: The subarray [4,-2,2,1,-1,4] has the largest sum 8.\n\n**Example 2:**\n\n```java\nInput: nums = [-1]\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n","difficulty":"Medium","concepts":["Kadane's Algorithm"],"solutions":{"python":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        res = nums[0]\n\n        total = 0\n        for n in nums:\n            total += n\n            res = max(res, total)\n            if total < 0:\n                total = 0\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    maxSubArray(nums) {\n        let [runningSum, maxSum] = [nums[0], nums[0]];\n\n        for (let i = 1; i < nums.length; i++) {\n            const num = nums[i];\n            const sum = runningSum + num;\n\n            runningSum = Math.max(num, sum);\n            maxSum = Math.max(maxSum, runningSum);\n        }\n\n        return maxSum;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n        int curr = nums[0];\n        int result = nums[0];\n        \n        for (int i = 1; i < nums.size(); i++) {\n            curr = max(curr + nums[i], nums[i]);\n            result = max(result, curr);\n        }\n        \n        return result;\n    }\n};\n","java":"class Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums.length == 1) return nums[0];\n\n        int sum = 0;\n        int max = nums[0];\n\n        for (int n : nums) {\n            sum += n;\n            max = Math.max(max, sum);\n\n            if (sum < 0) {\n                sum = 0;\n            }\n        }\n        return max;\n    }\n}\n","csharp":"public class Solution {\n    public int MaxSubArray(int[] nums) {\n        int maxSub = nums[0];\n        int curSum = 0;\n        \n        for(int i = 0; i < nums.Length; i++){\n            if(curSum < 0){\n                curSum = 0;\n            }\n            curSum += nums[i];\n            maxSub = Math.Max(maxSub, curSum);            \n        }\n        return maxSub;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    maxSubArray(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxSubArray(vector<int>& nums) {\n\n    }\n};\n","java":"class Solution {\n    public int maxSubArray(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxSubArray(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/5WZl3MMT0Eg"},{"id":"number-of-one-bits","name":"Number of One Bits","description":"You are given an unsigned integer `n`. Return the number of `1` bits in its binary representation.\n\nYou may assume `n` is a non-negative integer which fits within 32-bits.\n\n**Example 1:**\n\n```java\nInput: n = 00000000000000000000000000010111\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: n = 01111111111111111111111111111101\n\nOutput: 30\n```\n","difficulty":"Easy","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        res = 0\n        while n:\n            n &= n - 1\n            res += 1\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number} n - a positive integer\n     * @return {number}\n     */\n    hammingWeight(n) {\n        let count = 0;\n        while (n !== 0) {\n            n &= n - 1;\n            count++;\n        }\n\n        return count;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n        int bit = 0;\n        int result = 0;\n        \n        while (n != 0) {\n            bit = n & 1;\n            if (bit == 1) {\n                result++;\n            }\n            n = n >> 1;\n        }\n        \n        return result;\n    }\n};\n","java":"class Solution {\n    public int hammingWeight(int n) {\n        int count = 0;\n        while (n != 0) {\n            n = n & (n - 1);\n            count++;\n        }\n        return count;\n    }\n}\n","csharp":"public class Solution {\n    public int HammingWeight(uint n) {\n        int count = 0;\n        while (n != 0) {\n            n = n & (n - 1);\n            count++;\n        }\n        return count;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def hammingWeight(self, n: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n - a positive integer\n     * @return {number}\n     */\n    hammingWeight(n) {}\n}\n","cpp":"class Solution {\npublic:\n    int hammingWeight(uint32_t n) {\n\n    }\n};\n","java":"class Solution {\n    public int hammingWeight(int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int HammingWeight(uint n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/5Km3utixwZs"},{"id":"products-of-array-discluding-self","name":"Products of Array Discluding Self","description":"Given an integer array `nums`, return an array `output` where `output[i]` is the product of all the elements of `nums` except `nums[i]`.\n\nEach product is **guaranteed** to fit in a **32-bit** integer.   \n\nFollow-up: Could you solve it in $O(n)$ time without using the division operation?\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,4,6]\n\nOutput: [48,24,12,8]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [-1,0,1,2,3]\n\nOutput: [0,-6,0,0,0]\n```\n\n**Constraints:**\n* `2 <= nums.length <= 1000`\n* `-20 <= nums[i] <= 20`\n","difficulty":"Medium","concepts":["Static Arrays","Prefix Sums"],"solutions":{"python":"class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        res = [1] * (len(nums))\n\n        for i in range(1, len(nums)):\n            res[i] = res[i-1] * nums[i-1]\n        postfix = 1\n        for i in range(len(nums) - 1, -1, -1):\n            res[i] *= postfix\n            postfix *= nums[i]\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[]}\n     */\n    productExceptSelf(nums) {\n        const result = [];\n        let prefix = 1;\n        let postfix = 1;\n\n        for (let i = 0; i < nums.length; i++) {\n            result[i] = prefix;\n            prefix *= nums[i];\n        }\n        for (let i = nums.length - 2; i >= 0; i--) {\n            postfix *= nums[i + 1];\n            result[i] *= postfix;\n        }\n\n        return result;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> result(n, 1);\n        \n        int prefix = 1;\n        for (int i = 0; i < n; i++) {\n            result[i] = prefix;\n            prefix = prefix * nums[i];\n        }\n        \n        int postfix = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            result[i] = result[i] * postfix;\n            postfix = postfix * nums[i];\n        }\n        \n        return result;\n    }\n};\n","java":"class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int[] arr = new int[nums.length];\n        int right = 1, left = 1;\n        for (int i = 0; i < nums.length; i++) {\n            arr[i] = left;\n            left *= nums[i];\n        }\n        for (int i = nums.length - 1; i >= 0; i--) {\n            arr[i] *= right;\n            right *= nums[i];\n        }\n        return arr;\n    }\n}  \n","csharp":"public class Solution {\n    public int[] ProductExceptSelf(int[] nums) {\n        int prefix = 1, postfix = 1;\n        int[] res = new int[nums.Length];        \n        \n        for(int i = 0; i < nums.Length; i++){\n            res[i] = prefix;\n            prefix *= nums[i];             \n        }\n        \n        for(int i = nums.Length-1; i>=0; i--){\n            res[i] *= postfix;\n            postfix *= nums[i];          \n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def productExceptSelf(self, nums: List[int]) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[]}\n     */\n    productExceptSelf(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> productExceptSelf(vector<int>& nums) {\n\n    }\n};\n","java":"class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        \n    }\n}  \n","csharp":"public class Solution {\n    public int[] ProductExceptSelf(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/bNvIQI2wAjk"},{"id":"longest-consecutive-sequence","name":"Longest Consecutive Sequence","description":"Given an array of integers `nums`, return *the length* of the longest consecutive sequence of elements.\n\nA *consecutive sequence* is a sequence of elements in which each element is exactly `1` greater than the previous element.\n\nYou must write an algorithm that runs in `O(n)` time.\n\n**Example 1:**\n\n```java\nInput: nums = [2,20,4,10,3,4,5]\n\nOutput: 4\n```\n\nExplanation: The longest consecutive sequence is `[2, 3, 4, 5]`.\n\n**Example 2:**\n\n```java\nInput: nums = [0,3,2,5,4,6,1,1]\n\nOutput: 7\n```\n\n**Constraints:**\n* `0 <= nums.length <= 1000`\n* `-10^9 <= nums[i] <= 10^9`\n","difficulty":"Medium","concepts":["Hash Usage"],"solutions":{"python":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        numSet = set(nums)\n        longest = 0\n\n        for n in numSet:\n            if (n - 1) not in numSet:\n                length = 1\n                while (n + length) in numSet:\n                    length += 1\n                longest = max(length, longest)\n        return longest\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    longestConsecutive(nums) {\n        const numSet = new Set(nums);\n        let longest = 0;\n\n        for (const n of numSet) {\n            if (!numSet.has(n - 1)) {\n                let length = 1;\n                while (numSet.has(n + length)) {\n                    length++;\n                }\n                longest = Math.max(length, longest);\n            }\n        }\n        return longest;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        unordered_set<int> numSet(nums.begin(), nums.end());\n        int longest = 0;\n\n        for (int n : numSet) {\n            if (numSet.find(n - 1) == numSet.end()) {\n                int length = 1;\n                while (numSet.find(n + length) != numSet.end()) {\n                    length++;\n                }\n                longest = max(length, longest);\n            }\n        }\n        return longest;\n    }\n};\n","java":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        Set<Integer> numSet = new HashSet<>();\n        for (int num : nums) {\n            numSet.add(num);\n        }\n\n        int longest = 0;\n\n        for (int n : numSet) {\n            if (!numSet.contains(n - 1)) {\n                int length = 1;\n                while (numSet.contains(n + length)) {\n                    length++;\n                }\n                longest = Math.max(length, longest);\n            }\n        }\n        return longest;\n    }\n}\n","csharp":"public class Solution {\n    public int LongestConsecutive(int[] nums) {\n        HashSet<int> numSet = new HashSet<int>(nums);\n        int longest = 0;\n\n        foreach (int n in numSet) {\n            if (!numSet.Contains(n - 1)) {\n                int length = 1;\n                while (numSet.Contains(n + length)) {\n                    length++;\n                }\n                longest = Math.Max(length, longest);\n            }\n        }\n        return longest;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    longestConsecutive(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int longestConsecutive(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int longestConsecutive(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LongestConsecutive(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/P6RZZMu_maU"},{"id":"three-integer-sum","name":"Three Integer Sum","description":"Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` where `nums[i] + nums[j] + nums[k] == 0`, and the indices `i`, `j` and `k` are all distinct.\n\nThe output should *not* contain any duplicate triplets. You may return the output and the triplets in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [-1,0,1,2,-1,-4]\n\nOutput: [[-1,-1,2],[-1,0,1]]\n```\n\nExplanation: \n`nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.`\n`nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.`\n`nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.`\nThe distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.\n\n**Example 2:**\n\n```java\nInput: nums = [0,1,1]\n\nOutput: []\n```\n\nExplanation: The only possible triplet does not sum up to 0.\n\n**Example 3:**\n\n```java\nInput: nums = [0,0,0]\n\nOutput: [[0,0,0]]\n```\n\nExplanation: The only possible triplet sums up to 0.\n\n\n**Constraints:**\n* `3 <= nums.length <= 1000`\n* `-10^5 <= nums[i] <= 10^5`\n","difficulty":"Medium","concepts":["Two Pointers"],"solutions":{"python":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        for i, a in enumerate(nums):\n            if a > 0:\n                break\n\n            if i > 0 and a == nums[i - 1]:\n                continue\n\n            l, r = i + 1, len(nums) - 1\n            while l < r:\n                threeSum = a + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([a, nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while nums[l] == nums[l - 1] and l < r:\n                        l += 1\n                        \n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    threeSum(nums) {\n        nums.sort((a, b) => a - b);\n        const res = [];\n\n        for (let i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) break;\n            if (i > 0 && nums[i] === nums[i - 1]) continue;\n\n            let l = i + 1;\n            let r = nums.length - 1;\n            while (l < r) {\n                const sum = nums[i] + nums[l] + nums[r];\n                if (sum > 0) {\n                    r--;\n                } else if (sum < 0) {\n                    l++;\n                } else {\n                    res.push([nums[i], nums[l], nums[r]]);\n                    l++;\n                    r--;\n                    while (l < r && nums[l] === nums[l - 1]) {\n                        l++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        sort(nums.begin(), nums.end());\n        vector<vector<int>> res;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (nums[i] > 0) break;\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n            int l = i + 1, r = nums.size() - 1;\n            while (l < r) {\n                int sum = nums[i] + nums[l] + nums[r];\n                if (sum > 0) {\n                    r--;\n                } else if (sum < 0) {\n                    l++;\n                } else {\n                    res.push_back({nums[i], nums[l], nums[r]});\n                    l++;\n                    r--;\n                    while (l < r && nums[l] == nums[l - 1]) {\n                        l++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> res = new ArrayList<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) break;\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n            int l = i + 1, r = nums.length - 1;\n            while (l < r) {\n                int sum = nums[i] + nums[l] + nums[r];\n                if (sum > 0) {\n                    r--;\n                } else if (sum < 0) {\n                    l++;\n                } else {\n                    res.add(Arrays.asList(nums[i], nums[l], nums[r]));\n                    l++;\n                    r--;\n                    while (l < r && nums[l] == nums[l - 1]) {\n                        l++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> ThreeSum(int[] nums) {\n        Array.Sort(nums);\n        List<List<int>> res = new List<List<int>>();\n\n        for (int i = 0; i < nums.Length; i++) {\n            if (nums[i] > 0) break;\n            if (i > 0 && nums[i] == nums[i - 1]) continue;\n\n            int l = i + 1, r = nums.Length - 1;\n            while (l < r) {\n                int sum = nums[i] + nums[l] + nums[r];\n                if (sum > 0) {\n                    r--;\n                } else if (sum < 0) {\n                    l++;\n                } else {\n                    res.Add(new List<int> {nums[i], nums[l], nums[r]});\n                    l++;\n                    r--;\n                    while (l < r && nums[l] == nums[l - 1]) {\n                        l++;\n                    }\n                }\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    threeSum(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> threeSum(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> ThreeSum(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/jzZsG8n2R9A"},{"id":"max-water-container","name":"Max Water Container","description":"You are given an integer array `heights` where `heights[i]` represents the height of the $i^{th}$ bar.\n\nYou may choose any two bars to form a container. Return the *maximum* amount of water a container can store.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/77f004c6-e773-4e63-7b99-a2309303c700/public)\n\n```java\nInput: height = [1,7,2,5,4,7,3,6]\n\nOutput: 36\n```\n\n**Example 2:**\n\n```java\nInput: height = [2,2,2]\n\nOutput: 4\n```\n\n**Constraints:**\n* `2 <= height.length <= 1000`\n* `0 <= height[i] <= 1000`\n","difficulty":"Medium","concepts":["Two Pointers"],"solutions":{"python":"class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        l, r = 0, len(heights) - 1\n        res = 0\n\n        while l < r:\n            res = max(res, min(heights[l], heights[r]) * (r - l))\n            if heights[l] < heights[r]:\n                l += 1\n            elif heights[r] <= heights[l]:\n                r -= 1\n            \n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} heights\n     * @return {number}\n     */\n    maxArea(heights) {\n        let left = 0;\n        let right = heights.length - 1;\n        let res = 0;\n\n        while (left < right) {\n            const containerLength = right - left;\n            const area =\n                containerLength * Math.min(heights[left], heights[right]);\n            res = Math.max(res, area);\n            if (heights[left] < heights[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxArea(vector<int>& heights) {\n        int left = 0;\n        int right = heights.size() - 1;\n        \n        int curr = 0;\n        int result = 0;\n        \n        while (left < right) {\n            curr = (right - left) * min(heights[left], heights[right]);\n            result = max(result, curr);\n            \n            if (heights[left] <= heights[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return result;\n    }\n};\n","java":"class Solution {\n    public int maxArea(int[] heights) {\n        int left = 0;\n        int right = heights.length - 1;\n        int res = 0;\n        \n        while (left < right) {\n            int containerLength = right - left;\n            int area = containerLength * Math.min(heights[left], heights[right]);\n            res = Math.max(res, area);\n            if (heights[left] < heights[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int MaxArea(int[] heights) {\n        int res = 0, area = 0, left = 0, right = heights.Length-1;\n        \n        while (left < right){\n            area = (Math.Min(heights[left], heights[right])) * (right - left);\n            res = Math.Max(area, res);\n            \n            if (heights[left] < heights[right]){\n                left++;\n            } else{\n                right--;\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxArea(self, heights: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} heights\n     * @return {number}\n     */\n    maxArea(heights) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxArea(vector<int>& heights) {\n        \n    }\n};\n","java":"class Solution {\n    public int maxArea(int[] heights) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxArea(int[] heights) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/UuiTKBwPgAo"},{"id":"longest-substring-without-duplicates","name":"Longest Substring Without Duplicates","description":"Given a string `s`, find the *length of the longest substring* without duplicate characters.\n\nA **substring** is a contiguous sequence of characters within a string.\n\n**Example 1:**\n\n```java\nInput: s = \"zxyzxyz\"\n\nOutput: 3\n```\n\nExplanation: The string \"xyz\" is the longest without duplicate characters.\n\n**Example 2:**\n\n```java\nInput: s = \"xxxx\"\n\nOutput: 1\n```\n\n**Constraints:**\n* `0 <= s.length <= 1000`\n* `s` may consist of printable ASCII characters.\n","difficulty":"Medium","concepts":["Sliding Window Fixed Size","Sliding Window Variable Size"],"solutions":{"python":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        charSet = set()\n        l = 0\n        res = 0\n\n        for r in range(len(s)):\n            while s[r] in charSet:\n                charSet.remove(s[l])\n                l += 1\n            charSet.add(s[r])\n            res = max(res, r - l + 1)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {number}\n     */\n    lengthOfLongestSubstring(s) {\n        const charSet = new Set();\n        let l = 0;\n        let res = 0;\n\n        for (let r = 0; r < s.length; r++) {\n            while (charSet.has(s[r])) {\n                charSet.delete(s[l]);\n                l++;\n            }\n            charSet.add(s[r]);\n            res = Math.max(res, r - l + 1);\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        unordered_set<char> charSet;\n        int l = 0;\n        int res = 0;\n\n        for (int r = 0; r < s.size(); r++) {\n            while (charSet.find(s[r]) != charSet.end()) {\n                charSet.erase(s[l]);\n                l++;\n            }\n            charSet.insert(s[r]);\n            res = max(res, r - l + 1);\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        HashSet<Character> charSet = new HashSet<>();\n        int l = 0;\n        int res = 0;\n\n        for (int r = 0; r < s.length(); r++) {\n            while (charSet.contains(s.charAt(r))) {\n                charSet.remove(s.charAt(l));\n                l++;\n            }\n            charSet.add(s.charAt(r));\n            res = Math.max(res, r - l + 1);\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int LengthOfLongestSubstring(string s) {\n        HashSet<char> charSet = new HashSet<char>();\n        int l = 0;\n        int res = 0;\n\n        for (int r = 0; r < s.Length; r++) {\n            while (charSet.Contains(s[r])) {\n                charSet.Remove(s[l]);\n                l++;\n            }\n            charSet.Add(s[r]);\n            res = Math.Max(res, r - l + 1);\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def lengthOfLongestSubstring(self, s: str) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {number}\n     */\n    lengthOfLongestSubstring(s) {}\n}\n","cpp":"class Solution {\npublic:\n    int lengthOfLongestSubstring(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LengthOfLongestSubstring(string s) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/wiGpQwVHdE0"},{"id":"longest-repeating-substring-with-replacement","name":"Longest Repeating Substring With Replacement","description":"You are given a string `s` consisting of only uppercase english characters and an integer `k`. You can choose up to `k` characters of the string and replace them with any other uppercase English character.\n\nAfter performing at most `k` replacements, return the length of the longest substring which contains only one distinct character.\n\n**Example 1:**\n\n```java\nInput: s = \"XYYX\", k = 2\n\nOutput: 4\n```\n\nExplanation: Either replace the 'X's with 'Y's, or replace the 'Y's with 'X's.\n\n**Example 2:**\n\n```java\nInput: s = \"AAABABB\", k = 1\n\nOutput: 5\n```\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `0 <= k <= s.length`\n","difficulty":"Medium","concepts":["Sliding Window Fixed Size","Sliding Window Variable Size"],"solutions":{"python":"class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        count = {}\n        \n        l = 0\n        maxf = 0\n        for r in range(len(s)):\n            count[s[r]] = 1 + count.get(s[r], 0)\n            maxf = max(maxf, count[s[r]])\n\n            if (r - l + 1) - maxf > k:\n                count[s[l]] -= 1\n                l += 1\n\n        return (r - l + 1)\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {number} k\n     * @return {number}\n     */\n    characterReplacement(s, k) {\n        let res = 0;\n        const count = new Map();\n        let l = 0;\n\n        for (let r = 0; r < s.length; r++) {\n            let len = r - l + 1;\n            count.set(s[r], 1 + (count.get(s[r]) || 0));\n\n            if (len - Math.max(...count.values()) > k) {\n                count.set(s[l], count.get(s[l]) - 1);\n                l++;\n            }\n            len = r - l + 1;\n            res = Math.max(res, len);\n        }\n\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        vector<int> count(26);\n        int maxCount = 0;\n        \n        int i = 0;\n        int j = 0;\n        \n        int result = 0;\n        \n        while (j < s.size()) {\n            count[s[j] - 'A']++;\n            maxCount = max(maxCount, count[s[j] - 'A']);\n            if (j - i + 1 - maxCount > k) {\n                count[s[i] - 'A']--;\n                i++;\n            }\n            result = max(result, j - i + 1);\n            j++;\n        }\n        \n        return result;\n    }\n};\n","java":"class Solution {\n    public int characterReplacement(String s, int k) {\n        int[] arr = new int[26];\n        \n        int ans = 0;\n        int max = 0;\n        int i = 0;\n        for (int j = 0; j < s.length(); j++) {\n            arr[s.charAt(j) - 'A']++;\n            max = Math.max(max, arr[s.charAt(j) - 'A']);\n\n            if (j - i + 1 - max > k) {\n                arr[s.charAt(i) - 'A']--;\n                i++;\n            }\n            ans = Math.max(ans, j - i + 1);\n        }\n        return ans;\n    }\n}\n","csharp":"public class Solution {\n    public int CharacterReplacement(string s, int k) {\n        int left = 0, maxLength = 0;\n        int mostFrequentLetterCount = 0; \n        int[] charCounts = new int[26]; \n\n        for (int right = 0; right < s.Length; right++) {\n            charCounts[s[right] - 'A']++;\n            mostFrequentLetterCount = Math.Max(mostFrequentLetterCount, charCounts[s[right] - 'A']);\n\n            int lettersToChange = (right - left + 1) - mostFrequentLetterCount;\n            if (lettersToChange > k) { \n                charCounts[s[left] - 'A']--;\n                left++;\n            }\n\n            maxLength = Math.Max(maxLength, (right - left + 1));\n        }\n        return maxLength;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def characterReplacement(self, s: str, k: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {number} k\n     * @return {number}\n     */\n    characterReplacement(s, k) {}\n}\n","cpp":"class Solution {\npublic:\n    int characterReplacement(string s, int k) {\n        \n    }\n};\n","java":"class Solution {\n    public int characterReplacement(String s, int k) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int CharacterReplacement(string s, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/gqXU1UyA8pk"},{"id":"minimum-window-with-characters","name":"Minimum Window With Characters","description":"Given two strings `s` and `t`, return the shortest **substring** of `s` such that every character in `t`, including duplicates, is present in the substring. If such a substring does not exist, return an empty string `\"\"`.\n\nYou may assume that the correct output is always unique.\n\n**Example 1:**\n\n```java\nInput: s = \"OUZODYXAZV\", t = \"XYZ\"\n\nOutput: \"YXAZ\"\n```\n\nExplanation: `\"YXAZ\"` is the shortest substring that includes `\"X\"`, `\"Y\"`, and `\"Z\"` from string `t`.\n\n**Example 2:**\n\n```java\nInput: s = \"xyz\", t = \"xyz\"\n\nOutput: \"xyz\"\n```\n\n**Example 3:**\n\n```java\nInput: s = \"x\", t = \"xy\"\n\nOutput: \"\"\n```\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `1 <= t.length <= 1000`\n* `s` and `t` consist of uppercase and lowercase English letters.\n","difficulty":"Hard","concepts":["Hash Usage","Sliding Window Fixed Size","Sliding Window Variable Size"],"solutions":{"python":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        if t == \"\":\n            return \"\"\n\n        countT, window = {}, {}\n        for c in t:\n            countT[c] = 1 + countT.get(c, 0)\n\n        have, need = 0, len(countT)\n        res, resLen = [-1, -1], float(\"infinity\")\n        l = 0\n        for r in range(len(s)):\n            c = s[r]\n            window[c] = 1 + window.get(c, 0)\n\n            if c in countT and window[c] == countT[c]:\n                have += 1\n\n            while have == need:\n                if (r - l + 1) < resLen:\n                    res = [l, r]\n                    resLen = r - l + 1\n                    \n                window[s[l]] -= 1\n                if s[l] in countT and window[s[l]] < countT[s[l]]:\n                    have -= 1\n                l += 1\n        l, r = res\n        return s[l : r + 1] if resLen != float(\"infinity\") else \"\"\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} t\n     * @return {string}\n     */\n    minWindow(s, t) {\n        const map = new Map();\n\n        for (const x of t) {\n            map.set(x, (map.get(x) || 0) + 1);\n        }\n\n        let matched = 0;\n        let start = 0;\n        let minLen = s.length + 1;\n        let subStr = 0;\n        for (let endWindow = 0; endWindow < s.length; endWindow++) {\n            const right = s[endWindow];\n            if (map.has(right)) {\n                map.set(right, map.get(right) - 1);\n                if (map.get(right) === 0) matched++;\n            }\n\n            while (matched === map.size) {\n                if (minLen > endWindow - start + 1) {\n                    minLen = endWindow - start + 1;\n                    subStr = start;\n                }\n                const deleted = s[start++];\n                if (map.has(deleted)) {\n                    if (map.get(deleted) === 0) matched--;\n                    map.set(deleted, map.get(deleted) + 1);\n                }\n            }\n        }\n        return minLen > s.length ? '' : s.substring(subStr, subStr + minLen);\n    }\n}\n","cpp":"class Solution {\npublic:\n    string minWindow(string s, string t) {\n        unordered_map<char, int> m;\n        for (int i = 0; i < t.size(); i++) {\n            m[t[i]]++;\n        }\n        \n        int i = 0;\n        int j = 0;\n        \n        int counter = t.size();\n        \n        int minStart = 0;\n        int minLength = INT_MAX;\n        \n        while (j < s.size()) {\n            if (m[s[j]] > 0) {\n                counter--;\n            }\n            m[s[j]]--;\n            j++;\n            \n            while (counter == 0) {\n                if (j - i < minLength) {\n                    minStart = i;\n                    minLength = j - i;\n                }\n                m[s[i]]++;\n\n                if (m[s[i]] > 0) {\n                    counter++;\n                }\n                i++;\n            }\n        }\n        \n        if (minLength != INT_MAX) {\n            return s.substr(minStart, minLength);\n        }\n        return \"\";\n    }\n};\n","java":"class Solution {\n    public String minWindow(String s, String t) {\n        HashMap<Character, Integer> map = new HashMap<>();\n\n        for (char x : t.toCharArray()) {\n            map.put(x, map.getOrDefault(x, 0) + 1);\n        }\n\n        int matched = 0;\n        int start = 0;\n        int minLen = s.length() + 1;\n        int subStr = 0;\n        for (int endWindow = 0; endWindow < s.length(); endWindow++) {\n            char right = s.charAt(endWindow);\n            if (map.containsKey(right)) {\n                map.put(right, map.get(right) - 1);\n                if (map.get(right) == 0) matched++;\n            }\n\n            while (matched == map.size()) {\n                if (minLen > endWindow - start + 1) {\n                    minLen = endWindow - start + 1;\n                    subStr = start;\n                }\n                char deleted = s.charAt(start++);\n                if (map.containsKey(deleted)) {\n                    if (map.get(deleted) == 0) matched--;\n                    map.put(deleted, map.get(deleted) + 1);\n                }\n            }\n        }\n        return minLen > s.length() ? \"\" : s.substring(subStr, subStr + minLen);\n    }\n}\n","csharp":"public class Solution {\n    public string MinWindow(string s, string t) {\n        Dictionary<char, int> map = new Dictionary<char, int>();\n\n        foreach (char x in t.ToCharArray()) {\n            if (map.ContainsKey(x)) {\n                map[x]++;\n            } else {\n                map.Add(x, 1);\n            }\n        }\n\n        int matched = 0, start = 0, minLen = s.Length + 1, subStr = 0;\n        for (int endWindow = 0; endWindow < s.Length; endWindow++) {\n            char right = s[endWindow];\n            if (map.ContainsKey(right)) {\n                map[right]--;\n                if (map[right] == 0) matched++;\n            }\n\n            while (matched == map.Count) {\n                if (minLen > endWindow - start + 1) {\n                    minLen = endWindow - start + 1;\n                    subStr = start;\n                }\n                char deleted = s[start++];\n                if (map.ContainsKey(deleted)) {\n                    if (map[deleted] == 0) matched--;\n                    map[deleted]++;\n                }\n            }\n        }\n        return minLen > s.Length ? \"\" : s.Substring(subStr, minLen);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} t\n     * @return {string}\n     */\n    minWindow(s, t) {}\n}\n","cpp":"class Solution {\npublic:\n    string minWindow(string s, string t) {\n        \n    }\n};\n","java":"class Solution {\n    public String minWindow(String s, String t) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public string MinWindow(string s, string t) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/jSto0O4AJbM"},{"id":"find-target-in-rotated-sorted-array","name":"Find Target in Rotated Sorted Array","description":"You are given an array of length `n` which was originally sorted in ascending order. It has now been **rotated** between `1` and `n` times. For example, the array `nums = [1,2,3,4,5,6]` might become:\n\n* `[3,4,5,6,1,2]` if it was rotated `4` times.\n* `[1,2,3,4,5,6]` if it was rotated `6` times.\n\nGiven the rotated sorted array `nums` and an integer `target`, return the index of `target` within `nums`, or `-1` if it is not present.\n\nYou may assume all elements in the sorted rotated array `nums` are **unique**,\n\nA solution that runs in `O(n)` time is trivial, can you write an algorithm that runs in `O(log n) time`?\n\n**Example 1:**\n\n```java\nInput: nums = [3,4,5,6,1,2], target = 1\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: nums = [3,5,6,0,1,2], target = 4\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n* `-1000 <= target <= 1000`\n","difficulty":"Medium","concepts":["Search Array"],"solutions":{"python":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            mid = (l + r) // 2\n            if target == nums[mid]:\n                return mid\n\n            if nums[l] <= nums[mid]:\n                if target > nums[mid] or target < nums[l]:\n                    l = mid + 1\n                else:\n                    r = mid - 1\n                    \n            else:\n                if target < nums[mid] or target > nums[r]:\n                    r = mid - 1\n                else:\n                    l = mid + 1\n        return -1\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number}\n     */\n    search(nums, target) {\n        let l = 0;\n            let r = nums.length - 1;\n\n        while (l <= r) {\n            const mid = Math.floor((l + r) / 2);\n            if (target === nums[mid]) {\n                return mid;\n            }\n\n            if (nums[l] <= nums[mid]) {\n                if (target > nums[mid] || target < nums[l]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            } else {\n                if (target < nums[mid] || target > nums[r]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n        }\n        return -1;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int low = 0;\n        int high = nums.size() - 1;\n        \n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target <= nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (nums[mid] <= target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n        \n        return -1;\n    }\n};\n","java":"class Solution {\n    public int search(int[] nums, int target) {\n        int l = 0;\n        int r = nums.length - 1;\n\n        while(l <= r) {\n\n            int mid = (l + r) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            if (nums[l] <= nums[mid]) {\n                if (target > nums[mid] || target < nums[l]) {\n                    l = mid + 1;\n                } else {\n                    r = mid - 1;\n                }\n            } else {\n                if (target < nums[mid] || target > nums [r]) {\n                    r = mid - 1;\n                } else {\n                    l = mid + 1;\n                }\n            }\n\n        }\n\n        return -1;\n    }\n}\n","csharp":"public class Solution {\n    public int Search(int[] nums, int target) {\n        int low = 0;\n        int high = nums.Length - 1;\n        \n        while(low <= high) {\n            var mid = (low + high) / 2;\n            \n            if(nums[mid] == target) {\n                return mid;\n            } else if(nums[low] <= nums[mid]) {\n                if(target > nums[mid] ||  target < nums[low]) \n                    low = mid + 1;\n                else high = mid - 1;\n            } else {\n                if(target < nums[mid] || target > nums[high]) \n                    high = mid - 1;\n                else low = mid + 1;\n            }\n        }\n        \n        return -1;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number}\n     */\n    search(nums, target) {}\n}\n","cpp":"class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/U8XENwh8Oy8"},{"id":"merge-two-sorted-linked-lists","name":"Merge Two Sorted Linked Lists","description":"You are given the heads of two sorted linked lists `list1` and `list2`.\n\nMerge the two lists into one **sorted** linked list and return the head of the new sorted linked list.\n\nThe new list should be made up of nodes from `list1` and `list2`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/51adfea9-493a-4abb-ece7-fbb359d1c800/public)\n\n```java\nInput: list1 = [1,2,4], list2 = [1,3,5]\n\nOutput: [1,1,2,3,4,5]\n```\n\n**Example 2:**\n\n```java\nInput: list1 = [], list2 = [1,2]\n\nOutput: [1,2]\n```\n\n**Example 3:**\n\n```java\nInput: list1 = [], list2 = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The length of the each list <= 100`.\n* `-100 <= Node.val <= 100`\n","difficulty":"Easy","concepts":["Singly Linked Lists"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\n# Iterative Solution\nclass Solution:\n    def mergeTwoLists(self, list1: ListNode, list2: ListNode) -> ListNode:\n        dummy = node = ListNode()\n\n        while list1 and list2:\n            if list1.val < list2.val:\n                node.next = list1\n                list1 = list1.next\n            else:\n                node.next = list2\n                list2 = list2.next\n            node = node.next\n\n        node.next = list1 or list2\n\n        return dummy.next\n    \n# Recursive Solution\n# class Solution:\n#     def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n#         if not list1:\n#             return list2\n#         if not list2:\n#             return list1\n#         lil, big = (list1, list2) if list1.val < list2.val else (list2, list1)\n#         lil.next = self.mergeTwoLists(lil.next, big)\n#         return lil\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\n/** Iterative Solution */\nclass Solution {\n    /**\n     * @param {ListNode} list1\n     * @param {ListNode} list2\n     * @return {ListNode}\n     */\n    mergeTwoLists(list1, list2) {\n        const dummy = { val: 0, next: null };\n        let node = dummy;\n\n        while (list1 && list2) {\n            if (list1.val < list2.val) {\n                node.next = list1;\n                list1 = list1.next;\n            } else {\n                node.next = list2;\n                list2 = list2.next;\n            }\n            node = node.next;\n        }\n\n        if (list1) {\n            node.next = list1;\n        } else {\n            node.next = list2;\n        }\n\n        return dummy.next;\n    }\n}\n\n/** Recursive Solution */\n// class Solution {\n//     /**\n//      * @param {ListNode} list1\n//      * @param {ListNode} list2\n//      * @return {ListNode}\n//      */\n//     mergeTwoLists(list1, list2) {\n//         if (list1 === null) return list2;\n//         if (list2 === null) return list1;\n\n//         if (list1.val < list2.val) {\n//             list1.next = this.mergeTwoLists(list1.next, list2);\n//             return list1;\n//         } else {\n//             list2.next = this.mergeTwoLists(list2.next, list1);\n//             return list2;\n//         }\n//     }\n// }\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\n/** Iterative Solution */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        ListNode dummy(0);\n        ListNode* node = &dummy;\n\n        while (list1 && list2) {\n            if (list1->val < list2->val) {\n                node->next = list1;\n                list1 = list1->next;\n            } else {\n                node->next = list2;\n                list2 = list2->next;\n            }\n            node = node->next;\n        }\n\n        if (list1) {\n            node->next = list1;\n        } else {\n            node->next = list2;\n        }\n\n        return dummy.next;\n    }\n};\n\n/** Recursive Solution */\n// class Solution {\n// public:\n//     ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n//         if (list1 == nullptr) return list2;\n//         if (list2 == nullptr) return list1;\n\n//         if (list1->val < list2->val) {\n//             list1->next = mergeTwoLists(list1->next, list2);\n//             return list1;\n//         } else {\n//             list2->next = mergeTwoLists(list2->next, list1);\n//             return list2;\n//         }\n//     }\n// };\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n/** Iterative Solution */\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode node = dummy;\n\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                node.next = list1;\n                list1 = list1.next;\n            } else {\n                node.next = list2;\n                list2 = list2.next;\n            }\n            node = node.next;\n        }\n\n        if (list1 != null) {\n            node.next = list1;\n        } else {\n            node.next = list2;\n        }\n\n        return dummy.next;\n    }\n}\n\n/** Recursive Solution */\n// class Solution {\n//     public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n//         if (list1 == null) return list2;\n//         if (list2 == null) return list1;\n\n//         if (list1.val < list2.val) {\n//             list1.next = mergeTwoLists(list1.next, list2);\n//             return list1;\n//         } else {\n//             list2.next = mergeTwoLists(list2.next, list1);\n//             return list2;\n//         }\n//     }\n// }\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\n/** Iterative Solution */\npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode node = dummy;\n\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                node.next = list1;\n                list1 = list1.next;\n            } else {\n                node.next = list2;\n                list2 = list2.next;\n            }\n            node = node.next;\n        }\n\n        if (list1 != null) {\n            node.next = list1;\n        } else {\n            node.next = list2;\n        }\n\n        return dummy.next;\n    }\n}\n\n/** Recursive Solution */\n// public class Solution {\n//     public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n//         if (list1 == null) return list2;\n//         if (list2 == null) return list1;\n\n//         if (list1.val < list2.val) {\n//             list1.next = MergeTwoLists(list1.next, list2);\n//             return list1;\n//         } else {\n//             list2.next = MergeTwoLists(list2.next, list1);\n//             return list2;\n//         }\n//     }\n// }\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def mergeTwoLists(self, list1: Optional[ListNode], list2: Optional[ListNode]) -> Optional[ListNode]:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} list1\n     * @param {ListNode} list2\n     * @return {ListNode}\n     */\n    mergeTwoLists(list1, list2) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n \npublic class Solution {\n    public ListNode MergeTwoLists(ListNode list1, ListNode list2) {\n        \n    }\n}"},"videoUrl":"https://www.youtube.com/embed/XIdigk956u0"},{"id":"reorder-linked-list","name":"Reorder Linked List","description":"You are given the head of a singly linked-list.\n    \nThe positions of a linked list of `length = 7` for example, can intially be represented as:\n\n`[0, 1, 2, 3, 4, 5, 6]`\n\nReorder the nodes of the linked list to be in the following order:\n\n`[0, 6, 1, 5, 2, 4, 3]`\n\nNotice that in the general case for a list of `length = n` the nodes are reordered to be in the following order:\n\n`[0, n-1, 1, n-2, 2, n-3, ...]`\n\nYou may not modify the values in the list's nodes, but instead you must reorder the nodes themselves.\n\n**Example 1:**\n\n```java\nInput: head = [2,4,6,8]\n\nOutput: [2,8,4,6]\n```\n\n**Example 2:**\n\n```java\nInput: head = [2,4,6,8,10]\n\nOutput: [2,10,4,8,6]\n```\n\n**Constraints:**\n* `1 <= Length of the list <= 1000`.\n* `1 <= Node.val <= 1000`\n","difficulty":"Medium","concepts":["Singly Linked Lists","Fast and Slow Pointers"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        second = slow.next\n        prev = slow.next = None\n        while second:\n            tmp = second.next\n            second.next = prev\n            prev = second\n            second = tmp\n\n        first, second = head, prev\n        while second:\n            tmp1, tmp2 = first.next, second.next\n            first.next = second\n            second.next = tmp1\n            first, second = tmp1, tmp2\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @return {void}\n     */\n    reorderList(head) {\n        let slow = head;\n        let fast = head.next;\n        while (fast !== null && fast.next !== null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        let second = slow.next;\n        let prev = (slow.next = null);\n        while (second !== null) {\n            const tmp = second.next;\n            second.next = prev;\n            prev = second;\n            second = tmp;\n        }\n\n        let first = head;\n        second = prev;\n        while (second !== null) {\n            const tmp1 = first.next;\n            const tmp2 = second.next;\n            first.next = second;\n            second.next = tmp1;\n            first = tmp1;\n            second = tmp2;\n        }\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        ListNode* slow = head;\n        ListNode* fast = head->next;\n        while (fast != nullptr && fast->next != nullptr) {\n            slow = slow->next;\n            fast = fast->next->next;\n        }\n\n        ListNode* second = slow->next;\n        ListNode* prev = slow->next = nullptr;\n        while (second != nullptr) {\n            ListNode* tmp = second->next;\n            second->next = prev;\n            prev = second;\n            second = tmp;\n        }\n\n        ListNode* first = head;\n        second = prev;\n        while (second != nullptr) {\n            ListNode* tmp1 = first->next;\n            ListNode* tmp2 = second->next;\n            first->next = second;\n            second->next = tmp1;\n            first = tmp1;\n            second = tmp2;\n        }\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public void reorderList(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode second = slow.next;\n        ListNode prev = slow.next = null;\n        while (second != null) {\n            ListNode tmp = second.next;\n            second.next = prev;\n            prev = second;\n            second = tmp;\n        }\n\n        ListNode first = head;\n        second = prev;\n        while (second != null) {\n            ListNode tmp1 = first.next;\n            ListNode tmp2 = second.next;\n            first.next = second;\n            second.next = tmp1;\n            first = tmp1;\n            second = tmp2;\n        }\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public void ReorderList(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode second = slow.next;\n        ListNode prev = slow.next = null;\n        while (second != null) {\n            ListNode tmp = second.next;\n            second.next = prev;\n            prev = second;\n            second = tmp;\n        }\n\n        ListNode first = head;\n        second = prev;\n        while (second != null) {\n            ListNode tmp1 = first.next;\n            ListNode tmp2 = second.next;\n            first.next = second;\n            second.next = tmp1;\n            first = tmp1;\n            second = tmp2;\n        }\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reorderList(self, head: Optional[ListNode]) -> None:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @return {void}\n     */\n    reorderList(head) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    void reorderList(ListNode* head) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public void reorderList(ListNode head) {\n        \n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public void ReorderList(ListNode head) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/S5bfdUTrKLM"},{"id":"remove-node-from-end-of-linked-list","name":"Remove Node From End of Linked List","description":"You are given the beginning of a linked list `head`, and an integer `n`.\n    \nRemove the `nth` node from the end of the list and return the beginning of the list.\n\n**Example 1:**\n\n```java\nInput: head = [1,2,3,4], n = 2\n\nOutput: [1,2,4]\n```\n\n**Example 2:**\n\n```java\nInput: head = [5], n = 1\n\nOutput: []\n```\n\n**Example 3:**\n\n```java\nInput: head = [1,2], n = 2\n\nOutput: [2]\n```\n\n**Constraints:**\n* The number of nodes in the list is `sz`.\n* `1 <= sz <= 30`\n* `0 <= Node.val <= 100`\n* `1 <= n <= sz`\n","difficulty":"Medium","concepts":["Singly Linked Lists"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        left = dummy\n        right = head\n\n        while n > 0:\n            right = right.next\n            n -= 1\n\n        while right:\n            left = left.next\n            right = right.next\n\n        left.next = left.next.next\n        return dummy.next\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @param {number} n\n     * @return {ListNode}\n     */\n    removeNthFromEnd(head, n) {\n        const dummy = new ListNode(0, head);\n        let left = dummy;\n        let right = head;\n\n        while (n > 0) {\n            right = right.next;\n            n--;\n        }\n\n        while (right !== null) {\n            left = left.next;\n            right = right.next;\n        }\n\n        left.next = left.next.next;\n        return dummy.next;\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* left = dummy;\n        ListNode* right = head;\n\n        while (n > 0) {\n            right = right->next;\n            n--;\n        }\n\n        while (right != nullptr) {\n            left = left->next;\n            right = right->next;\n        }\n\n        left->next = left->next->next;\n        return dummy->next;\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode left = dummy;\n        ListNode right = head;\n\n        while (n > 0) {\n            right = right.next;\n            n--;\n        }\n\n        while (right != null) {\n            left = left.next;\n            right = right.next;\n        }\n\n        left.next = left.next.next;\n        return dummy.next;\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode left = dummy;\n        ListNode right = head;\n\n        while (n > 0) {\n            right = right.next;\n            n--;\n        }\n\n        while (right != null) {\n            left = left.next;\n            right = right.next;\n        }\n\n        left.next = left.next.next;\n        return dummy.next;\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @param {number} n\n     * @return {ListNode}\n     */\n    removeNthFromEnd(head, n) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode RemoveNthFromEnd(ListNode head, int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/XVuQxVej6y8"},{"id":"linked-list-cycle-detection","name":"Linked List Cycle Detection","description":"Given the beginning of a linked list `head`, return `true` if there is a cycle in the linked list. Otherwise, return `false`.\n\nThere is a cycle in a linked list if at least one node in the list that can be visited again by following the `next` pointer.\n\nInternally, `index` determines the index of the beginning of the cycle, if it exists. The tail node of the list will set it's `next` pointer to the `index-th` node. If `index = -1`, then the tail node points to `null` and no cycle exists.\n\n**Note:** `index` is **not** given to you as a parameter.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3ecdbcfc-70fc-429a-4654-cf4f6a7dbe00/public)\n\n```java\nInput: head = [1,2,3,4], index = 1\n\nOutput: true\n```\n\nExplanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed).\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/89e6716c-9f65-46da-d7b2-f04a93269700/public)\n\n```java\nInput: head = [1,2], index = -1\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= Length of the list <= 1000`.\n* `-1000 <= Node.val <= 1000`\n* `index` is `-1` or a valid index in the linked list.\n","difficulty":"Easy","concepts":["Singly Linked Lists","Fast and Slow Pointers"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        slow, fast = head, head\n\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @return {boolean}\n     */\n    hasCycle(head) {\n        let fast = head;\n        let slow = head;\n\n        while (fast !== null && fast.next !== null) {\n            fast = fast.next.next;\n            slow = slow.next;\n\n            if (fast === slow) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while (fast != nullptr && fast->next != nullptr) {\n            fast = fast->next->next;\n            slow = slow->next;\n            \n            if (fast == slow) {\n                return true;\n            }\n        }\n        \n        return false;\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        \n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (fast == slow) return true;\n        }\n        return false;\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public bool HasCycle(ListNode head) {\n        ListNode slow = head, fast = head;\n\n        while (fast != null && fast.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n            if (slow.Equals(fast)) return true;\n        }\n        return false;\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def hasCycle(self, head: Optional[ListNode]) -> bool:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @return {boolean}\n     */\n    hasCycle(head) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool hasCycle(ListNode* head) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public boolean hasCycle(ListNode head) {\n        \n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public bool HasCycle(ListNode head) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/gBTe7lFR3vc"},{"id":"merge-k-sorted-linked-lists","name":"Merge K Sorted Linked Lists","description":"You are given an array of `k` linked lists `lists`, where each list is sorted in ascending order.\n\nReturn the **sorted** linked list that is the result of merging all of the individual linked lists.\n\n**Example 1:**\n\n```java\nInput: lists = [[1,2,4],[1,3,5],[3,6]]\n\nOutput: [1,1,2,3,3,4,5,6]\n```\n\n**Example 2:**\n\n```java\nInput: lists = []\n\nOutput: []\n```\n\n**Example 3:**\n\n```java\nInput: lists = [[]]\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= lists.length <= 1000`\n* `0 <= lists[i].length <= 100`\n* `-1000 <= lists[i][j] <= 1000`\n","difficulty":"Hard","concepts":["Singly Linked Lists","Merge Sort","Heap Properties","Push and Pop"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        if not lists or len(lists) == 0:\n            return None\n\n        while len(lists) > 1:\n            mergedLists = []\n            for i in range(0, len(lists), 2):\n                l1 = lists[i]\n                l2 = lists[i + 1] if (i + 1) < len(lists) else None\n                mergedLists.append(self.mergeList(l1, l2))\n            lists = mergedLists\n        return lists[0]\n\n    def mergeList(self, l1, l2):\n        dummy = ListNode()\n        tail = dummy\n\n        while l1 and l2:\n            if l1.val < l2.val:\n                tail.next = l1\n                l1 = l1.next\n            else:\n                tail.next = l2\n                l2 = l2.next\n            tail = tail.next\n        if l1:\n            tail.next = l1\n        if l2:\n            tail.next = l2\n        return dummy.next\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode[]} lists\n     * @return {ListNode}\n     */\n    mergeKLists(lists) {\n        if (!lists || lists.length === 0) {\n            return null;\n        }\n\n        while (lists.length > 1) {\n            const mergedLists = [];\n            for (let i = 0; i < lists.length; i += 2) {\n                const l1 = lists[i];\n                const l2 = i + 1 < lists.length ? lists[i + 1] : null;\n                mergedLists.push(this.mergeList(l1, l2));\n            }\n            lists = mergedLists;\n        }\n        return lists[0];\n    }\n\n    /**\n     * @param {ListNode} l1\n     * @param  {ListNode} l2\n     * @return {ListNode}\n     */\n    mergeList(l1, l2) {\n        const dummy = new ListNode();\n        let tail = dummy;\n\n        while (l1 && l2) {\n            if (l1.val < l2.val) {\n                tail.next = l1;\n                l1 = l1.next;\n            } else {\n                tail.next = l2;\n                l2 = l2.next;\n            }\n            tail = tail.next;\n        }\n        if (l1) {\n            tail.next = l1;\n        }\n        if (l2) {\n            tail.next = l2;\n        }\n        return dummy.next;\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        int n = lists.size();\n        if (n == 0) {\n            return NULL;\n        }\n        \n        while (n > 1) {\n            for (int i = 0; i < n / 2; i++) {\n                lists[i] = mergeTwoLists(lists[i], lists[n - i - 1]);\n            }\n            n = (n + 1) / 2;\n        }\n        \n        return lists.front();\n    }\n\nprivate:\n    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {\n        if (list1 == NULL && list2 == NULL) {\n            return NULL;\n        }\n        if (list1 == NULL) {\n            return list2;\n        }\n        if (list2 == NULL) {\n            return list1;\n        }\n        \n        ListNode* head = NULL;\n        if (list1->val <= list2->val) {\n            head = list1;\n            list1 = list1->next;\n        } else {\n            head = list2;\n            list2 = list2->next;\n        }\n        ListNode* curr = head;\n        \n        while (list1 != NULL && list2 != NULL) {\n            if (list1->val <= list2->val) {\n                curr->next = list1;\n                list1 = list1->next;\n            } else {\n                curr->next = list2;\n                list2 = list2->next;\n            }\n            curr = curr->next;\n        }\n        \n        if (list1 == NULL) {\n            curr->next = list2;\n        } else {\n            curr->next = list1;\n        }\n        \n        return head;\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n\n    public ListNode mergeKLists(ListNode[] lists) {\n        int size = lists.length;\n        int interval = 1;\n\n        while (interval < size) {\n            for (int i = 0; i < size - interval; i += 2 * interval) {\n                lists[i] = merge(lists[i], lists[i + interval]);\n            }\n\n            interval *= 2;\n        }\n\n        return size > 0 ? lists[0] : null;\n    }\n\n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                curr.next = l1;\n                l1 = l1.next;\n            } else {\n                curr.next = l2;\n                l2 = l2.next;\n            }\n\n            curr = curr.next;\n        }\n\n        if (l1 != null) {\n            curr.next = l1;\n        } else {\n            curr.next = l2;\n        }\n\n        return dummy.next;\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public ListNode MergeKLists(ListNode[] lists) {\n        if (lists.Length == 0) {\n            return null;\n        }\n        \n        while (lists.Length > 1) {\n            var mergedLists = new ListNode[(lists.Length + 1) / 2];\n            for (int i = 0; i < lists.Length; i += 2) {\n                var l1 = lists[i];\n                var l2 = (i + 1 < lists.Length) ? lists[i + 1] : null;\n                mergedLists[i/2] = (MergeLists(l1, l2));\n            }\n            lists = mergedLists;\n        }\n        \n        return lists[0];\n    }\n    \n    public ListNode MergeLists(ListNode l1, ListNode l2) {\n        var sorted = new ListNode();\n        var current = sorted;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            }\n            else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n        \n        if (l1 != null) {\n            current.next = l1;\n        } else {\n            current.next = l2;\n        }\n        \n        return sorted.next;\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:    \n    def mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode[]} lists\n     * @return {ListNode}\n     */\n    mergeKLists(lists) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* mergeKLists(vector<ListNode*>& lists) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {    \n    public ListNode MergeKLists(ListNode[] lists) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/q5a5OiGbT6Q"},{"id":"depth-of-binary-tree","name":"Depth of Binary Tree","description":"Given the `root` of a binary tree, return its **depth**.\n\nThe **depth** of a binary tree is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5ea6da77-7e43-43e0-dd9d-e879ca0b1600/public)\n\n```java\nInput: root = [1,2,3,null,null,4]\n\nOutput: 3\n```\n\n**Example 2:**\n\n```java\nInput: root = []\n\nOutput: 0\n```\n\n**Constraints:**\n* `0 <= The number of nodes in the tree <= 100`.\n* `-100 <= Node.val <= 100`\n","difficulty":"Easy","concepts":["Binary Tree","Depth-First Search","Breadth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\n# RECURSIVE DFS\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        if not root:\n            return 0\n\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))\n\n\n# ITERATIVE DFS\n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -> int:\n#         stack = [[root, 1]]\n#         res = 0\n\n#         while stack:\n#             node, depth = stack.pop()\n\n#             if node:\n#                 res = max(res, depth)\n#                 stack.append([node.left, depth + 1])\n#                 stack.append([node.right, depth + 1])\n#         return res\n\n\n# BFS\n# class Solution:\n#     def maxDepth(self, root: Optional[TreeNode]) -> int:\n#         q = deque()\n#         if root:\n#             q.append(root)\n\n#         level = 0\n\n#         while q:\n\n#             for i in range(len(q)):\n#                 node = q.popleft()\n#                 if node.left:\n#                     q.append(node.left)\n#                 if node.right:\n#                     q.append(node.right)\n#             level += 1\n#         return level\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// RECURSIVE DFS\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    maxDepth(root) {\n        if (root === null) {\n            return 0;\n        }\n\n        return (\n            1 + Math.max(this.maxDepth(root.left), this.maxDepth(root.right))\n        );\n    }\n}\n\n// ITERATIVE DFS\n// class Solution {\n//     /**\n//      * @param {TreeNode} root\n//      * @return {number}\n//      */\n//     maxDepth(root) {\n//         const stack = [[root, 1]];\n//         let res = 0;\n\n//         while (stack.length > 0) {\n//             const current = stack.pop();\n//             const node = current[0];\n//             const depth = current[1];\n\n//             if (node !== null) {\n//                 res = Math.max(res, depth);\n//                 stack.push([node.left, depth + 1]);\n//                 stack.push([node.right, depth + 1]);\n//             }\n//         }\n//         return res;\n//     }\n// }\n\n// BFS\n// class Solution {\n//     /**\n//      * @param {TreeNode} root\n//      * @return {number}\n//      */\n//     maxDepth(root) {\n//         const q = [];\n//         if (root !== null) {\n//             q.push(root);\n//         }\n\n//         let level = 0;\n\n//         while (q.length > 0) {\n//             const size = q.length;\n\n//             for (let i = 0; i < size; i++) {\n//                 const node = q.shift();\n//                 if (node.left !== null) {\n//                     q.push(node.left);\n//                 }\n//                 if (node.right !== null) {\n//                     q.push(node.right);\n//                 }\n//             }\n//             level++;\n//         }\n//         return level;\n//     }\n// }\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\n// RECURSIVE DFS\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if (root == nullptr) {\n            return 0;\n        }\n\n        return 1 + max(maxDepth(root->left), maxDepth(root->right));\n    }\n};\n\n// ITERATIVE DFS\n// class Solution {\n// public:\n//     int maxDepth(TreeNode* root) {\n//         stack<pair<TreeNode*, int>> stack;\n//         stack.push({root, 1});\n//         int res = 0;\n\n//         while (!stack.empty()) {\n//             pair<TreeNode*, int> current = stack.top();\n//             stack.pop();\n//             TreeNode* node = current.first;\n//             int depth = current.second;\n\n//             if (node != nullptr) {\n//                 res = max(res, depth);\n//                 stack.push({node->left, depth + 1});\n//                 stack.push({node->right, depth + 1});\n//             }\n//         }\n//         return res;\n//     }\n// };\n\n// BFS\n// class Solution {\n// public:\n//     int maxDepth(TreeNode* root) {\n//         queue<TreeNode*> q;\n//         if (root != nullptr) {\n//             q.push(root);\n//         }\n\n//         int level = 0;\n\n//         while (!q.empty()) {\n//             int size = q.size();\n\n//             for (int i = 0; i < size; i++) {\n//                 TreeNode* node = q.front();\n//                 q.pop();\n//                 if (node->left != nullptr) {\n//                     q.push(node->left);\n//                 }\n//                 if (node->right != nullptr) {\n//                     q.push(node->right);\n//                 }\n//             }\n//             level++;\n//         }\n//         return level;\n//     }\n// };\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// RECURSIVE DFS\npublic class Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}\n\n// ITERATIVE DFS\n// public class Solution {\n//     public int maxDepth(TreeNode root) {\n//         Stack<Pair<TreeNode, Integer>> stack = new Stack<>();\n//         stack.push(new Pair<>(root, 1));\n//         int res = 0;\n\n//         while (!stack.isEmpty()) {\n//             Pair<TreeNode, Integer> current = stack.pop();\n//             TreeNode node = current.getKey();\n//             int depth = current.getValue();\n\n//             if (node != null) {\n//                 res = Math.max(res, depth);\n//                 stack.push(new Pair<>(node.left, depth + 1));\n//                 stack.push(new Pair<>(node.right, depth + 1));\n//             }\n//         }\n//         return res;\n//     }\n// }\n\n// BFS\n// public class Solution {\n//     public int maxDepth(TreeNode root) {\n//         Queue<TreeNode> q = new LinkedList<>();\n//         if (root != null) {\n//             q.add(root);\n//         }\n\n//         int level = 0;\n\n//         while (!q.isEmpty()) {\n//             int size = q.size();\n\n//             for (int i = 0; i < size; i++) {\n//                 TreeNode node = q.poll();\n//                 if (node.left != null) {\n//                     q.add(node.left);\n//                 }\n//                 if (node.right != null) {\n//                     q.add(node.right);\n//                 }\n//             }\n//             level++;\n//         }\n//         return level;\n//     }\n// }\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\n// RECURSIVE DFS\npublic class Solution {\n    public int MaxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n\n        return 1 + Math.Max(MaxDepth(root.left), MaxDepth(root.right));\n    }\n}\n\n// ITERATIVE DFS\n// public class Solution {\n//     public int MaxDepth(TreeNode root) {\n//         Stack<Tuple<TreeNode, int>> stack = new Stack<Tuple<TreeNode, int>>();\n//         stack.Push(new Tuple<TreeNode, int>(root, 1));\n//         int res = 0;\n\n//         while (stack.Count > 0) {\n//             Tuple<TreeNode, int> current = stack.Pop();\n//             TreeNode node = current.Item1;\n//             int depth = current.Item2;\n\n//             if (node != null) {\n//                 res = Math.Max(res, depth);\n//                 stack.Push(new Tuple<TreeNode, int>(node.left, depth + 1));\n//                 stack.Push(new Tuple<TreeNode, int>(node.right, depth + 1));\n//             }\n//         }\n//         return res;\n//     }\n// }\n\n// BFS\n// public class Solution {\n//     public int MaxDepth(TreeNode root) {\n//         Queue<TreeNode> q = new Queue<TreeNode>();\n//         if (root != null) {\n//             q.Enqueue(root);\n//         }\n\n//         int level = 0;\n\n//         while (q.Count > 0) {\n//             int size = q.Count;\n\n//             for (int i = 0; i < size; i++) {\n//                 TreeNode node = q.Dequeue();\n//                 if (node.left != null) {\n//                     q.Enqueue(node.left);\n//                 }\n//                 if (node.right != null) {\n//                     q.Enqueue(node.right);\n//                 }\n//             }\n//             level++;\n//         }\n//         return level;\n//     }\n// }\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxDepth(self, root: Optional[TreeNode]) -> int:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    maxDepth(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int MaxDepth(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/hTM3phVI6YQ"},{"id":"same-binary-tree","name":"Same Binary Tree","description":"Given the roots of two binary trees `p` and `q`, return `true` if the trees are **equivalent**, otherwise return `false`.\n\nTwo binary trees are considered **equivalent** if they share the exact same structure and the nodes have the same values.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e78fc10c-4692-471f-5261-61e9be4f3a00/public)\n\n```java\nInput: p = [1,2,3], q = [1,2,3]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0b0ee764-c643-46ff-cb3f-86ce8b58ab00/public)\n\n```java\nInput: p = [4,7], q = [4,null,7]\n\nOutput: false\n```\n\n**Example 3:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/4d811f95-0488-490b-1f4f-fc5489df0f00/public)\n\n```java\nInput: p = [1,2,3], q = [1,3,2]\n\nOutput: false\n```\n\n**Constraints:**\n* `0 <= The number of nodes in both trees <= 100`.\n* `-100 <= Node.val <= 100`\n","difficulty":"Easy","concepts":["Binary Tree","Depth-First Search","Breadth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        if not p and not q:\n            return True\n        if p and q and p.val == q.val:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)\n        else:\n            return False\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} p\n     * @param {TreeNode} q\n     * @return {boolean}\n     */\n    isSameTree(p, q) {\n        if (!p && !q) {\n            return true;\n        }\n        if (p && q && p.val === q.val) {\n            return (\n                this.isSameTree(p.left, q.left) &&\n                this.isSameTree(p.right, q.right)\n            );\n        } else {\n            return false;\n        }\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if (!p && !q) {\n            return true;\n        }\n        if (p && q && p->val == q->val) {\n            return isSameTree(p->left, q->left) && isSameTree(p->right, q->right);\n        } else {\n            return false;\n        }\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p != null && q != null && p.val == q.val) {\n            return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n        } else {\n            return false;\n        }\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p != null && q != null && p.val == q.val) {\n            return IsSameTree(p.left, q.left) && IsSameTree(p.right, q.right);\n        } else {\n            return false;\n        }\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} p\n     * @param {TreeNode} q\n     * @return {boolean}\n     */\n    isSameTree(p, q) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public bool IsSameTree(TreeNode p, TreeNode q) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/vRbbcKXCxOw"},{"id":"subtree-of-a-binary-tree","name":"Subtree of a Binary Tree","description":"Given the roots of two binary trees `root` and `subRoot`, return `true` if there is a subtree of `root` with the same structure and node values of `subRoot` and `false` otherwise.\n\nA subtree of a binary tree `tree` is a tree that consists of a node in `tree` and all of this node's descendants. The tree `tree` could also be considered as a subtree of itself.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2991a77a-9664-46ed-528d-019e392f7400/public)\n\n```java\nInput: root = [1,2,3,4,5], subRoot = [2,4,5]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ae6114cb-23a0-457f-c441-0a82b7a58500/public)\n\n```java\nInput: root = [1,2,3,4,5,null,null,6], subRoot = [2,4,5]\n\nOutput: false\n```\n\n**Constraints:**\n* `0 <= The number of nodes in both trees <= 100`.\n* `-100 <= root.val, subRoot.val <= 100`\n","difficulty":"Easy","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    \n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not subRoot:\n            return True\n        if not root:\n            return False\n\n        if self.sameTree(root, subRoot):\n            return True\n        return self.isSubtree(root.left, subRoot) or self.isSubtree(root.right, subRoot)\n\n    def sameTree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        if not root and not subRoot:\n            return True\n        if root and subRoot and root.val == subRoot.val:\n            return self.sameTree(root.left, subRoot.left) and self.sameTree(root.right, subRoot.right)\n        return False\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @param {TreeNode} subRoot\n     * @return {boolean}\n     */\n    isSubtree(root, subRoot) {\n        if (!subRoot) {\n            return true;\n        }\n        if (!root) {\n            return false;\n        }\n\n        if (this.sameTree(root, subRoot)) {\n            return true;\n        }\n        return (\n            this.isSubtree(root.left, subRoot) ||\n            this.isSubtree(root.right, subRoot)\n        );\n    }\n\n    /**\n     * @param {TreeNode} root\n     * @param {TreeNode} subRoot\n     * @return {boolean}\n     */\n    sameTree(root, subRoot) {\n        if (!root && !subRoot) {\n            return true;\n        }\n        if (root && subRoot && root.val === subRoot.val) {\n            return (\n                this.sameTree(root.left, subRoot.left) &&\n                this.sameTree(root.right, subRoot.right)\n            );\n        }\n        return false;\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        if (!subRoot) {\n            return true;\n        }\n        if (!root) {\n            return false;\n        }\n\n        if (sameTree(root, subRoot)) {\n            return true;\n        }\n        return isSubtree(root->left, subRoot) || isSubtree(root->right, subRoot);\n    }\n\n    bool sameTree(TreeNode* root, TreeNode* subRoot) {\n        if (!root && !subRoot) {\n            return true;\n        }\n        if (root && subRoot && root->val == subRoot->val) {\n            return sameTree(root->left, subRoot->left) && sameTree(root->right, subRoot->right);\n        }\n        return false;\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    \n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if (subRoot == null) {\n            return true;\n        }\n        if (root == null) {\n            return false;\n        }\n\n        if (sameTree(root, subRoot)) {\n            return true;\n        }\n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n\n    public boolean sameTree(TreeNode root, TreeNode subRoot) {\n        if (root == null && subRoot == null) {\n            return true;\n        }\n        if (root != null && subRoot != null && root.val == subRoot.val) {\n            return sameTree(root.left, subRoot.left) && sameTree(root.right, subRoot.right);\n        }\n        return false;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public bool IsSubtree(TreeNode root, TreeNode subRoot) {\n        if (subRoot == null) {\n            return true;\n        }\n        if (root == null) {\n            return false;\n        }\n\n        if (SameTree(root, subRoot)) {\n            return true;\n        }\n        return IsSubtree(root.left, subRoot) || IsSubtree(root.right, subRoot);\n    }\n\n    public bool SameTree(TreeNode root, TreeNode subRoot) {\n        if (root == null && subRoot == null) {\n            return true;\n        }\n        if (root != null && subRoot != null && root.val == subRoot.val) {\n            return SameTree(root.left, subRoot.left) && SameTree(root.right, subRoot.right);\n        }\n        return false;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:   \n    def isSubtree(self, root: Optional[TreeNode], subRoot: Optional[TreeNode]) -> bool:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @param {TreeNode} subRoot\n     * @return {boolean}\n     */\n    isSubtree(root, subRoot) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isSubtree(TreeNode* root, TreeNode* subRoot) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {  \n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {    \n    public bool IsSubtree(TreeNode root, TreeNode subRoot) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/E36O5SWp-LE"},{"id":"design-word-search-data-structure","name":"Design Word Search Data Structure","description":"Design a data structure that supports adding new words and searching for existing words.\n\nImplement the `WordDictionary` class:\n\n* `void addWord(word)` Adds `word` to the data structure.\n* `bool search(word)` Returns `true` if there is any string in the data structure that matches `word` or `false` otherwise. `word` may contain dots `'.'` where dots can be matched with any letter.\n\n**Example 1:**\n\n```java\nInput:\n[\"WordDictionary\", \"addWord\", \"day\", \"addWord\", \"bay\", \"addWord\", \"may\", \"search\", \"say\", \"search\", \"day\", \"search\", \".ay\", \"search\", \"b..\"]\n\nOutput:\n[null, null, null, null, false, true, true, true]\n\nExplanation:\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"day\");\nwordDictionary.addWord(\"bay\");\nwordDictionary.addWord(\"may\");\nwordDictionary.search(\"say\"); // return false\nwordDictionary.search(\"day\"); // return true\nwordDictionary.search(\".ay\"); // return true\nwordDictionary.search(\"b..\"); // return true\n```\n\n**Constraints:**\n* `1 <= word.length <= 20`\n* `word` in `addWord` consists of lowercase English letters.\n* `word` in `search` consist of `'.'` or lowercase English letters.\n","difficulty":"Medium","concepts":["Trie"],"solutions":{"python":"class TrieNode:\n    def __init__(self):\n        self.children = {}  # a : TrieNode\n        self.word = False\n\n\nclass WordDictionary:\n    def __init__(self):\n        self.root = TrieNode()\n\n    def addWord(self, word: str) -> None:\n        cur = self.root\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n        cur.word = True\n\n    def search(self, word: str) -> bool:\n        def dfs(j, root):\n            cur = root\n\n            for i in range(j, len(word)):\n                c = word[i]\n                if c == \".\":\n                    for child in cur.children.values():\n                        if dfs(i + 1, child):\n                            return True\n                    return False\n                else:\n                    if c not in cur.children:\n                        return False\n                    cur = cur.children[c]\n            return cur.word\n\n        return dfs(0, self.root)\n","javascript":"class TrieNode {\n    constructor() {\n        this.children = Array(26).fill(null);\n        this.word = false;\n    }\n}\n\nclass WordDictionary {\n    constructor() {\n        this.root = new TrieNode();\n    }\n\n    /**\n     * @param {string} word\n     * @return {void}\n     */\n    addWord(word) {\n        let cur = this.root;\n        for (const c of word) {\n            if (cur.children[c.charCodeAt(0) - 'a'.charCodeAt(0)] === null) {\n                cur.children[c.charCodeAt(0) - 'a'.charCodeAt(0)] =\n                    new TrieNode();\n            }\n            cur = cur.children[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n        }\n        cur.word = true;\n    }\n\n    /**\n     * @param {string} word\n     * @return {boolean}\n     */\n    search(word) {\n        return this.dfs(word, 0, this.root);\n    }\n\n    /**\n     * @param {string} word\n     * @param {number} j\n     * @param {TrieNode} root\n     * @return {boolean}\n     */\n    dfs(word, j, root) {\n        let cur = root;\n\n        for (let i = j; i < word.length; i++) {\n            const c = word[i];\n            if (c === '.') {\n                for (const child of cur.children) {\n                    if (child !== null && this.dfs(word, i + 1, child)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (\n                    cur.children[c.charCodeAt(0) - 'a'.charCodeAt(0)] === null\n                ) {\n                    return false;\n                }\n                cur = cur.children[c.charCodeAt(0) - 'a'.charCodeAt(0)];\n            }\n        }\n        return cur.word;\n    }\n}\n","cpp":"class TrieNode {\npublic:\n    std::vector<TrieNode*> children;\n    bool word;\n\n    TrieNode() : children(26, nullptr), word(false) {}\n};\n\nclass WordDictionary {\npublic:\n    TrieNode* root;\n\n    WordDictionary() : root(new TrieNode()) {}\n\n    void addWord(std::string word) {\n        TrieNode* cur = root;\n        for (char c : word) {\n            if (cur->children[c - 'a'] == nullptr) {\n                cur->children[c - 'a'] = new TrieNode();\n            }\n            cur = cur->children[c - 'a'];\n        }\n        cur->word = true;\n    }\n\n    bool search(std::string word) {\n        return dfs(word, 0, root);\n    }\n\nprivate:\n    bool dfs(std::string word, int j, TrieNode* root) {\n        TrieNode* cur = root;\n\n        for (int i = j; i < word.size(); i++) {\n            char c = word[i];\n            if (c == '.') {\n                for (TrieNode* child : cur->children) {\n                    if (child != nullptr && dfs(word, i + 1, child)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (cur->children[c - 'a'] == nullptr) {\n                    return false;\n                }\n                cur = cur->children[c - 'a'];\n            }\n        }\n        return cur->word;\n    }\n};\n","java":"class TrieNode {\n    \n    TrieNode[] children;\n    boolean word;\n    \n    public TrieNode() {\n        children = new TrieNode[26];\n        word = false;\n    }\n}\n\nclass WordDictionary {\n    \n    private TrieNode root;\n\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n\n    public void addWord(String word) {\n        TrieNode cur = root;\n        for (char c : word.toCharArray()) {\n            if (cur.children[c - 'a'] == null) {\n                cur.children[c - 'a'] = new TrieNode();\n            }\n            cur = cur.children[c - 'a'];\n        }\n        cur.word = true;\n    }\n\n    public boolean search(String word) {\n        return dfs(word, 0, root);\n    }\n\n    private boolean dfs(String word, int j, TrieNode root) {\n        TrieNode cur = root;\n\n        for (int i = j; i < word.length(); i++) {\n            char c = word.charAt(i);\n            if (c == '.') {\n                for (TrieNode child : cur.children) {\n                    if (child != null && dfs(word, i + 1, child)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (cur.children[c - 'a'] == null) {\n                    return false;\n                }\n                cur = cur.children[c - 'a'];\n            }\n        }\n        return cur.word;\n    }\n}\n","csharp":"public class TrieNode {\n    public TrieNode[] children = new TrieNode[26];\n    public bool word = false;\n}\n\npublic class WordDictionary {\n    \n    private TrieNode root;\n\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n\n    public void AddWord(string word) {\n        TrieNode cur = root;\n        foreach (char c in word) {\n            if (cur.children[c - 'a'] == null) {\n                cur.children[c - 'a'] = new TrieNode();\n            }\n            cur = cur.children[c - 'a'];\n        }\n        cur.word = true;\n    }\n\n    public bool Search(string word) {\n        return Dfs(word, 0, root);\n    }\n\n    private bool Dfs(string word, int j, TrieNode root) {\n        TrieNode cur = root;\n\n        for (int i = j; i < word.Length; i++) {\n            char c = word[i];\n            if (c == '.') {\n                foreach (TrieNode child in cur.children) {\n                    if (child != null && Dfs(word, i + 1, child)) {\n                        return true;\n                    }\n                }\n                return false;\n            } else {\n                if (cur.children[c - 'a'] == null) {\n                    return false;\n                }\n                cur = cur.children[c - 'a'];\n            }\n        }\n        return cur.word;\n    }\n}\n"},"starterCode":{"python":"class WordDictionary:\n\n    def __init__(self):\n        \n\n    def addWord(self, word: str) -> None:\n        \n\n    def search(self, word: str) -> bool:\n        \n","javascript":"class WordDictionary {\n    constructor() {}\n\n    /**\n     * @param {string} word\n     * @return {void}\n     */\n    addWord(word) {}\n\n    /**\n     * @param {string} word\n     * @return {boolean}\n     */\n    search(word) {}\n}\n","cpp":"class WordDictionary {\npublic:\n    WordDictionary() {\n        \n    }\n    \n    void addWord(string word) {\n        \n    }\n    \n    bool search(string word) {\n        \n    }\n};\n","java":"class WordDictionary {\n\n    public WordDictionary() {\n\n    }\n\n    public void addWord(String word) {\n\n    }\n\n    public boolean search(String word) {\n\n    }\n}\n","csharp":"public class WordDictionary {\n\n    public WordDictionary() {\n        \n    }\n    \n    public void AddWord(string word) {\n        \n    }\n    \n    public bool Search(string word) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/BTf05gs_8iU"},{"id":"search-for-word","name":"Search for Word","description":"Given a 2-D grid of characters `board` and a string `word`, return `true` if the word is present in the grid, otherwise return `false`.\n\nFor the word to be present it must be possible to form it with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7c1fcf82-71c8-4750-3ddd-4ab6a666a500/public)\n\n```java\nInput: \nboard = [\n  [\"A\",\"B\",\"C\",\"D\"],\n  [\"S\",\"A\",\"A\",\"T\"],\n  [\"A\",\"C\",\"A\",\"E\"]\n],\nword = \"CAT\"\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/79721392-44b6-4de7-c571-d3d1640ac100/public)\n\n```java\nInput: \nboard = [\n  [\"A\",\"B\",\"C\",\"D\"],\n  [\"S\",\"A\",\"A\",\"T\"],\n  [\"A\",\"C\",\"A\",\"E\"]\n],\nword = \"BAT\"\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= board.length, board[i].length <= 5`\n* `1 <= word.length <= 10`\n* `board` and `word` consists of only lowercase and uppercase English letters.\n","difficulty":"Medium","concepts":["Tree Maze","Matrix DFS"],"solutions":{"python":"class Solution:\n    \n    def exist(self, board: List[List[str]], word: str) -> bool:\n        m = len(board)\n        n = len(board[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == word[0]:\n                    if self.dfs(board, word, 0, i, j, m, n):\n                        return True\n        \n        return False\n    \n    def dfs(self, board: List[List[str]], word: str, index: int, i: int, j: int, m: int, n: int):\n        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != word[index]:\n            return False\n        if index == len(word) - 1:\n            return True\n        \n        board[i][j] = '#'\n        \n        if (self.dfs(board, word, index + 1, i - 1, j, m, n)\n            or self.dfs(board, word, index + 1, i + 1, j, m, n)\n            or self.dfs(board, word, index + 1, i, j - 1, m, n)\n            or self.dfs(board, word, index + 1, i, j + 1, m, n)):\n            return True\n        \n        board[i][j] = word[index]\n        return False\n","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @param {string} word\n     * @return {boolean}\n     */\n    exist(board, word) {\n        const m = board.length;\n        const n = board[0].length;\n\n        for (let i = 0; i < m; i++) {\n            for (let j = 0; j < n; j++) {\n                if (board[i][j] == word[0]) {\n                    if (this.dfs(board, word, 0, i, j, m, n)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * @param {character[][]} board\n     * @param {string} word\n     * @param {number} index\n     * @param {number} i\n     * @param {number} j\n     * @param {number} m\n     * @param {number} n\n     * @return {boolean}\n     */\n    dfs(board, word, index, i, j, m, n) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[index]) {\n            return false;\n        }\n        if (index == word.length - 1) {\n            return true;\n        }\n\n        board[i][j] = '#';\n\n        if (\n            this.dfs(board, word, index + 1, i - 1, j, m, n) ||\n            this.dfs(board, word, index + 1, i + 1, j, m, n) ||\n            this.dfs(board, word, index + 1, i, j - 1, m, n) ||\n            this.dfs(board, word, index + 1, i, j + 1, m, n)\n        ) {\n            return true;\n        }\n\n        board[i][j] = word[index];\n        return false;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        int m = board.size();\n        int n = board[0].size();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == word[0]) {\n                    if (dfs(board, word, 0, i, j, m, n)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \nprivate:\n    bool dfs(vector<vector<char>>& board, string word,\n        int index, int i, int j, int m, int n) {\n        \n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[index]) {\n            return false;\n        }\n        if (index == word.size() - 1) {\n            return true;\n        }\n        \n        board[i][j] = '#';\n        \n        if (dfs(board, word, index + 1, i - 1, j, m, n)\n            || dfs(board, word, index + 1, i + 1, j, m, n)\n            || dfs(board, word, index + 1, i, j - 1, m, n)\n            || dfs(board, word, index + 1, i, j + 1, m, n)) {\n            return true;\n        }\n        \n        board[i][j] = word[index];\n        return false;\n    }\n};\n","java":"class Solution {\n    \n    public boolean exist(char[][] board, String word) {\n        int m = board.length;\n        int n = board[0].length;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == word.charAt(0)) {\n                    if (dfs(board, word, 0, i, j, m, n)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private boolean dfs(char[][] board, String word, int index, int i, int j, int m, int n) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word.charAt(index)) {\n            return false;\n        }\n        if (index == word.length() - 1) {\n            return true;\n        }\n        \n        board[i][j] = '#';\n        \n        if (dfs(board, word, index + 1, i - 1, j, m, n)\n            || dfs(board, word, index + 1, i + 1, j, m, n)\n            || dfs(board, word, index + 1, i, j - 1, m, n)\n            || dfs(board, word, index + 1, i, j + 1, m, n)) {\n            return true;\n        }\n        \n        board[i][j] = word.charAt(index);\n        return false;\n    }\n}\n","csharp":"public class Solution {\n    \n    public bool Exist(char[][] board, string word) {\n        int m = board.Length;\n        int n = board[0].Length;\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == word[0]) {\n                    if (Dfs(board, word, 0, i, j, m, n)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    private bool Dfs(char[][] board, string word, int index, int i, int j, int m, int n) {\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != word[index]) {\n            return false;\n        }\n        if (index == word.Length - 1) {\n            return true;\n        }\n        \n        board[i][j] = '#';\n        \n        if (Dfs(board, word, index + 1, i - 1, j, m, n)\n            || Dfs(board, word, index + 1, i + 1, j, m, n)\n            || Dfs(board, word, index + 1, i, j - 1, m, n)\n            || Dfs(board, word, index + 1, i, j + 1, m, n)) {\n            return true;\n        }\n        \n        board[i][j] = word[index];\n        return false;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @param {string} word\n     * @return {boolean}\n     */\n    exist(board, word) {}\n}\n","cpp":"class Solution {\npublic:\n    bool exist(vector<vector<char>>& board, string word) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean exist(char[][] board, String word) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool Exist(char[][] board, string word) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/pfiQ_PS1g8E"},{"id":"search-for-word-ii","name":"Search for Word II","description":"Given a 2-D grid of characters `board` and a list of strings `words`, return all words that are present in the grid.\n\nFor a word to be present it must be possible to form the word with a path in the board with horizontally or vertically neighboring cells. The same cell may not be used more than once in a word.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/06435c8e-bac3-49f5-5df7-77fd5dd42800/public)\n\n```java\nInput:\nboard = [\n  [\"a\",\"b\",\"c\",\"d\"],\n  [\"s\",\"a\",\"a\",\"t\"],\n  [\"a\",\"c\",\"k\",\"e\"],\n  [\"a\",\"c\",\"d\",\"n\"]\n],\nwords = [\"bat\",\"cat\",\"back\",\"backend\",\"stack\"]\n\nOutput: [\"cat\",\"back\",\"backend\"]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6f244a10-78bf-4a30-0a5f-b8f3e03ce000/public)\n\n```java\nInput:\nboard = [\n  [\"x\",\"o\"],\n  [\"x\",\"o\"]\n],\nwords = [\"xoxo\"]\n\nOutput: []\n```\n\n**Constraints:**\n* `1 <= board.length, board[i].length <= 10`\n* `board[i]` consists only of lowercase English letter.\n* `1 <= words.length <= 100`\n* `1 <= words[i].length <= 10`\n* `words[i]` consists only of lowercase English letters.\n* All strings within `words` are distinct.\n","difficulty":"Hard","concepts":["Matrix DFS","Trie"],"solutions":{"python":"class TrieNode:\n    def __init__(self):\n        self.children = {}\n        self.isWord = False\n        self.refs = 0\n\n    def addWord(self, word):\n        cur = self\n        cur.refs += 1\n        for c in word:\n            if c not in cur.children:\n                cur.children[c] = TrieNode()\n            cur = cur.children[c]\n            cur.refs += 1\n        cur.isWord = True\n\n    def removeWord(self, word):\n        cur = self\n        cur.refs -= 1\n        for c in word:\n            if c in cur.children:\n                cur = cur.children[c]\n                cur.refs -= 1\n\nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        root = TrieNode()\n        for w in words:\n            root.addWord(w)\n\n        ROWS, COLS = len(board), len(board[0])\n        res, visit = set(), set()\n\n        def dfs(r, c, node, word):\n            if (\n                r not in range(ROWS) \n                or c not in range(COLS)\n                or board[r][c] not in node.children\n                or node.children[board[r][c]].refs < 1\n                or (r, c) in visit\n            ):\n                return\n\n            visit.add((r, c))\n            node = node.children[board[r][c]]\n            word += board[r][c]\n            if node.isWord:\n                node.isWord = False\n                res.add(word)\n                root.removeWord(word)\n\n            dfs(r + 1, c, node, word)\n            dfs(r - 1, c, node, word)\n            dfs(r, c + 1, node, word)\n            dfs(r, c - 1, node, word)\n            visit.remove((r, c))\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, root, \"\")\n\n        return list(res)\n","javascript":"class TrieNode {\n    constructor() {\n        this.children = {};\n        this.isWord = false;\n        this.refs = 0;\n    }\n\n    /**\n     * @param {string} word\n     */\n    addWord(word) {\n        let cur = this;\n        cur.refs++;\n        for (const c of word) {\n            if (!cur.children[c]) {\n                cur.children[c] = new TrieNode();\n            }\n            cur = cur.children[c];\n            cur.refs++;\n        }\n        cur.isWord = true;\n    }\n\n    /**\n     * @param {string} word\n     */\n    removeWord(word) {\n        let cur = this;\n        cur.refs--;\n        for (const c of word) {\n            if (cur.children[c]) {\n                cur = cur.children[c];\n                cur.refs--;\n            }\n        }\n    }\n}\n\nclass Solution {\n    constructor() {\n        this.ROWS = 0;\n        this.COLS = 0;\n    }\n\n    /**\n     * @param {character[][]} board\n     * @param {string[]} words\n     * @return {string[]}\n     */\n    findWords(board, words) {\n        const res = new Set();\n        const visit = new Set();\n        const root = new TrieNode();\n\n        for (const w of words) {\n            root.addWord(w);\n        }\n\n        this.ROWS = board.length;\n        this.COLS = board[0].length;\n\n        for (let r = 0; r < this.ROWS; r++) {\n            for (let c = 0; c < this.COLS; c++) {\n                this.dfs(r, c, root, '', board, res, visit, root);\n            }\n        }\n\n        return Array.from(res);\n    }\n\n    /**\n     * @param {number} r\n     * @param {number} c\n     * @param {TrieNode} node\n     * @param {string} word\n     * @param {character[][]} board\n     * @param {Set<string>} res\n     * @param {Set<string>} visit\n     * @param {TrieNode} root\n     */\n    dfs(r, c, node, word, board, res, visit, root) {\n        if (\n            r < 0 ||\n            r >= this.ROWS ||\n            c < 0 ||\n            c >= this.COLS ||\n            !node.children[board[r][c]] ||\n            node.children[board[r][c]].refs < 1 ||\n            visit.has(r + ',' + c)\n        ) {\n            return;\n        }\n\n        visit.add(r + ',' + c);\n        node = node.children[board[r][c]];\n        word += board[r][c];\n        if (node.isWord) {\n            node.isWord = false;\n            res.add(word);\n            root.removeWord(word);\n        }\n\n        this.dfs(r + 1, c, node, word, board, res, visit, root);\n        this.dfs(r - 1, c, node, word, board, res, visit, root);\n        this.dfs(r, c + 1, node, word, board, res, visit, root);\n        this.dfs(r, c - 1, node, word, board, res, visit, root);\n        visit.delete(r + ',' + c);\n    }\n}\n","cpp":"class TrieNode {\npublic:\n    map<char, TrieNode*> children;\n    bool isWord = false;\n    int refs = 0;\n\n    void addWord(string word) {\n        TrieNode* cur = this;\n        cur->refs++;\n        for (char c : word) {\n            if (cur->children.count(c) == 0) {\n                cur->children[c] = new TrieNode();\n            }\n            cur = cur->children[c];\n            cur->refs++;\n        }\n        cur->isWord = true;\n    }\n\n    void removeWord(string word) {\n        TrieNode* cur = this;\n        cur->refs--;\n        for (char c : word) {\n            if (cur->children.count(c) > 0) {\n                cur = cur->children[c];\n                cur->refs--;\n            }\n        }\n    }\n};\n\nclass Solution {\npublic:\n    int ROWS, COLS;\n\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        unordered_set<string> res;\n        unordered_set<string> visit;\n        TrieNode* root = new TrieNode();\n\n        for (string& w : words) {\n            root->addWord(w);\n        }\n\n        ROWS = board.size();\n        COLS = board[0].size();\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                dfs(r, c, root, \"\", board, res, visit, root);\n            }\n        }\n\n        return vector<string>(res.begin(), res.end());\n    }\n\nprivate:\n    void dfs(int r, int c, TrieNode* node, string word, vector<vector<char>>& board,\n             unordered_set<string>& res, unordered_set<string>& visit, TrieNode* root) {\n        if (\n                r < 0 || r >= ROWS ||\n                        c < 0 || c >= COLS ||\n                        node->children.count(board[r][c]) == 0 ||\n                        node->children[board[r][c]]->refs < 1 ||\n                        visit.count(to_string(r) + \",\" + to_string(c)) > 0\n        ) {\n            return;\n        }\n\n        visit.insert(to_string(r) + \",\" + to_string(c));\n        node = node->children[board[r][c]];\n        word += board[r][c];\n        if (node->isWord) {\n            node->isWord = false;\n            res.insert(word);\n            root->removeWord(word);\n        }\n\n        dfs(r + 1, c, node, word, board, res, visit, root);\n        dfs(r - 1, c, node, word, board, res, visit, root);\n        dfs(r, c + 1, node, word, board, res, visit, root);\n        dfs(r, c - 1, node, word, board, res, visit, root);\n        visit.erase(to_string(r) + \",\" + to_string(c));\n    }\n};\n","java":"class TrieNode {\n    \n    Map<Character, TrieNode> children = new HashMap<>();\n    boolean isWord = false;\n    int refs = 0;\n\n    public void addWord(String word) {\n        TrieNode cur = this;\n        cur.refs++;\n        for (char c : word.toCharArray()) {\n            cur.children.putIfAbsent(c, new TrieNode());\n            cur = cur.children.get(c);\n            cur.refs++;\n        }\n        cur.isWord = true;\n    }\n\n    public void removeWord(String word) {\n        TrieNode cur = this;\n        cur.refs--;\n        for (char c : word.toCharArray()) {\n            if (cur.children.containsKey(c)) {\n                cur = cur.children.get(c);\n                cur.refs--;\n            }\n        }\n    }\n}\n\nclass Solution {\n    \n    int ROWS, COLS;\n\n    public List<String> findWords(char[][] board, String[] words) {\n        Set<String> res = new HashSet<>();\n        Set<String> visit = new HashSet<>();\n        TrieNode root = new TrieNode();\n\n        for (String w : words) {\n            root.addWord(w);\n        }\n\n        ROWS = board.length;\n        COLS = board[0].length;\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                dfs(r, c, root, \"\", board, res, visit, root);\n            }\n        }\n\n        return new ArrayList<>(res);\n    }\n\n    private void dfs(int r, int c, TrieNode node, String word, char[][] board,\n                    Set<String> res, Set<String> visit, TrieNode root) {\n        if (\n                r < 0 || r >= ROWS ||\n                        c < 0 || c >= COLS ||\n                        !node.children.containsKey(board[r][c]) ||\n                        node.children.get(board[r][c]).refs < 1 ||\n                        visit.contains(r + \",\" + c)\n        ) {\n            return;\n        }\n\n        visit.add(r + \",\" + c);\n        node = node.children.get(board[r][c]);\n        word += board[r][c];\n        if (node.isWord) {\n            node.isWord = false;\n            res.add(word);\n            root.removeWord(word);\n        }\n\n        dfs(r + 1, c, node, word, board, res, visit, root);\n        dfs(r - 1, c, node, word, board, res, visit, root);\n        dfs(r, c + 1, node, word, board, res, visit, root);\n        dfs(r, c - 1, node, word, board, res, visit, root);\n        visit.remove(r + \",\" + c);\n    }\n}\n","csharp":"public class TrieNode {\n    \n    public Dictionary<char, TrieNode> children = new Dictionary<char, TrieNode>();\n    public bool isWord = false;\n    public int refs = 0;\n\n    public void AddWord(string word) {\n        TrieNode cur = this;\n        cur.refs++;\n        foreach (char c in word) {\n            if (!cur.children.ContainsKey(c)) {\n                cur.children[c] = new TrieNode();\n            }\n            cur = cur.children[c];\n            cur.refs++;\n        }\n        cur.isWord = true;\n    }\n\n    public void RemoveWord(string word) {\n        TrieNode cur = this;\n        cur.refs--;\n        foreach (char c in word) {\n            if (cur.children.ContainsKey(c)) {\n                cur = cur.children[c];\n                cur.refs--;\n            }\n        }\n    }\n}\n\npublic class Solution {\n    int ROWS, COLS;\n\n    public List<string> FindWords(char[][] board, string[] words) {\n        HashSet<string> res = new HashSet<string>();\n        HashSet<string> visit = new HashSet<string>();\n        TrieNode root = new TrieNode();\n\n        foreach (string w in words) {\n            root.AddWord(w);\n        }\n\n        ROWS = board.Length;\n        COLS = board[0].Length;\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                Dfs(r, c, root, \"\", board, res, visit, root);\n            }\n        }\n\n        return new List<string>(res);\n    }\n\n    private void Dfs(int r, int c, TrieNode node, string word, char[][] board,\n                    HashSet<string> res, HashSet<string> visit, TrieNode root) {\n        if (\n                r < 0 || r >= ROWS ||\n                        c < 0 || c >= COLS ||\n                        !node.children.ContainsKey(board[r][c]) ||\n                        node.children[board[r][c]].refs < 1 ||\n                        visit.Contains(r + \",\" + c)\n        ) {\n            return;\n        }\n\n        visit.Add(r + \",\" + c);\n        node = node.children[board[r][c]];\n        word += board[r][c];\n        if (node.isWord) {\n            node.isWord = false;\n            res.Add(word);\n            root.RemoveWord(word);\n        }\n\n        Dfs(r + 1, c, node, word, board, res, visit, root);\n        Dfs(r - 1, c, node, word, board, res, visit, root);\n        Dfs(r, c + 1, node, word, board, res, visit, root);\n        Dfs(r, c - 1, node, word, board, res, visit, root);\n        visit.Remove(r + \",\" + c);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        ","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @param {string[]} words\n     * @return {string[]}\n     */\n    findWords(board, words) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {\n        \n    }\n};\n","java":"class Solution {\n    public List<String> findWords(char[][] board, String[] words) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<string> FindWords(char[][] board, string[] words) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/asbcE9mZz_U"},{"id":"clone-graph","name":"Clone Graph","description":"Given a node in a connected undirected graph, return a deep copy of the graph.\n\nEach node in the graph contains an integer value and a list of its neighbors.\n\n```java\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\nThe graph is shown in the test cases as an adjacency list. **An adjacency list** is a mapping of nodes to lists, used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\n\nFor simplicity, nodes values are numbered from 1 to `n`, where `n` is the total number of nodes in the graph. The index of each node within the adjacency list is the same as the node's value (1-indexed).\n\nThe input node will always be the first node in the graph and have `1` as the value.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ca68c09d-4d0e-4d80-9c20-078c666cf900/public)\n\n```java\nInput: adjList = [[2],[1,3],[2]]\n\nOutput: [[2],[1,3],[2]]\n```\n\nExplanation: There are 3 nodes in the graph.\nNode 1: val = 1 and neighbors = [2].\nNode 2: val = 2 and neighbors = [1, 3].\nNode 3: val = 3 and neighbors = [2].\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/96c7fb34-26e8-42e0-5f5d-61b8b8c96800/public)\n\n```java\nInput: adjList = [[]]\n\nOutput: [[]]\n```\n\nExplanation: The graph has one node with no neighbors.\n\n**Example 3:**\n\n```java\nInput: adjList = []\n\nOutput: []\n```\n\nExplanation: The graph is empty.\n\n**Constraints:**\n* `0 <= The number of nodes in the graph <= 100`.\n* `1 <= Node.val <= 100`\n* There are no duplicate edges and no self-loops in the graph.\n","difficulty":"Medium","concepts":["Adjacency List"],"solutions":{"python":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        oldToNew = {}\n\n        def dfs(node):\n            if node in oldToNew:\n                return oldToNew[node]\n\n            copy = Node(node.val)\n            oldToNew[node] = copy\n            for nei in node.neighbors:\n                copy.neighbors.append(dfs(nei))\n            return copy\n\n        return dfs(node) if node else None\n","javascript":"/**\n * // Definition for a Node.\n * class Node {\n *     constructor(val = 0, neighbors = []) {\n *       this.val = val;\n *       this.neighbors = neighbors;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {Node} node\n     * @return {Node}\n     */\n    cloneGraph(node) {\n        const oldToNew = new Map();\n        return this.dfs(node, oldToNew);\n    }\n\n    /**\n     * @param {Node} node\n     * @param {Map} oldToNew\n     * @return {Node}\n     */\n    dfs(node, oldToNew) {\n        if (node === null) {\n            return null;\n        }\n\n        if (oldToNew.has(node)) {\n            return oldToNew.get(node);\n        }\n\n        const copy = new Node(node.val);\n        oldToNew.set(node, copy);\n\n        for (const nei of node.neighbors) {\n            copy.neighbors.push(this.dfs(nei, oldToNew));\n        }\n\n        return copy;\n    }\n}\n","cpp":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        map<Node*, Node*> oldToNew;\n        return dfs(node, oldToNew);\n    }\n\n    Node* dfs(Node* node, map<Node*, Node*>& oldToNew) {\n        if (node == nullptr) {\n            return nullptr;\n        }\n\n        if (oldToNew.count(node)) {\n            return oldToNew[node];\n        }\n\n        Node* copy = new Node(node->val);\n        oldToNew[node] = copy;\n\n        for (Node* nei : node->neighbors) {\n            copy->neighbors.push_back(dfs(nei, oldToNew));\n        }\n\n        return copy;\n    }\n};\n","java":"/*\nDefinition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    \n    public Node cloneGraph(Node node) {\n        Map<Node, Node> oldToNew = new HashMap<>();\n\n        return dfs(node, oldToNew);\n    }\n\n    private Node dfs(Node node, Map<Node, Node> oldToNew) {\n        if (node == null) {\n            return null;\n        }\n\n        if (oldToNew.containsKey(node)) {\n            return oldToNew.get(node);\n        }\n\n        Node copy = new Node(node.val);\n        oldToNew.put(node, copy);\n\n        for (Node nei : node.neighbors) {\n            copy.neighbors.add(dfs(nei, oldToNew));\n        }\n\n        return copy;\n    }\n}\n","csharp":"/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> neighbors;\n\n    public Node() {\n        val = 0;\n        neighbors = new List<Node>();\n    }\n\n    public Node(int _val) {\n        val = _val;\n        neighbors = new List<Node>();\n    }\n\n    public Node(int _val, List<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\npublic class Solution {\n    \n    public Node CloneGraph(Node node) {\n        Dictionary<Node, Node> oldToNew = new Dictionary<Node, Node>();\n        return Dfs(node, oldToNew);\n    }\n\n    private Node Dfs(Node node, Dictionary<Node, Node> oldToNew) {\n        if (node == null)\n            return null;\n\n        if (oldToNew.ContainsKey(node))\n            return oldToNew[node];\n\n        Node copy = new Node(node.val);\n        oldToNew[node] = copy;\n\n        foreach (Node nei in node.neighbors)\n            copy.neighbors.Add(Dfs(nei, oldToNew));\n\n        return copy;\n    }\n}\n"},"starterCode":{"python":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val = 0, neighbors = None):\n        self.val = val\n        self.neighbors = neighbors if neighbors is not None else []\n\"\"\"\n\nclass Solution:\n    def cloneGraph(self, node: Optional['Node']) -> Optional['Node']:\n        ","javascript":"/**\n * // Definition for a Node.\n * class Node {\n *     constructor(val = 0, neighbors = []) {\n *       this.val = val;\n *       this.neighbors = neighbors;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {Node} node\n     * @return {Node}\n     */\n    cloneGraph(node) {}\n}\n","cpp":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> neighbors;\n    Node() {\n        val = 0;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val) {\n        val = _val;\n        neighbors = vector<Node*>();\n    }\n    Node(int _val, vector<Node*> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        \n    }\n};\n","java":"/*\nDefinition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    public Node cloneGraph(Node node) {\n        \n    }\n}","csharp":"/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public IList<Node> neighbors;\n\n    public Node() {\n        val = 0;\n        neighbors = new List<Node>();\n    }\n\n    public Node(int _val) {\n        val = _val;\n        neighbors = new List<Node>();\n    }\n\n    public Node(int _val, List<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\npublic class Solution {\n    public Node CloneGraph(Node node) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/mQeF6bN8hMk"},{"id":"pacific-atlantic-water-flow","name":"Pacific Atlantic Water Flow","description":"You are given a rectangular island `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.\n    \nThe islands borders the **Pacific Ocean** from the top and left sides, and borders the **Atlantic Ocean** from the bottom and right sides.\n\nWater can flow in **four directions** (up, down, left, or right) from a cell to a neighboring cell with **height equal or lower**. Water can also flow into the ocean from cells adjacent to the ocean.\n\nFind all cells where water can flow from that cell to **both** the Pacific and Atlantic oceans. Return it as a **2D list** where each element is a list `[r, c]` representing the row and column of the cell. You may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/3899fae1-ab18-4d6b-15b4-c7f7aa224700/public)\n\n```java\nInput: heights = [\n  [4,2,7,3,4],\n  [7,4,6,4,7],\n  [6,3,5,3,6]\n]\n\nOutput: [[0,2],[0,4],[1,0],[1,1],[1,2],[1,3],[1,4],[2,0]]\n```\n\n**Example 2:**\n\n```java\nInput: heights = [[1],[1]]\n\nOutput: [[0,0],[0,1]]\n```\n\n**Constraints:**\n* `1 <= heights.length, heights[r].length <= 100`\n* `0 <= heights[r][c] <= 1000`\n","difficulty":"Medium","concepts":["Matrix DFS"],"solutions":{"python":"class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ROWS, COLS = len(heights), len(heights[0])\n        pac, atl = set(), set()\n\n        def dfs(r, c, visit, prevHeight):\n            if (\n                (r, c) in visit\n                or r < 0\n                or c < 0\n                or r == ROWS\n                or c == COLS\n                or heights[r][c] < prevHeight\n            ):\n                return\n            visit.add((r, c))\n            dfs(r + 1, c, visit, heights[r][c])\n            dfs(r - 1, c, visit, heights[r][c])\n            dfs(r, c + 1, visit, heights[r][c])\n            dfs(r, c - 1, visit, heights[r][c])\n\n        for c in range(COLS):\n            dfs(0, c, pac, heights[0][c])\n            dfs(ROWS - 1, c, atl, heights[ROWS - 1][c])\n\n        for r in range(ROWS):\n            dfs(r, 0, pac, heights[r][0])\n            dfs(r, COLS - 1, atl, heights[r][COLS - 1])\n\n        res = []\n        for r in range(ROWS):\n            for c in range(COLS):\n                if (r, c) in pac and (r, c) in atl:\n                    res.append([r, c])\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} heights\n     * @return {number[][]}\n     */\n    pacificAtlantic(heights) {\n        const ROWS = heights.length,\n            COLS = heights[0].length;\n        const pac = new Set();\n        const atl = new Set();\n\n        for (let i = 0; i < ROWS; i++) {\n            this.dfs(i, 0, pac, heights[i][0], ROWS, COLS, heights);\n            this.dfs(\n                i,\n                COLS - 1,\n                atl,\n                heights[i][COLS - 1],\n                ROWS,\n                COLS,\n                heights,\n            );\n        }\n\n        for (let j = 0; j < COLS; j++) {\n            this.dfs(0, j, pac, heights[0][j], ROWS, COLS, heights);\n            this.dfs(\n                ROWS - 1,\n                j,\n                atl,\n                heights[ROWS - 1][j],\n                ROWS,\n                COLS,\n                heights,\n            );\n        }\n\n        const res = [];\n        for (let i = 0; i < ROWS; i++) {\n            for (let j = 0; j < COLS; j++) {\n                const coord = i * COLS + j;\n                if (pac.has(coord) && atl.has(coord)) {\n                    res.push([i, j]);\n                }\n            }\n        }\n        return res;\n    }\n\n    /**\n     * @param {number} r\n     * @param {number} c\n     * @param {Set} visit\n     * @param {number} prevHeight\n     * @param {number} ROWS\n     * @param {number} COLS\n     * @param {number[][]} heights\n     * @return {void}\n     */\n    dfs(r, c, visit, prevHeight, ROWS, COLS, heights) {\n        const coord = r * COLS + c;\n        if (\n            r < 0 ||\n            c < 0 ||\n            r === ROWS ||\n            c === COLS ||\n            heights[r][c] < prevHeight ||\n            visit.has(coord)\n        ) {\n            return;\n        }\n        visit.add(coord);\n        this.dfs(r + 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        this.dfs(r - 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        this.dfs(r, c + 1, visit, heights[r][c], ROWS, COLS, heights);\n        this.dfs(r, c - 1, visit, heights[r][c], ROWS, COLS, heights);\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        int ROWS = heights.size(), COLS = heights[0].size();\n        unordered_set<int> pac, atl;\n\n        for (int i = 0; i < ROWS; i++) {\n            dfs(i, 0, pac, heights[i][0], ROWS, COLS, heights);\n            dfs(i, COLS - 1, atl, heights[i][COLS - 1], ROWS, COLS, heights);\n        }\n\n        for (int j = 0; j < COLS; j++) {\n            dfs(0, j, pac, heights[0][j], ROWS, COLS, heights);\n            dfs(ROWS - 1, j, atl, heights[ROWS - 1][j], ROWS, COLS, heights);\n        }\n\n        vector<vector<int>> res;\n        for (int i = 0; i < ROWS; i++) {\n            for (int j = 0; j < COLS; j++) {\n                int coord = i * COLS + j;\n                if (pac.count(coord) && atl.count(coord)) {\n                    res.push_back({i, j});\n                }\n            }\n        }\n        return res;\n    }\n\nprivate:\n    void dfs(int r, int c, unordered_set<int>& visit, int prevHeight, int ROWS, int COLS, vector<vector<int>>& heights) {\n        int coord = r * COLS + c;\n        if (r < 0 || c < 0 || r == ROWS || c == COLS || heights[r][c] < prevHeight || visit.count(coord)) {\n            return;\n        }\n        visit.insert(coord);\n        dfs(r + 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r - 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r, c + 1, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r, c - 1, visit, heights[r][c], ROWS, COLS, heights);\n    }\n};\n","java":"class Solution {\n   \n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        int ROWS = heights.length, COLS = heights[0].length;\n        Set<Integer> pac = new HashSet<>();\n        Set<Integer> atl = new HashSet<>();\n\n        for (int i = 0; i < ROWS; i++) {\n            dfs(i, 0, pac, heights[i][0], ROWS, COLS, heights);\n            dfs(i, COLS - 1, atl, heights[i][COLS - 1], ROWS, COLS, heights);\n        }\n\n        for (int j = 0; j < COLS; j++) {\n            dfs(0, j, pac, heights[0][j], ROWS, COLS, heights);\n            dfs(ROWS - 1, j, atl, heights[ROWS - 1][j], ROWS, COLS, heights);\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        for (int i = 0; i < ROWS; i++) {\n            for (int j = 0; j < COLS; j++) {\n                int coord = i * COLS + j;\n                if (pac.contains(coord) && atl.contains(coord)) {\n                    res.add(Arrays.asList(i, j));\n                }\n            }\n        }\n        return res;\n    }\n\n    private void dfs(int r, int c, Set<Integer> visit, int prevHeight, int ROWS, int COLS, int[][] heights) {\n        int coord = r * COLS + c;\n        if (r < 0 || c < 0 || r == ROWS || c == COLS || heights[r][c] < prevHeight || visit.contains(coord)) {\n            return;\n        }\n        visit.add(coord);\n        dfs(r + 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r - 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r, c + 1, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r, c - 1, visit, heights[r][c], ROWS, COLS, heights);\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<List<int>> PacificAtlantic(int[][] heights) {\n        int ROWS = heights.Length, COLS = heights[0].Length;\n        HashSet<int> pac = new HashSet<int>();\n        HashSet<int> atl = new HashSet<int>();\n\n        for (int i = 0; i < ROWS; i++) {\n            dfs(i, 0, pac, heights[i][0], ROWS, COLS, heights);\n            dfs(i, COLS - 1, atl, heights[i][COLS - 1], ROWS, COLS, heights);\n        }\n\n        for (int j = 0; j < COLS; j++) {\n            dfs(0, j, pac, heights[0][j], ROWS, COLS, heights);\n            dfs(ROWS - 1, j, atl, heights[ROWS - 1][j], ROWS, COLS, heights);\n        }\n\n        List<List<int>> res = new List<List<int>>();\n        for (int i = 0; i < ROWS; i++) {\n            for (int j = 0; j < COLS; j++) {\n                int coord = i * COLS + j;\n                if (pac.Contains(coord) && atl.Contains(coord)) {\n                    res.Add(new List<int> { i, j });\n                }\n            }\n        }\n        return res;\n    }\n\n    private void dfs(int r, int c, HashSet<int> visit, int prevHeight, int ROWS, int COLS, int[][] heights) {\n        int coord = r * COLS + c;\n        if (r < 0 || c < 0 || r == ROWS || c == COLS || heights[r][c] < prevHeight || visit.Contains(coord)) {\n            return;\n        }\n        visit.Add(coord);\n        dfs(r + 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r - 1, c, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r, c + 1, visit, heights[r][c], ROWS, COLS, heights);\n        dfs(r, c - 1, visit, heights[r][c], ROWS, COLS, heights);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} heights\n     * @return {number[][]}\n     */\n    pacificAtlantic(heights) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> PacificAtlantic(int[][] heights) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/s-VkcjHqkGI"},{"id":"course-schedule","name":"Course Schedule","description":"You are given an array `prerequisites` where `prerequisites[i] = [a, b]` indicates that you **must** take course `b` first if you want to take course `a`.\n\nThe pair `[0, 1]`, indicates that must take course `1` before taking course `0`.\n\nThere are a total of `numCourses` courses you are required to take, labeled from `0` to `numCourses - 1`. \n\nReturn `true` if it is possible to finish all courses, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: numCourses = 2, prerequisites = [[0,1]]\n\nOutput: true\n```\nExplanation: First take course 1 (no prerequisites) and then take course 0.\n\n**Example 2:**\n\n```java\nInput: numCourses = 2, prerequisites = [[0,1],[1,0]]\n\nOutput: false\n```\n\nExplanation: In order to take course 1 you must take course 0, and to take course 0 you must take course 1. So it is impossible.\n\n**Constraints:**\n* `1 <= numCourses <= 1000`\n* `0 <= prerequisites.length <= 1000`\n* All `prerequisite` pairs are **unique**.\n","difficulty":"Medium","concepts":["Adjacency List"],"solutions":{"python":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        preMap = {i: [] for i in range(numCourses)}\n\n        for crs, pre in prerequisites:\n            preMap[crs].append(pre)\n\n        visiting = set()\n\n        def dfs(crs):\n            if crs in visiting:\n                return False\n            if preMap[crs] == []:\n                return True\n\n            visiting.add(crs)\n            for pre in preMap[crs]:\n                if not dfs(pre):\n                    return False\n            visiting.remove(crs)\n            preMap[crs] = []\n            return True\n\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True\n","javascript":"class Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {boolean}\n     */\n    canFinish(numCourses, prerequisites) {\n        const preMap = new Map();\n        const visiting = new Set();\n\n        for (let i = 0; i < numCourses; i++) {\n            preMap.set(i, []);\n        }\n\n        for (const pair of prerequisites) {\n            preMap.get(pair[0]).push(pair[1]);\n        }\n\n        for (let c = 0; c < numCourses; c++) {\n            if (!this.dfs(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @param {number} crs\n     * @param {Map} preMap\n     * @param {Set} visiting\n     * @return {boolean}\n     */\n    dfs(crs, preMap, visiting) {\n        if (visiting.has(crs)) {\n            return false;\n        }\n        if (preMap.get(crs).length === 0) {\n            return true;\n        }\n\n        visiting.add(crs);\n        for (const pre of preMap.get(crs)) {\n            if (!this.dfs(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting.delete(crs);\n        preMap.set(crs, []);\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        vector<vector<int>> preMap(numCourses);\n        for (auto& pair : prerequisites) {\n            preMap[pair[0]].push_back(pair[1]);\n        }\n\n        vector<bool> visiting(numCourses, false);\n        for (int c = 0; c < numCourses; c++) {\n            if (!dfs(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\nprivate:\n    bool dfs(int crs, vector<vector<int>>& preMap, vector<bool>& visiting) {\n        if (visiting[crs]) {\n            return false;\n        }\n        if (preMap[crs].empty()) {\n            return true;\n        }\n\n        visiting[crs] = true;\n        for (int pre : preMap[crs]) {\n            if (!dfs(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting[crs] = false;\n        preMap[crs].clear();\n        return true;\n    }\n};\n","java":"class Solution {\n\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        HashMap<Integer, List<Integer>> preMap = new HashMap<>();\n        Set<Integer> visiting = new HashSet<>();\n\n        for (int i = 0; i < numCourses; i++) {\n            preMap.put(i, new ArrayList<>());\n        }\n\n        for (int[] pair : prerequisites) {\n            preMap.get(pair[0]).add(pair[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!dfs(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean dfs(int crs, HashMap<Integer, List<Integer>> preMap, Set<Integer> visiting) {\n        if (visiting.contains(crs)) {\n            return false;\n        }\n        if (preMap.get(crs).isEmpty()) {\n            return true;\n        }\n\n        visiting.add(crs);\n        for (int pre : preMap.get(crs)) {\n            if (!dfs(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting.remove(crs);\n        preMap.put(crs, new ArrayList<>());\n        return true;\n    }\n}\n","csharp":"public class Solution {\n\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        Dictionary<int, List<int>> preMap = new Dictionary<int, List<int>>();\n        HashSet<int> visiting = new HashSet<int>();\n\n        for (int i = 0; i < numCourses; i++) {\n            preMap[i] = new List<int>();\n        }\n\n        foreach (var pair in prerequisites) {\n            preMap[pair[0]].Add(pair[1]);\n        }\n\n        for (int c = 0; c < numCourses; c++) {\n            if (!DFS(c, preMap, visiting)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private bool DFS(int crs, Dictionary<int, List<int>> preMap, HashSet<int> visiting) {\n        if (visiting.Contains(crs)) {\n            return false;\n        }\n        if (preMap[crs].Count == 0) {\n            return true;\n        }\n\n        visiting.Add(crs);\n        foreach (var pre in preMap[crs]) {\n            if (!DFS(pre, preMap, visiting)) {\n                return false;\n            }\n        }\n        visiting.Remove(crs);\n        preMap[crs] = new List<int>();\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {boolean}\n     */\n    canFinish(numCourses, prerequisites) {}\n}\n","cpp":"class Solution {\npublic:\n    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool CanFinish(int numCourses, int[][] prerequisites) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/EgI5nU9etnU"},{"id":"house-robber","name":"House Robber","description":"You are given an integer array `nums` where `nums[i]` represents the amount of money the `i`th house has. The houses are arranged in a straight line, i.e. the `i`th house is the neighbor of the `(i-1)`th and `(i+1)`th house.\n\nYou are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.\n\nReturn the *maximum* amount of money you can rob **without** alerting the police.\n\n**Example 1:**\n\n```java\nInput: nums = [1,1,3,3]\n\nOutput: 4\n```\n\nExplanation: `nums[0] + nums[2] = 1 + 3 = 4`.\n\n**Example 2:**\n\n```java\nInput: nums = [2,9,8,3,6]\n\nOutput: 16\n```\n\nExplanation: `nums[0] + nums[2] + nums[4] = 2 + 8 + 6 = 16`.\n\n**Constraints:**\n* `1 <= nums.length <= 100`\n* `0 <= nums[i] <= 100`\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP"],"solutions":{"python":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            temp = max(n + rob1, rob2)\n            rob1 = rob2\n            rob2 = temp\n        return rob2\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    rob(nums) {\n        let rob1 = 0;\n            let rob2 = 0;\n\n        for (const n of nums) {\n            const temp = Math.max(n + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        int rob1 = 0, rob2 = 0;\n\n        for (int n : nums) {\n            int temp = max(n + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n};\n","java":"class Solution {\n    public int rob(int[] nums) {\n        int rob1 = 0, rob2 = 0;\n\n        for (int n : nums) {\n            int temp = Math.max(n + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n}\n","csharp":"public class Solution {\n    public int Rob(int[] nums) {\n        int rob1 = 0, rob2 = 0;\n\n        foreach (int n in nums) {\n            int temp = Math.Max(n + rob1, rob2);\n            rob1 = rob2;\n            rob2 = temp;\n        }\n        return rob2;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    rob(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Rob(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/73r3KWiEvyk"},{"id":"house-robber-ii","name":"House Robber II","description":"You are given an integer array `nums` where `nums[i]` represents the amount of money the `i`th house has. The houses are arranged in a circle, i.e. the first house and the last house are neighbors.\n\nYou are planning to rob money from the houses, but you cannot rob **two adjacent houses** because the security system will automatically alert the police if two adjacent houses were *both* broken into.\n    \nReturn the *maximum* amount of money you can rob **without** alerting the police.\n\n**Example 1:**\n\n```java\nInput: nums = [3,4,3]\n\nOutput: 4\n```\n\nExplanation: You cannot rob `nums[0] + nums[2] = 6` because `nums[0]` and `nums[2]` are adjacent houses. The maximum you can rob is `nums[1] = 4`.\n\n**Example 2:**\n\n```java\nInput: nums = [2,9,8,3,6]\n\nOutput: 15\n```\n\nExplanation: You cannot rob `nums[0] + nums[2] + nums[4] = 16` because `nums[0]` and `nums[4]` are adjacent houses. The maximum you can rob is `nums[1] + nums[4] = 15`.\n\n\n**Constraints:**\n* `1 <= nums.length <= 100`\n* `0 <= nums[i] <= 100`\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP"],"solutions":{"python":"class Solution:\n    \n    def rob(self, nums: List[int]) -> int:\n        return max(nums[0], self.helper(nums[1:]), self.helper(nums[:-1]))\n\n    def helper(self, nums):\n        rob1, rob2 = 0, 0\n\n        for n in nums:\n            newRob = max(rob1 + n, rob2)\n            rob1 = rob2\n            rob2 = newRob\n        return rob2\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    rob(nums) {\n        return Math.max(\n            nums[0],\n            Math.max(\n                this.helper(nums.slice(1)),\n                this.helper(nums.slice(0, -1)),\n            ),\n        );\n    }\n\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    helper(nums) {\n        let rob1 = 0;\n            let rob2 = 0;\n        for (const n of nums) {\n            const newRob = Math.max(rob1 + n, rob2);\n            rob1 = rob2;\n            rob2 = newRob;\n        }\n        return rob2;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        vector<int> nums1(nums.begin() + 1, nums.end());\n        vector<int> nums2(nums.begin(), nums.end() - 1);\n        return max(nums[0], max(helper(nums1), helper(nums2)));\n    }\n\nprivate:\n    int helper(vector<int>& nums) {\n        int rob1 = 0, rob2 = 0;\n        for (int n : nums) {\n            int newRob = max(rob1 + n, rob2);\n            rob1 = rob2;\n            rob2 = newRob;\n        }\n        return rob2;\n    }\n};\n","java":"class Solution {\n    \n    public int rob(int[] nums) {\n        return Math.max(nums[0], Math.max(helper(Arrays.copyOfRange(nums, 1, nums.length)), helper(Arrays.copyOfRange(nums, 0, nums.length - 1))));\n    }\n\n    private int helper(int[] nums) {\n        int rob1 = 0, rob2 = 0;\n\n        for (int n : nums) {\n            int newRob = Math.max(rob1 + n, rob2);\n            rob1 = rob2;\n            rob2 = newRob;\n        }\n        return rob2;\n    }\n}\n","csharp":"public class Solution {\n    \n    public int Rob(int[] nums) {\n        return Math.Max(nums[0], Math.Max(Helper(nums.Skip(1).ToArray()), Helper(nums.Take(nums.Length - 1).ToArray())));\n    }\n\n    private int Helper(int[] nums) {\n        int rob1 = 0, rob2 = 0;\n        foreach (int n in nums) {\n            int newRob = Math.Max(rob1 + n, rob2);\n            rob1 = rob2;\n            rob2 = newRob;\n        }\n        return rob2;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def rob(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    rob(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int rob(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int rob(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Rob(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/rWAJCfYYOvM"},{"id":"longest-palindromic-substring","name":"Longest Palindromic Substring","description":"Given a string `s`, return the longest substring of `s` that is a *palindrome*.\n\nA **palindrome** is a string that reads the same forward and backward.\n\nIf there are multiple palindromic substrings that have the same length, return any one of them.\n\n**Example 1:**\n\n```java\nInput: s = \"ababd\"\n\nOutput: \"bab\"\n```\n\nExplanation: Both \"aba\" and \"bab\" are valid answers.\n\n**Example 2:**\n\n```java\nInput: s = \"abbc\"\n\nOutput: \"bb\"\n```\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `s` contains only digits and English letters.\n","difficulty":"Medium","concepts":["Two Pointers","Palindromes"],"solutions":{"python":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        res = \"\"\n        resLen = 0\n\n        for i in range(len(s)):\n            # odd length\n            l, r = i, i\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    res = s[l : r + 1]\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n            # even length\n            l, r = i, i + 1\n            while l >= 0 and r < len(s) and s[l] == s[r]:\n                if (r - l + 1) > resLen:\n                    res = s[l : r + 1]\n                    resLen = r - l + 1\n                l -= 1\n                r += 1\n\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {string}\n     */\n    longestPalindrome(s) {\n        let res = '';\n        let resLen = 0;\n\n        for (let i = 0; i < s.length; i++) {\n            // odd length\n            let l = i;\n                let r = i;\n            while (l >= 0 && r < s.length && s.charAt(l) === s.charAt(r)) {\n                if (r - l + 1 > resLen) {\n                    res = s.substring(l, r + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n\n            // even length\n            l = i;\n            r = i + 1;\n            while (l >= 0 && r < s.length && s.charAt(l) === s.charAt(r)) {\n                if (r - l + 1 > resLen) {\n                    res = s.substring(l, r + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n        }\n\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    string longestPalindrome(string s) {\n        string res = \"\";\n        int resLen = 0;\n\n        for (int i = 0; i < s.size(); i++) {\n            // odd length\n            int l = i, r = i;\n            while (l >= 0 && r < s.size() && s[l] == s[r]) {\n                if (r - l + 1 > resLen) {\n                    res = s.substr(l, r - l + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n\n            // even length\n            l = i;\n            r = i + 1;\n            while (l >= 0 && r < s.size() && s[l] == s[r]) {\n                if (r - l + 1 > resLen) {\n                    res = s.substr(l, r - l + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n        }\n\n        return res;\n    }\n};\n","java":"class Solution {\n    public String longestPalindrome(String s) {\n        String res = \"\";\n        int resLen = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            // odd length\n            int l = i, r = i;\n            while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n                if (r - l + 1 > resLen) {\n                    res = s.substring(l, r + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n\n            // even length\n            l = i;\n            r = i + 1;\n            while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n                if (r - l + 1 > resLen) {\n                    res = s.substring(l, r + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n        }\n\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public string LongestPalindrome(string s) {\n        string res = \"\";\n        int resLen = 0;\n\n        for (int i = 0; i < s.Length; i++) {\n            // odd length\n            int l = i, r = i;\n            while (l >= 0 && r < s.Length && s[l] == s[r]) {\n                if (r - l + 1 > resLen) {\n                    res = s.Substring(l, r - l + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n\n            // even length\n            l = i;\n            r = i + 1;\n            while (l >= 0 && r < s.Length && s[l] == s[r]) {\n                if (r - l + 1 > resLen) {\n                    res = s.Substring(l, r - l + 1);\n                    resLen = r - l + 1;\n                }\n                l--;\n                r++;\n            }\n        }\n\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def longestPalindrome(self, s: str) -> str:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {string}\n     */\n    longestPalindrome(s) {}\n}\n","cpp":"class Solution {\npublic:\n    string longestPalindrome(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public String longestPalindrome(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public string LongestPalindrome(string s) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/XYQecbcd6_c"},{"id":"palindromic-substrings","name":"Palindromic Substrings","description":"Given a string `s`, return the number of substrings within `s` that are palindromes.\n\nA **palindrome** is a string that reads the same forward and backward.\n\n**Example 1:**\n\n```java\nInput: s = \"abc\"\n\nOutput: 3\n```\n\nExplanation: \"a\", \"b\", \"c\".\n\n**Example 2:**\n\n```java\nInput: s = \"aaa\"\n\nOutput: 6\n```\n\nExplanation: \"a\", \"a\", \"a\", \"aa\", \"aa\", \"aaa\". Note that different substrings are counted as different palindromes even if the string contents are the same.\n\n**Constraints:**\n* `1 <= s.length <= 1000`\n* `s` consists of lowercase English letters.\n","difficulty":"Medium","concepts":["Two Pointers","Palindromes"],"solutions":{"python":"class Solution:\n    \n    def countSubstrings(self, s: str) -> int:\n        res = 0\n\n        for i in range(len(s)):\n            res += self.countPali(s, i, i)\n            res += self.countPali(s, i, i + 1)\n        return res\n\n    def countPali(self, s, l, r):\n        res = 0\n        while l >= 0 and r < len(s) and s[l] == s[r]:\n            res += 1\n            l -= 1\n            r += 1\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {number}\n     */\n    countSubstrings(s) {\n        let res = 0;\n        for (let i = 0; i < s.length; i++) {\n            res += this.countPali(s, i, i);\n            res += this.countPali(s, i, i + 1);\n        }\n        return res;\n    }\n\n    /**\n     * @param {string} s\n     * @param {number} l\n     * @param {number} r\n     * @return {number}\n     */\n    countPali(s, l, r) {\n        let res = 0;\n        while (l >= 0 && r < s.length && s.charAt(l) === s.charAt(r)) {\n            res++;\n            l--;\n            r++;\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int countSubstrings(string s) {\n        int res = 0;\n        for (int i = 0; i < s.size(); i++) {\n            res += countPali(s, i, i);\n            res += countPali(s, i, i + 1);\n        }\n        return res;\n    }\n\nprivate:\n    int countPali(string s, int l, int r) {\n        int res = 0;\n        while (l >= 0 && r < s.size() && s[l] == s[r]) {\n            res++;\n            l--;\n            r++;\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    \n    public int countSubstrings(String s) {\n        int res = 0;\n        for (int i = 0; i < s.length(); i++) {\n            res += countPali(s, i, i);\n            res += countPali(s, i, i + 1);\n        }\n        return res;\n    }\n\n    private int countPali(String s, int l, int r) {\n        int res = 0;\n        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {\n            res++;\n            l--;\n            r++;\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    \n    public int CountSubstrings(string s) {\n        int res = 0;\n        for (int i = 0; i < s.Length; i++) {\n            res += CountPali(s, i, i);\n            res += CountPali(s, i, i + 1);\n        }\n        return res;\n    }\n\n    private int CountPali(string s, int l, int r) {\n        int res = 0;\n        while (l >= 0 && r < s.Length && s[l] == s[r]) {\n            res++;\n            l--;\n            r++;\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def countSubstrings(self, s: str) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {number}\n     */\n    countSubstrings(s) {}\n}\n","cpp":"class Solution {\npublic:\n    int countSubstrings(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public int countSubstrings(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int CountSubstrings(string s) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/4RACzI5-du8"},{"id":"decode-ways","name":"Decode Ways","description":"A string consisting of uppercase english characters can be encoded to a number using the following mapping:\n\n```java\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n```\n\nTo **decode** a message, digits must be grouped and then mapped back into letters using the reverse of the mapping above. There may be multiple ways to decode a message. For example, `\"1012\"` can be mapped into:\n\n* `\"JAB\"` with the grouping `(10 1 2)`\n* `\"JL\"` with the grouping `(10 12)`\n\nThe grouping `(1 01 2)` is invalid because `01` cannot be mapped into a letter since it contains a leading zero.\n\nGiven a string `s` containing only digits, return the number of ways to **decode** it. You can assume that the answer fits in a **32-bit** integer.\n\n**Example 1:**\n\n```java\nInput: s = \"12\"\n\nOutput: 2\n\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\n```\n\n**Example 2:**\n\n```java\nInput: s = \"01\"\n\nOutput: 0\n```\n\nExplanation: \"01\" cannot be decoded because \"01\" cannot be mapped into a letter.\n\n**Constraints:**\n* `1 <= s.length <= 100`\n* `s` consists of digits\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP"],"solutions":{"python":"# Memoization solution \nclass Solution:\n    def numDecodings(self, s: str) -> int:\n        dp = {len(s): 1}\n\n        def dfs(i):\n            if i in dp:\n                return dp[i]\n            if s[i] == \"0\":\n                return 0\n\n            res = dfs(i + 1)\n            if i + 1 < len(s) and (\n                s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"\n            ):\n                res += dfs(i + 2)\n            dp[i] = res\n            return res\n\n        return dfs(0)\n\n# Dynamic Programming solution\n# class Solution:\n#     def numDecodings(self, s: str) -> int:\n#         dp = {len(s): 1}\n#         for i in range(len(s) - 1, -1, -1):\n#             if s[i] == \"0\":\n#                 dp[i] = 0\n#             else:\n#                 dp[i] = dp[i + 1]\n\n#             if i + 1 < len(s) and (\n#                 s[i] == \"1\" or s[i] == \"2\" and s[i + 1] in \"0123456\"\n#             ):\n#                 dp[i] += dp[i + 2]\n#         return dp[0]\n","javascript":"// Memoization solution\nclass Solution {\n    /**\n     * @param {string} s\n     * @return {number}\n     */\n    numDecodings(s) {\n        const dp = new Map();\n        dp.set(s.length, 1);\n\n        return this.dfs(s, 0, dp);\n    }\n\n    /**\n     * @param {string} s\n     * @param {number} i\n     * @param {Map} dp\n     * @return {number}\n     */\n    dfs(s, i, dp) {\n        if (dp.has(i)) {\n            return dp.get(i);\n        }\n        if (s.charAt(i) === '0') {\n            return 0;\n        }\n\n        let res = this.dfs(s, i + 1, dp);\n        if (\n            i + 1 < s.length &&\n            (s.charAt(i) === '1' ||\n                (s.charAt(i) === '2' && s.charAt(i + 1) <= '6'))\n        ) {\n            res += this.dfs(s, i + 2, dp);\n        }\n        dp.set(i, res);\n        return res;\n    }\n}\n\n// Dynamic Programming solution\n// class Solution {\n//     /**\n//      * @param {string} s\n//      * @return {number}\n//      */\n//     numDecodings(s) {\n//         let dp = new Array(s.length + 1).fill(0);\n//         dp[s.length] = 1;\n//         for (let i = s.length - 1; i >= 0; i--) {\n//             if (s.charAt(i) === '0') {\n//                 dp[i] = 0;\n//             } else {\n//                 dp[i] = dp[i + 1];\n//                 if (\n//                     i + 1 < s.length &&\n//                     (s.charAt(i) === '1' ||\n//                         (s.charAt(i) === '2' && s.charAt(i + 1) <= '6'))\n//                 ) {\n//                     dp[i] += dp[i + 2];\n//                 }\n//             }\n//         }\n//         return dp[0];\n//     }\n// }\n","cpp":"// Memoization solution\nclass Solution {\npublic:\n    int numDecodings(string s) {\n        unordered_map<int, int> dp;\n        dp[s.size()] = 1;\n        return dfs(s, 0, dp);\n    }\n\nprivate:\n    int dfs(string s, int i, unordered_map<int, int>& dp) {\n        if (dp.count(i)) {\n            return dp[i];\n        }\n        if (s[i] == '0') {\n            return 0;\n        }\n\n        int res = dfs(s, i + 1, dp);\n        if (i + 1 < s.size() && (s[i] == '1' || s[i] == '2' && s[i + 1] <= '6')) {\n            res += dfs(s, i + 2, dp);\n        }\n        dp[i] = res;\n        return res;\n    }\n};\n\n// Dynamic Programming solution\n// class Solution {\n// public:\n//     int numDecodings(string s) {\n//         vector<int> dp(s.size() + 1);\n//         dp[s.size()] = 1;\n//         for (int i = s.size() - 1; i >= 0; i--) {\n//             if (s[i] == '0') {\n//                 dp[i] = 0;\n//             } else {\n//                 dp[i] = dp[i + 1];\n//                 if (i + 1 < s.size() && (s[i] == '1' || s[i] == '2' && s[i + 1] <= '6')) {\n//                     dp[i] += dp[i + 2];\n//                 }\n//             }\n//         }\n//         return dp[0];\n//     }\n// };\n","java":"// Memoization solution\nclass Solution {\n    \n    public int numDecodings(String s) {\n        Map<Integer, Integer> dp = new HashMap<>();\n        dp.put(s.length(), 1);\n\n        return dfs(s, 0, dp);\n    }\n\n    private int dfs(String s, int i, Map<Integer, Integer> dp) {\n        if (dp.containsKey(i)) {\n            return dp.get(i);\n        }\n        if (s.charAt(i) == '0') {\n            return 0;\n        }\n\n        int res = dfs(s, i + 1, dp);\n        if (i + 1 < s.length() && (s.charAt(i) == '1' || s.charAt(i) == '2' && s.charAt(i + 1) <= '6')) {\n            res += dfs(s, i + 2, dp);\n        }\n        dp.put(i, res);\n        return res;\n    }\n}\n\n// Dynamic Programming solution\n// class Solution {\n//     public int numDecodings(String s) {    \n//         int[] dp = new int[s.length() + 1];\n//         dp[s.length()] = 1;\n//         for (int i = s.length() - 1; i >= 0; i--) {\n//             if (s.charAt(i) == '0') {\n//                 dp[i] = 0;\n//             } else {\n//                 dp[i] = dp[i + 1];\n//                 if (i + 1 < s.length() && (s.charAt(i) == '1' || s.charAt(i) == '2' && s.charAt(i + 1) <= '6')) {\n//                     dp[i] += dp[i + 2];\n//                 }\n//             }\n//         }\n//         return dp[0];\n//     }\n// }\n","csharp":"// Memoization solution\npublic class Solution {\n\n    public int NumDecodings(string s) {\n        Dictionary<int, int> dp = new Dictionary<int, int>();\n        dp[s.Length] = 1;\n        return Dfs(s, 0, dp);\n    }\n\n    private int Dfs(string s, int i, Dictionary<int, int> dp) {\n        if (dp.ContainsKey(i)) {\n            return dp[i];\n        }\n        if (s[i] == '0') {\n            return 0;\n        }\n\n        int res = Dfs(s, i + 1, dp);\n        if (i + 1 < s.Length && (s[i] == '1' || s[i] == '2' && s[i + 1] <= '6')) {\n            res += Dfs(s, i + 2, dp);\n        }\n        dp[i] = res;\n        return res;\n    }\n}\n\n// Dynamic Programming solution\n// public class Solution {\n//     public int NumDecodings(string s) {\n//         int[] dp = new int[s.Length + 1];\n//         dp[s.Length] = 1;\n//         for (int i = s.Length - 1; i >= 0; i--) {\n//             if (s[i] == '0') {\n//                 dp[i] = 0;\n//             } else {\n//                 dp[i] = dp[i + 1];\n//                 if (i + 1 < s.Length && (s[i] == '1' || s[i] == '2' && s[i + 1] <= '6')) {\n//                     dp[i] += dp[i + 2];\n//                 }\n//             }\n//         }\n//         return dp[0];\n//     }\n// }\n"},"starterCode":{"python":"class Solution:\n    def numDecodings(self, s: str) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {number}\n     */\n    numDecodings(s) {}\n}\n","cpp":"class Solution {\npublic:\n    int numDecodings(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public int numDecodings(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int NumDecodings(string s) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/6aEyTjOwlJU"},{"id":"coin-change","name":"Coin Change","description":"You are given an integer array `coins` representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer `amount` representing a target amount of money.\n\nReturn the fewest number of coins that you need to make up the *exact* target amount. If it is impossible to make up the amount, return `-1`.\n\nYou may assume that you have an unlimited number of each coin.\n\n**Example 1:**\n\n```java\nInput: coins = [1,5,10], amount = 12\n\nOutput: 3\n```\n\nExplanation: 12 = 10 + 1 + 1. Note that we do not have to use every kind coin available.\n\n**Example 2:**\n\n```java\nInput: coins = [2], amount = 3\n\nOutput: -1\n```\n\nExplanation: The amount of 3 cannot be made up with coins of 2.\n\n**Example 3:**\n\n```java\nInput: coins = [1], amount = 0\n\nOutput: 0\n```\n\nExplanation: Choosing 0 coins is a valid way to make up 0.\n\n**Constraints:**\n* `1 <= coins.length <= 10`\n* `1 <= coins[i] <= 2^31 - 1`\n* `0 <= amount <= 1000`\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP","Unbounded Knapsack"],"solutions":{"python":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n\n        for a in range(1, amount + 1):\n            for c in coins:\n                if a - c >= 0:\n                    dp[a] = min(dp[a], 1 + dp[a - c])\n        return dp[amount] if dp[amount] != amount + 1 else -1\n","javascript":"class Solution {\n    /**\n     * @param {number[]} coins\n     * @param {number} amount\n     * @return {number}\n     */\n    coinChange(coins, amount) {\n        const dp = new Array(amount + 1).fill(amount + 1);\n        dp[0] = 0;\n        for (let i = 1; i <= amount; i++) {\n            for (let j = 0; j < coins.length; j++) {\n                if (coins[j] <= i) {\n                    dp[i] = Math.min(dp[i], 1 + dp[i - coins[j]]);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        vector<int> dp(amount + 1, amount + 1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.size(); j++) {\n                if (coins[j] <= i) {\n                    dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n};\n","java":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            for (int j = 0; j < coins.length; j++) {\n                if (coins[j] <= i) {\n                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n","csharp":"public class Solution {\n    public int CoinChange(int[] coins, int amount) {\n        int[] dp = new int[amount + 1];\n        Array.Fill(dp, amount + 1);\n        dp[0] = 0;\n        for (int i = 1; i <= amount; i++) {\n            foreach (int coin in coins) {\n                if (coin <= i) {\n                    dp[i] = Math.Min(dp[i], dp[i - coin] + 1);\n                }\n            }\n        }\n        return dp[amount] > amount ? -1 : dp[amount];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} coins\n     * @param {number} amount\n     * @return {number}\n     */\n    coinChange(coins, amount) {}\n}\n","cpp":"class Solution {\npublic:\n    int coinChange(vector<int>& coins, int amount) {\n        \n    }\n};\n","java":"class Solution {\n    public int coinChange(int[] coins, int amount) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int CoinChange(int[] coins, int amount) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/H9bfqozjoqs"},{"id":"maximum-product-subarray","name":"Maximum Product Subarray","description":"Given an integer array `nums`, find a **subarray** that has the largest product within the array and return it.\n\nA **subarray** is a contiguous non-empty sequence of elements within an array.\n\nYou can assume the output will fit into a **32-bit** integer.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,-3,4]\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: nums = [-2,-1]\n\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-10 <= nums[i] <= 10`\n","difficulty":"Medium","concepts":["Kadane's Algorithm"],"solutions":{"python":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        res = nums[0]\n        curMin, curMax = 1, 1\n\n        for n in nums:\n            tmp = curMax * n\n            curMax = max(n * curMax, n * curMin, n)\n            curMin = min(tmp, n * curMin, n)\n            res = max(res, curMax)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    maxProduct(nums) {\n        let res = nums[0];\n        let curMin = 1;\n            let curMax = 1;\n\n        for (const n of nums) {\n            const tmp = curMax * n;\n            curMax = Math.max(Math.max(n * curMax, n * curMin), n);\n            curMin = Math.min(Math.min(tmp, n * curMin), n);\n            res = Math.max(res, curMax);\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        int res = nums[0];\n        int curMin = 1, curMax = 1;\n\n        for (int n : nums) {\n            int tmp = curMax * n;\n            curMax = max(max(n * curMax, n * curMin), n);\n            curMin = min(min(tmp, n * curMin), n);\n            res = max(res, curMax);\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int maxProduct(int[] nums) {\n        int res = nums[0];\n        int curMin = 1, curMax = 1;\n\n        for (int n : nums) {\n            int tmp = curMax * n;\n            curMax = Math.max(Math.max(n * curMax, n * curMin), n);\n            curMin = Math.min(Math.min(tmp, n * curMin), n);\n            res = Math.max(res, curMax);\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int MaxProduct(int[] nums) {\n        int res = nums[0];\n        int curMin = 1, curMax = 1;\n\n        foreach (int n in nums) {\n            int tmp = curMax * n;\n            curMax = Math.Max(Math.Max(n * curMax, n * curMin), n);\n            curMin = Math.Min(Math.Min(tmp, n * curMin), n);\n            res = Math.Max(res, curMax);\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    maxProduct(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxProduct(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int maxProduct(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxProduct(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/lXVy6YWFcRM"},{"id":"word-break","name":"Word Break","description":"Given a string `s` and a dictionary of strings `wordDict`, return `true` if `s` can be segmented into a space-separated sequence of dictionary words.\n\nYou are allowed to reuse words in the dictionary an unlimited number of times. You may assume all dictionary words are unique.\n\n**Example 1:**\n\n```java\nInput: s = \"neetcode\", wordDict = [\"neet\",\"code\"]\n\nOutput: true\n```\n\nExplanation: Return true because \"neetcode\" can be split into \"neet\" and \"code\".\n\n**Example 2:**\n\n```java\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\",\"ape\"]\n\nOutput: true\n```\n\nExplanation: Return true because \"applepenapple\" can be split into \"apple\", \"pen\" and \"apple\". Notice that we can reuse words and also not use all the words.\n\n**Example 3:**\n\n```java\nInput: s = \"catsincars\", wordDict = [\"cats\",\"cat\",\"sin\",\"in\",\"car\"]\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= s.length <= 200`\n* `1 <= wordDict.length <= 100`\n* `1 <= wordDict[i].length <= 20`\n* `s` and `wordDict[i]` consist of only lowercase English letters.\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP"],"solutions":{"python":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n\n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i : i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n\n        return dp[0]\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string[]} wordDict\n     * @return {boolean}\n     */\n    wordBreak(s, wordDict) {\n        const dp = new Array(s.length + 1).fill(false);\n        dp[s.length] = true;\n\n        for (let i = s.length - 1; i >= 0; i--) {\n            for (const w of wordDict) {\n                if (\n                    i + w.length <= s.length &&\n                    s.slice(i, i + w.length) === w\n                ) {\n                    dp[i] = dp[i + w.length];\n                }\n                if (dp[i]) {\n                    break;\n                }\n            }\n        }\n\n        return dp[0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        vector<bool> dp(s.size() + 1, false);\n        dp[s.size()] = true;\n\n        for (int i = s.size() - 1; i >= 0; i--) {\n            for (const auto& w : wordDict) {\n                if ((i + w.size()) <= s.size() && s.substr(i, w.size()) == w) {\n                    dp[i] = dp[i + w.size()];\n                }\n                if (dp[i]) {\n                    break;\n                }\n            }\n        }\n\n        return dp[0];\n    }\n};\n","java":"class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        boolean[] dp = new boolean[s.length() + 1];\n        dp[s.length()] = true;\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (String w : wordDict) {\n                if ((i + w.length()) <= s.length() && s.substring(i, i + w.length()).equals(w)) {\n                    dp[i] = dp[i + w.length()];\n                }\n                if (dp[i]) {\n                    break;\n                }\n            }\n        }\n\n        return dp[0];\n    }\n}\n","csharp":"public class Solution {\n    public bool WordBreak(string s, List<string> wordDict) {\n        bool[] dp = new bool[s.Length + 1];\n        dp[s.Length] = true;\n\n        for (int i = s.Length - 1; i >= 0; i--) {\n            foreach (string w in wordDict) {\n                if ((i + w.Length) <= s.Length && s.Substring(i, w.Length) == w) {\n                    dp[i] = dp[i + w.Length];\n                }\n                if (dp[i]) {\n                    break;\n                }\n            }\n        }\n\n        return dp[0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string[]} wordDict\n     * @return {boolean}\n     */\n    wordBreak(s, wordDict) {}\n}\n","cpp":"class Solution {\npublic:\n    bool wordBreak(string s, vector<string>& wordDict) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean wordBreak(String s, List<String> wordDict) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool WordBreak(string s, List<string> wordDict) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Sx9NNgInc3A"},{"id":"longest-increasing-subsequence","name":"Longest Increasing Subsequence","description":"Given an integer array `nums`, return the *length* of the longest strictly *increasing* subsequence.\n\nA **subsequence** is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\n* For example, `\"cat\"` is a subsequence of `\"crabt\"`.\n\n**Example 1:**\n\n```java\nInput: nums = [9,1,4,2,3,3,7]\n\nOutput: 4\n```\n\nExplanation: The longest increasing subsequence is [1,2,3,7], which has a length of 4.\n\n**Example 2:**\n\n```java\nInput: nums = [0,3,1,3,2,3]\n\nOutput: 4\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP"],"solutions":{"python":"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        LIS = [1] * len(nums)\n\n        for i in range(len(nums) - 1, -1, -1):\n            for j in range(i + 1, len(nums)):\n                if nums[i] < nums[j]:\n                    LIS[i] = max(LIS[i], 1 + LIS[j])\n        return max(LIS)\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    lengthOfLIS(nums) {\n        const LIS = new Array(nums.length).fill(1);\n\n        for (let i = nums.length - 1; i >= 0; i--) {\n            for (let j = i + 1; j < nums.length; j++) {\n                if (nums[i] < nums[j]) {\n                    LIS[i] = Math.max(LIS[i], 1 + LIS[j]);\n                }\n            }\n        }\n        return Math.max(...LIS);\n    }\n}\n","cpp":"class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        vector<int> LIS(nums.size(), 1);\n\n        for (int i = nums.size() - 1; i >= 0; i--) {\n            for (int j = i + 1; j < nums.size(); j++) {\n                if (nums[i] < nums[j]) {\n                    LIS[i] = max(LIS[i], 1 + LIS[j]);\n                }\n            }\n        }\n        return *max_element(LIS.begin(), LIS.end());\n    }\n};\n","java":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int[] LIS = new int[nums.length];\n        Arrays.fill(LIS, 1);\n\n        for (int i = nums.length - 1; i >= 0; i--) {\n            for (int j = i + 1; j < nums.length; j++) {\n                if (nums[i] < nums[j]) {\n                    LIS[i] = Math.max(LIS[i], 1 + LIS[j]);\n                }\n            }\n        }\n        return Arrays.stream(LIS).max().getAsInt();\n    }\n}\n","csharp":"public class Solution {\n    public int LengthOfLIS(int[] nums) {\n        int[] LIS = new int[nums.Length];\n        for (int i = 0; i < LIS.Length; i++) LIS[i] = 1;\n\n        for (int i = nums.Length - 1; i >= 0; i--) {\n            for (int j = i + 1; j < nums.Length; j++) {\n                if (nums[i] < nums[j]) {\n                    LIS[i] = Math.Max(LIS[i], 1 + LIS[j]);\n                }\n            }\n        }\n        return LIS.Max();\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    lengthOfLIS(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int lengthOfLIS(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int lengthOfLIS(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LengthOfLIS(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/cjWnW0hdF1Y"},{"id":"longest-common-subsequence","name":"Longest Common Subsequence","description":"Given two strings `text1` and `text2`, return the length of the *longest common subsequence* between the two strings if one exists, otherwise return `0`.\n\nA **subsequence** is a sequence that can be derived from the given sequence by deleting some or no elements  without changing the relative order of the remaining characters.\n\n* For example, `\"cat\"` is a subsequence of `\"crabt\"`.\n\nA **common subsequence** of two strings is a subsequence that exists in both strings.\n\n**Example 1:**\n\n```java\nInput: text1 = \"cat\", text2 = \"crabt\" \n\nOutput: 3 \n```\n\nExplanation: The longest common subsequence is \"cat\" which has a length of 3.\n\n**Example 2:**\n\n```java\nInput: text1 = \"abcd\", text2 = \"abcd\"\n\nOutput: 4\n```\n\n**Example 3:**\n\n```java\nInput: text1 = \"abcd\", text2 = \"efgh\"\n\nOutput: 0\n```\n\n**Constraints:**\n* `1 <= text1.length, text2.length <= 1000`\n* `text1` and `text2` consist of only lowercase English characters.\n","difficulty":"Medium","concepts":["Tree Maze","2-Dimension DP","LCS"],"solutions":{"python":"class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        dp = [[0 for j in range(len(text2) + 1)] for i in range(len(text1) + 1)]\n\n        for i in range(len(text1) - 1, -1, -1):\n            for j in range(len(text2) - 1, -1, -1):\n                if text1[i] == text2[j]:\n                    dp[i][j] = 1 + dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = max(dp[i][j + 1], dp[i + 1][j])\n\n        return dp[0][0]\n","javascript":"class Solution {\n    /**\n     * @param {string} text1\n     * @param {string} text2\n     * @return {number}\n     */\n    longestCommonSubsequence(text1, text2) {\n        const dp = Array(text1.length + 1)\n            .fill()\n            .map(() => Array(text2.length + 1).fill(0));\n\n        for (let i = text1.length - 1; i >= 0; i--) {\n            for (let j = text2.length - 1; j >= 0; j--) {\n                if (text1[i] === text2[j]) {\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n                }\n            }\n        }\n\n        return dp[0][0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<vector<int>> dp(text1.size() + 1, vector<int>(text2.size() + 1));\n\n        for (int i = text1.size() - 1; i >= 0; i--) {\n            for (int j = text2.size() - 1; j >= 0; j--) {\n                if (text1[i] == text2[j]) {\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\n                } else {\n                    dp[i][j] = max(dp[i][j + 1], dp[i + 1][j]);\n                }\n            }\n        }\n\n        return dp[0][0];\n    }\n};\n","java":"class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int[][] dp = new int[text1.length() + 1][text2.length() + 1];\n\n        for (int i = text1.length() - 1; i >= 0; i--) {\n            for (int j = text2.length() - 1; j >= 0; j--) {\n                if (text1.charAt(i) == text2.charAt(j)) {\n                    dp[i][j] = 1 + dp[i + 1][j + 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n                }\n            }\n        }\n\n        return dp[0][0];\n    }\n}\n","csharp":"public class Solution {\n    public int LongestCommonSubsequence(string text1, string text2) {\n        int[,] dp = new int[text1.Length + 1, text2.Length + 1];\n\n        for (int i = text1.Length - 1; i >= 0; i--) {\n            for (int j = text2.Length - 1; j >= 0; j--) {\n                if (text1[i] == text2[j]) {\n                    dp[i, j] = 1 + dp[i + 1, j + 1];\n                } else {\n                    dp[i, j] = Math.Max(dp[i, j + 1], dp[i + 1, j]);\n                }\n            }\n        }\n\n        return dp[0, 0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} text1\n     * @param {string} text2\n     * @return {number}\n     */\n    longestCommonSubsequence(text1, text2) {}\n}\n","cpp":"class Solution {\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        \n    }\n};\n","java":"class Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LongestCommonSubsequence(string text1, string text2) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Ua0GhsJSlWM"},{"id":"counting-bits","name":"Counting Bits","description":"Given an integer `n`, count the number of `1`'s in the binary representation of every number in the range `[0, n]`.\n    \nReturn an array `output` where `output[i]` is the number of `1`'s in the binary representation of `i`.\n\n**Example 1:**\n\n```java\nInput: n = 4\n\nOutput: [0,1,1,2,1]\n```\n\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n\n**Constraints:**\n* `0 <= n <= 1000`\n","difficulty":"Easy","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def countBits(self, n: int) -> List[int]:\n        dp = [0] * (n + 1)\n        offset = 1\n\n        for i in range(1, n + 1):\n            if offset * 2 == i:\n                offset = i\n            dp[i] = 1 + dp[i - offset]\n        return dp\n","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {number[]}\n     */\n    countBits(n) {\n        const dp = new Array(n + 1).fill(0);\n        let offset = 1;\n\n        for (let i = 1; i <= n; i++) {\n            if (offset * 2 == i) {\n                offset = i;\n            }\n            dp[i] = 1 + dp[i - offset];\n        }\n        return dp;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> countBits(int n) {\n        vector<int> dp(n + 1);\n        int offset = 1;\n\n        for (int i = 1; i <= n; i++) {\n            if (offset * 2 == i) {\n                offset = i;\n            }\n            dp[i] = 1 + dp[i - offset];\n        }\n        return dp;\n    }\n};\n","java":"class Solution {\n    public int[] countBits(int n) {\n        int[] dp = new int[n + 1];\n        int offset = 1;\n\n        for (int i = 1; i <= n; i++) {\n            if (offset * 2 == i) {\n                offset = i;\n            }\n            dp[i] = 1 + dp[i - offset];\n        }\n        return dp;\n    }\n}\n","csharp":"public class Solution {\n    public int[] CountBits(int n) {\n        int[] dp = new int[n + 1];\n        int offset = 1;\n\n        for (int i = 1; i <= n; i++) {\n            if (offset * 2 == i) {\n                offset = i;\n            }\n            dp[i] = 1 + dp[i - offset];\n        }\n        return dp;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def countBits(self, n: int) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {number[]}\n     */\n    countBits(n) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> countBits(int n) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] countBits(int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] CountBits(int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/RyBM56RIWrM"},{"id":"reverse-bits","name":"Reverse Bits","description":"Given a 32-bit unsigned integer `n`, reverse the bits of the binary representation of `n` and return the result.\n\n**Example 1:**\n\n```java\nInput: n = 00000000000000000000000000010101\n\nOutput:    2818572288 (10101000000000000000000000000000)\n```\n\nExplanation: Reversing `00000000000000000000000000010101`, which represents the unsigned integer `21`, gives us `10101000000000000000000000000000` which represents the unsigned integer `2818572288`.\n","difficulty":"Easy","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        res = 0\n        for i in range(32):\n            bit = (n >> i) & 1\n            res += (bit << (31 - i))\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number} n - a positive integer\n     * @return {number} - a positive integer\n     */\n    reverseBits(n) {\n        let res = 0;\n        for (let i = 0; i < 32; i++) {\n            const bit = (n >>> i) & 1;\n            res += bit << (31 - i);\n        }\n        return res >>> 0;\n    }\n}\n","cpp":"class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        uint32_t res = 0;\n        for (int i = 0; i < 32; i++) {\n            uint32_t bit = (n >> i) & 1;\n            res += (bit << (31 - i));\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int reverseBits(int n) {\n        int res = 0;\n        for (int i = 0; i < 32; i++) {\n            int bit = (n >> i) & 1;\n            res += (bit << (31 - i));\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public uint ReverseBits(uint n) {\n        uint res = 0;\n        for (int i = 0; i < 32; i++) {\n            uint bit = (n >> i) & 1;\n            res += (bit << (31 - i));\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def reverseBits(self, n: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n - a positive integer\n     * @return {number} - a positive integer\n     */\n    reverseBits(n) {}\n}\n","cpp":"class Solution {\npublic:\n    uint32_t reverseBits(uint32_t n) {\n        \n    }\n};\n","java":"class Solution {\n    public int reverseBits(int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public uint ReverseBits(uint n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/UcoN6UjAI64"},{"id":"missing-number","name":"Missing Number","description":"Given an array `nums` containing `n` integers in the range `[0, n]` without any duplicates, return the single number in the range that is missing from `nums`.\n\n**Follow-up**: Could you implement a solution using only `O(1)` extra space complexity and `O(n)` runtime complexity?\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3]\n\nOutput: 0\n```\n\nExplanation: Since there are 3 numbers, the range is [0,3]. The missing number is 0 since it does not appear in nums.\n\n**Example 2:**\n\n```java\nInput: nums = [0,2]\n\nOutput: 1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n","difficulty":"Easy","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        res = len(nums)\n\n        for i in range(len(nums)):\n            res += i - nums[i]\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    missingNumber(nums) {\n        let res = nums.length;\n\n        for (let i = 0; i < nums.length; i++) {\n            res += i - nums[i];\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        int res = nums.size();\n\n        for (int i = 0; i < nums.size(); i++) {\n            res += i - nums[i];\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int missingNumber(int[] nums) {\n        int res = nums.length;\n\n        for (int i = 0; i < nums.length; i++) {\n            res += i - nums[i];\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int MissingNumber(int[] nums) {\n        int res = nums.Length;\n\n        for (int i = 0; i < nums.Length; i++) {\n            res += i - nums[i];\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def missingNumber(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    missingNumber(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int missingNumber(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int missingNumber(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MissingNumber(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/WnPLSRLSANE"},{"id":"sum-of-two-integers","name":"Sum of Two Integers","description":"Given two integers `a` and `b`, return the sum of the two integers without using the `+` and `-` operators.\n\n**Example 1:**\n\n```java\nInput: a = 1, b = 1\n\nOutput: 2\n```\n\n**Example 2:**\n\n```java\nInput: a = 4, b = 7\n\nOutput: 11\n```\n\n**Constraints:**\n* `-1000 <= a, b <= 1000`\n","difficulty":"Medium","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        def add(a, b):\n            if not a or not b:\n                return a or b\n            return add(a ^ b, (a & b) << 1)\n\n        if a * b < 0:  \n            if a > 0:\n                return self.getSum(b, a)\n            if add(~a, 1) == b: \n                return 0\n            if add(~a, 1) < b:  \n                return add(~add(add(~a, 1), add(~b, 1)), 1)  \n\n        return add(a, b)  \n","javascript":"class Solution {\n    /**\n     * @param {number} a\n     * @param {number} b\n     * @return {number}\n     */\n    getSum(a, b) {\n        return this.add(a, b);\n    }\n\n    /**\n     * @param {number} a\n     * @param {number} b\n     * @return {number}\n     */\n    add(a, b) {\n        if (a === 0 || b === 0) {\n            return a | b;\n        }\n        return this.add(a ^ b, (a & b) << 1);\n    }\n}\n","cpp":"class Solution {\npublic:\n    int getSum(int a, int b) {\n        return add(a, b);\n    }\n\nprivate:\n    int add(int a, int b) {\n        if (a == 0 || b == 0) {\n            return a | b;\n        }\n        return add(a ^ b, (a & b) << 1);\n    }\n};\n","java":"class Solution {\n    \n    public int getSum(int a, int b) {\n        return add(a, b);\n    }\n\n    private int add(int a, int b) {\n        if (a == 0 || b == 0) {\n            return a | b;\n        }\n        return add(a ^ b, (a & b) << 1);\n    }\n}\n","csharp":"public class Solution {\n    \n    public int GetSum(int a, int b) {\n        return Add(a, b);\n    }\n\n    private int Add(int a, int b) {\n        if (a == 0 || b == 0) {\n            return a | b;\n        }\n        return Add(a ^ b, (a & b) << 1);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def getSum(self, a: int, b: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} a\n     * @param {number} b\n     * @return {number}\n     */\n    getSum(a, b) {}\n}\n","cpp":"class Solution {\npublic:\n    int getSum(int a, int b) {\n        \n    }\n};\n","java":"class Solution {\n    public int getSum(int a, int b) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int GetSum(int a, int b) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/gVUrDV4tZfY"},{"id":"top-k-elements-in-list","name":"Top K Elements in List","description":"Given an integer array `nums` and an integer `k`, return the `k` most frequent elements within the array.\n\nThe test cases are generated such that the answer is always **unique**.\n\nYou may return the output in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,2,3,3,3], k = 2\n\nOutput: [2,3]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7,7], k = 1\n\nOutput: [7]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10^4`.\n* `-1000 <= nums[i] <= 1000`\n* `1 <= k <= number of distinct elements in nums`.\n","difficulty":"Medium","concepts":["Hash Usage","Bucket Sort"],"solutions":{"python":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        count = {}\n        freq = [[] for i in range(len(nums) + 1)]\n\n        for n in nums:\n            count[n] = 1 + count.get(n, 0)\n        for n, c in count.items():\n            freq[c].append(n)\n\n        res = []\n        for i in range(len(freq) - 1, 0, -1):\n            for n in freq[i]:\n                res.append(n)\n                if len(res) == k:\n                    return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} k\n     * @return {number[]}\n     */\n    topKFrequent(nums, k) {\n        const count = {};\n        const freq = Array.from({ length: nums.length + 1 }, () => []);\n\n        for (const n of nums) {\n            count[n] = (count[n] || 0) + 1;\n        }\n        for (const n in count) {\n            freq[count[n]].push(parseInt(n));\n        }\n\n        const res = [];\n        for (let i = freq.length - 1; i > 0; i--) {\n            for (const n of freq[i]) {\n                res.push(n);\n                if (res.length === k) {\n                    return res;\n                }\n            }\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        unordered_map<int, int> count;\n        vector<vector<int>> freq(nums.size() + 1);\n\n        for (int n : nums) {\n            count[n] = 1 + count[n];\n        }\n        for (const auto& entry : count) {\n            freq[entry.second].push_back(entry.first);\n        }\n\n        vector<int> res;\n        for (int i = freq.size() - 1; i > 0; --i) {\n            for (int n : freq[i]) {\n                res.push_back(n);\n                if (res.size() == k) {\n                    return res;\n                }\n            }\n        }\n\n        return res;\n    }\n};\n","java":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        List<Integer>[] freq = new List[nums.length + 1];\n\n        for (int i = 0; i < freq.length; i++) {\n            freq[i] = new ArrayList<>();\n        }\n\n        for (int n : nums) {\n            count.put(n, count.getOrDefault(n, 0) + 1);\n        }\n\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            freq[entry.getValue()].add(entry.getKey());\n        }\n\n        int[] res = new int[k];\n        int index = 0;\n        for (int i = freq.length - 1; i > 0 && index < k; i--) {\n            for (int n : freq[i]) {\n                res[index++] = n;\n                if (index == k) {\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int[] TopKFrequent(int[] nums, int k) {\n        Dictionary<int, int> count = new Dictionary<int, int>();\n        List<int>[] freq = new List<int>[nums.Length + 1];\n\n        for (int i = 0; i < freq.Length; i++) {\n            freq[i] = new List<int>();\n        }\n\n        foreach (int n in nums) {\n            if (count.ContainsKey(n)) {\n                count[n]++;\n            } else {\n                count[n] = 1;\n            }\n        }\n\n        foreach (var entry in count){\n            freq[entry.Value].Add(entry.Key);\n        }\n\n        int[] res = new int[k];\n        int index = 0;\n        for (int i = freq.Length - 1; i > 0 && index < k; i--) {\n            foreach (int n in freq[i]) {\n                res[index++] = n;\n                if (index == k) {\n                    return res;\n                }\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def topKFrequent(self, nums: List[int], k: int) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} k\n     * @return {number[]}\n     */\n    topKFrequent(nums, k) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> topKFrequent(vector<int>& nums, int k) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] TopKFrequent(int[] nums, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/YPTqKIgVk-k"},{"id":"anagram-groups","name":"Anagram Groups","description":"Given an array of strings `strs`, group all *anagrams* together into sublists. You may return the output in **any order**.\n\nAn **anagram** is a string that contains the exact same characters as another string, but the order of the characters can be different.\n\n**Example 1:**\n\n```java\nInput: strs = [\"act\",\"pots\",\"tops\",\"cat\",\"stop\",\"hat\"]\n\nOutput: [[\"hat\"],[\"act\", \"cat\"],[\"stop\", \"pots\", \"tops\"]]\n```\n\n**Example 2:**\n\n```java\nInput: strs = [\"x\"]\n\nOutput: [[\"x\"]]\n```\n\n**Example 3:**\n\n```java\nInput: strs = [\"\"]\n\nOutput: [[\"\"]]\n```\n\n**Constraints:**\n* `1 <= strs.length <= 1000`.\n* `0 <= strs[i].length <= 100`\n* `strs[i]` is made up of lowercase English letters.\n","difficulty":"Medium","concepts":["Hash Usage"],"solutions":{"python":"class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ans = defaultdict(list)\n\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord(\"a\")] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n","javascript":"class Solution {\n    /**\n     * @param {string[]} strs\n     * @return {string[][]}\n     */\n    groupAnagrams(strs) {\n        const ans = {};\n\n        for (const s of strs) {\n            const count = Array(26).fill(0);\n            for (const c of s) {\n                count[c.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n            }\n\n            const key = count.join('#');\n            if (!ans[key]) {\n                ans[key] = [];\n            }\n\n            ans[key].push(s);\n        }\n\n        return Object.values(ans);\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        unordered_map<string, vector<string>> ans;\n\n        for (auto& s : strs) {\n            vector<int> count(26, 0);\n            for (char c : s) {\n                count[c - 'a']++;\n            }\n\n            string key;\n            for (int i : count) {\n                key += \"#\" + to_string(i);\n            }\n\n            ans[key].push_back(s);\n        }\n\n        vector<vector<string>> result;\n        for (auto& pair : ans) {\n            result.push_back(pair.second);\n        }\n\n        return result;\n    }\n};\n","java":"class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> ans = new HashMap<>();\n\n        for (String s : strs) {\n            int[] count = new int[26];\n            for (char c : s.toCharArray()) {\n                count[c - 'a']++;\n            }\n\n            String key = Arrays.toString(count);\n            if (!ans.containsKey(key)) {\n                ans.put(key, new ArrayList<>());\n            }\n\n            ans.get(key).add(s);\n        }\n\n        return new ArrayList<>(ans.values());\n    }\n}\n","csharp":"public class Solution {\n    public List<List<string>> GroupAnagrams(string[] strs) {\n        var ans = new Dictionary<string, List<string>>();\n\n        foreach (var s in strs) {\n            var count = new int[26];\n            foreach (var c in s) {\n                count[c - 'a']++;\n            }\n\n            var key = string.Join(',', count);\n            if (!ans.ContainsKey(key)) {\n                ans[key] = new List<string>();\n            }\n\n            ans[key].Add(s);\n        }\n\n        return new List<List<string>>(ans.Values);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {string[]} strs\n     * @return {string[][]}\n     */\n    groupAnagrams(strs) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<string>> groupAnagrams(vector<string>& strs) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<string>> GroupAnagrams(string[] strs) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/vzdNOK2oB2E"},{"id":"lowest-common-ancestor-in-binary-search-tree","name":"Lowest Common Ancestor in Binary Search Tree","description":"Given a binary search tree (BST) where all node values are *unique*, and two nodes from the tree `p` and `q`, return the lowest common ancestor (LCA) of the two nodes.\n\nThe lowest common ancestor between two nodes `p` and `q` is the lowest node in a tree `T` such that both `p` and `q` as descendants. The ancestor is allowed to be a descendant of itself.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2080ee6a-3d27-4cd5-0db2-07672ead8200/public)\n\n```java\nInput: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 8\n\nOutput: 5\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/2080ee6a-3d27-4cd5-0db2-07672ead8200/public)\n\n```java\nInput: root = [5,3,8,1,4,7,9,null,2], p = 3, q = 4\n\nOutput: 3\n```\n\nExplanation: The LCA of nodes 3 and 4 is 3, since a node can be a descendant of itself.\n\n\n**Constraints:**\n* `2 <= The number of nodes in the tree <= 100`.\n* `-100 <= Node.val <= 100`\n* `p != q`\n* `p` and `q` will both exist in the BST.\n","difficulty":"Medium","concepts":["Binary Tree","Binary Search Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        while True:\n            if root.val < p.val and root.val < q.val:\n                root = root.right\n            elif root.val > p.val and root.val > q.val:\n                root = root.left\n            else:\n                return root\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @param {TreeNode} p\n     * @param {TreeNode} q\n     * @return {TreeNode}\n     */\n    lowestCommonAncestor(root, p, q) {\n        while (true) {\n            if (root.val < p.val && root.val < q.val) {\n                root = root.right;\n            } else if (root.val > p.val && root.val > q.val) {\n                root = root.left;\n            } else {\n                return root;\n            }\n        }\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        while (true) {\n            if (root->val < p->val && root->val < q->val) {\n                root = root->right;\n            } else if (root->val > p->val && root->val > q->val) {\n                root = root->left;\n            } else {\n                return root;\n            }\n        }\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while (true) {\n            if (root.val < p.val && root.val < q.val) {\n                root = root.right;\n            } else if (root.val > p.val && root.val > q.val) {\n                root = root.left;\n            } else {\n                return root;\n            }\n        }\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        while (true) {\n            if (root.val < p.val && root.val < q.val) {\n                root = root.right;\n            } else if (root.val > p.val && root.val > q.val) {\n                root = root.left;\n            } else {\n                return root;\n            }\n        }\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def lowestCommonAncestor(self, root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @param {TreeNode} p\n     * @param {TreeNode} q\n     * @return {TreeNode}\n     */\n    lowestCommonAncestor(root, p, q) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/gs2LMfuOR9k"},{"id":"level-order-traversal-of-binary-tree","name":"Level Order Traversal of Binary Tree","description":"Given a binary tree `root`, return the level order traversal of it as a nested list, where each sublist contains the values of nodes at a particular level in the tree, from left to right.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a4639809-0754-4eda-221f-a4cd58bd9c00/public)\n\n```java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [[1],[2,3],[4,5,6,7]]\n```\n\n**Example 2:**\n\n```java\nInput: root = [1]\n\nOutput: [[1]]\n```\n\n**Example 3:**\n\n```java\nInput: root = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The number of nodes in both trees <= 1000`.\n* `-1000 <= Node.val <= 1000`\n","difficulty":"Medium","concepts":["Breadth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        res = []\n        q = deque()\n        if root:\n            q.append(root)\n\n        while q:\n            val = []\n\n            for i in range(len(q)):\n                node = q.popleft()\n                val.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(val)\n        return res\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number[][]}\n     */\n    levelOrder(root) {\n        const res = [];\n        const q = [];\n        if (root) {\n            q.push(root);\n        }\n\n        while (q.length > 0) {\n            const val = [];\n\n            for (let i = 0, len = q.length; i < len; i++) {\n                const node = q.shift();\n                val.push(node.val);\n                if (node.left) {\n                    q.push(node.left);\n                }\n                if (node.right) {\n                    q.push(node.right);\n                }\n            }\n            res.push(val);\n        }\n        return res;\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        vector<vector<int>> res;\n        deque<TreeNode*> q;\n        if (root) {\n            q.push_back(root);\n        }\n\n        while (!q.empty()) {\n            vector<int> val;\n\n            for (int i = 0, len = q.size(); i < len; i++) {\n                TreeNode* node = q.front();\n                q.pop_front();\n                val.push_back(node->val);\n                if (node->left) {\n                    q.push_back(node->left);\n                }\n                if (node->right) {\n                    q.push_back(node->right);\n                }\n            }\n            res.push_back(val);\n        }\n        return res;\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        Deque<TreeNode> q = new ArrayDeque<>();\n        if (root != null) {\n            q.add(root);\n        }\n\n        while (!q.isEmpty()) {\n            List<Integer> val = new ArrayList<>();\n\n            for (int i = 0, len = q.size(); i < len; i++) {\n                TreeNode node = q.poll();\n                val.add(node.val);\n                if (node.left != null) {\n                    q.add(node.left);\n                }\n                if (node.right != null) {\n                    q.add(node.right);\n                }\n            }\n            res.add(val);\n        }\n        return res;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n \npublic class Solution {\n    public List<List<int>> LevelOrder(TreeNode root) {\n        var res = new List<List<int>>();\n        var q = new Queue<TreeNode>();\n        if (root != null) {\n            q.Enqueue(root);\n        }\n\n        while (q.Count > 0) {\n            var val = new List<int>();\n\n            for (int i = 0, len = q.Count; i < len; i++) {\n                var node = q.Dequeue();\n                val.Add(node.val);\n                if (node.left != null) {\n                    q.Enqueue(node.left);\n                }\n                if (node.right != null) {\n                    q.Enqueue(node.right);\n                }\n            }\n            res.Add(val);\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def levelOrder(self, root: Optional[TreeNode]) -> List[List[int]]:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number[][]}\n     */\n    levelOrder(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<vector<int>> levelOrder(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n \npublic class Solution {\n    public List<List<int>> LevelOrder(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/6ZnyEApgFYg"},{"id":"valid-binary-search-tree","name":"Valid Binary Search Tree","description":"Given the `root` of a binary tree, return `true` if it is a **valid binary search tree**, otherwise return `false`.\n\nA **valid binary search tree** satisfies the following constraints:    \n* The left subtree of every node contains only nodes with keys **less than** the node's key.\n* The right subtree of every node contains only nodes with keys **greater than** the node's key.\n* Both the left and right subtrees are also binary search trees.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/18f9a316-8dc2-4e11-d304-51204454ac00/public)\n\n```java\nInput: root = [2,1,3]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6f14cb8d-efad-4221-2beb-fba2b19c8a00/public)\n\n```java\nInput: root = [1,2,3]\n\nOutput: false\n```\n\nExplanation: The root node's value is 1 but its left child's value is 2 which is greater than 1.\n\n**Constraints:**\n* `1 <= The number of nodes in the tree <= 1000`.\n* `-1000 <= Node.val <= 1000`\n","difficulty":"Medium","concepts":["Binary Tree","Binary Search Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        def valid(node, left, right):\n            if not node:\n                return True\n            if not (left < node.val < right):\n                return False\n\n            return valid(node.left, left, node.val) and valid(\n                node.right, node.val, right\n            )\n\n        return valid(root, float(\"-inf\"), float(\"inf\"))\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {boolean}\n     */\n    isValidBST(root) {\n        return this.valid(root, -Infinity, Infinity);\n    }\n\n    /**\n     * @param {TreeNode} node\n     * @param {number} left\n     * @param {number} right\n     * @return {boolean}\n     */\n    valid(node, left, right) {\n        if (!node) {\n            return true;\n        }\n        if (!(left < node.val && node.val < right)) {\n            return false;\n        }\n\n        return (\n            this.valid(node.left, left, node.val) &&\n            this.valid(node.right, node.val, right)\n        );\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        return valid(root, LONG_MIN, LONG_MAX);\n    }\n\nprivate:\n    bool valid(TreeNode* node, long left, long right) {\n        if (!node) {\n            return true;\n        }\n        if (!(left < node->val && node->val < right)) {\n            return false;\n        }\n\n        return valid(node->left, left, node->val) && valid(node->right, node->val, right);\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public boolean isValidBST(TreeNode root) {\n        return valid(root, Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    private boolean valid(TreeNode node, double left, double right) {\n        if (node == null) {\n            return true;\n        }\n        if (!(left < node.val && node.val < right)) {\n            return false;\n        }\n\n        return valid(node.left, left, node.val) && valid(node.right, node.val, right);\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public bool IsValidBST(TreeNode root) {\n        return Valid(root, double.NegativeInfinity, double.PositiveInfinity);\n    }\n\n    private bool Valid(TreeNode node, double left, double right) {\n        if (node == null) {\n            return true;\n        }\n        if (!(left < node.val && node.val < right)) {\n            return false;\n        }\n\n        return Valid(node.left, left, node.val) && Valid(node.right, node.val, right);\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isValidBST(self, root: Optional[TreeNode]) -> bool:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {boolean}\n     */\n    isValidBST(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isValidBST(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public boolean isValidBST(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public bool IsValidBST(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/s6ATEkipzow"},{"id":"kth-smallest-integer-in-bst","name":"Kth Smallest Integer in BST","description":"Given the `root` of a binary search tree, and an integer `k`, return the `kth` smallest value (**1-indexed**) in the tree.\n\nA **binary search tree** satisfies the following constraints:    \n* The left subtree of every node contains only nodes with keys **less than** the node's key.\n* The right subtree of every node contains only nodes with keys **greater than** the node's key.\n* Both the left and right subtrees are also binary search trees.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/02eca3db-f72f-4277-7134-faec4f02e500/public)\n\n```java\nInput: root = [2,1,3], k = 1\n\nOutput: 1\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/dca6c42d-2327-4036-f7f2-3e99d8203100/public)\n\n```java\nInput: root = [4,3,5,2,null], k = 4\n\nOutput: 5\n```\n\n**Constraints:**\n* `1 <= k <= The number of nodes in the tree <= 1000`.\n* `0 <= Node.val <= 1000`\n","difficulty":"Medium","concepts":["Binary Tree","Binary Search Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        stack = []\n        curr = root\n\n        while stack or curr:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            k -= 1\n            if k == 0:\n                return curr.val\n            curr = curr.right\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @param {number} k\n     * @return {number}\n     */\n    kthSmallest(root, k) {\n        let stack = [];\n        let curr = root;\n\n        while (stack.length > 0 || curr !== null) {\n            while (curr !== null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            k--;\n            if (k === 0) {\n                return curr.val;\n            }\n            curr = curr.right;\n        }\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        stack<TreeNode*> stack;\n        TreeNode* curr = root;\n\n        while (!stack.empty() || curr != nullptr) {\n            while (curr != nullptr) {\n                stack.push(curr);\n                curr = curr->left;\n            }\n            curr = stack.top();\n            stack.pop();\n            k--;\n            if (k == 0) {\n                return curr->val;\n            }\n            curr = curr->right;\n        }\n\n        return -1; \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> stack = new Stack<>();\n        TreeNode curr = root;\n\n        while (!stack.isEmpty() || curr != null) {\n            while (curr != null) {\n                stack.push(curr);\n                curr = curr.left;\n            }\n            curr = stack.pop();\n            k--;\n            if (k == 0) {\n                return curr.val;\n            }\n            curr = curr.right;\n        }\n\n        return -1;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        Stack<TreeNode> stack = new Stack<TreeNode>();\n        TreeNode curr = root;\n\n        while (stack.Count > 0 || curr != null) {\n            while (curr != null) {\n                stack.Push(curr);\n                curr = curr.left;\n            }\n            curr = stack.Pop();\n            k--;\n            if (k == 0) {\n                return curr.val;\n            }\n            curr = curr.right;\n        }\n\n        return -1;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @param {number} k\n     * @return {number}\n     */\n    kthSmallest(root, k) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int kthSmallest(TreeNode* root, int k) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int KthSmallest(TreeNode root, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/5LUXSvjmGCw"},{"id":"binary-tree-from-preorder-and-inorder-traversal","name":"Binary Tree from Preorder and Inorder Traversal","description":"You are given two integer arrays `preorder` and `inorder`.\n        \n* `preorder` is the preorder traversal of a binary tree\n* `inorder` is the inorder traversal of the same tree\n* Both arrays are of the same size and consist of unique values.\n\nRebuild the binary tree from the preorder and inorder traversals and return its root.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/938c14d3-6669-47ab-924b-a1a08640f200/public)\n\n```java\nInput: preorder = [1,2,3,4], inorder = [2,1,3,4]\n\nOutput: [1,2,3,null,null,null,4]\n```\n\n**Example 2:**\n\n```java\nInput: preorder = [1], inorder = [1]\n\nOutput: [1]\n```\n\n**Constraints:**\n* `1 <= inorder.length <= 1000`.\n* `inorder.length == preorder.length`\n* `-1000 <= preorder[i], inorder[i] <= 1000`\n","difficulty":"Medium","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        if not preorder or not inorder:\n            return None\n\n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1 : mid + 1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid + 1 :], inorder[mid + 1 :])\n        return root\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {number[]} preorder\n     * @param {number[]} inorder\n     * @return {TreeNode}\n     */\n    buildTree(preorder, inorder) {\n        if (!preorder.length || !inorder.length) {\n            return null;\n        }\n\n        let root = new TreeNode(preorder[0]);\n        let mid = inorder.indexOf(preorder[0]);\n        root.left = this.buildTree(\n            preorder.slice(1, mid + 1),\n            inorder.slice(0, mid),\n        );\n        root.right = this.buildTree(\n            preorder.slice(mid + 1),\n            inorder.slice(mid + 1),\n        );\n        return root;\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        if (preorder.empty() || inorder.empty()) {\n            return nullptr;\n        }\n\n        TreeNode* root = new TreeNode(preorder[0]);\n        auto mid = find(inorder.begin(), inorder.end(), preorder[0]) - inorder.begin();\n        vector<int> leftPre(preorder.begin() + 1, preorder.begin() + mid + 1);\n        vector<int> rightPre(preorder.begin() + mid + 1, preorder.end());\n        vector<int> leftIn(inorder.begin(), inorder.begin() + mid);\n        vector<int> rightIn(inorder.begin() + mid + 1, inorder.end());\n        root->left = buildTree(leftPre, leftIn);\n        root->right = buildTree(rightPre, rightIn);\n        return root;\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        if (preorder.length == 0 || inorder.length == 0) {\n            return null;\n        }\n\n        TreeNode root = new TreeNode(preorder[0]);\n        int mid = -1;\n        for (int i = 0; i < inorder.length; i++) {\n            if (inorder[i] == preorder[0]) {\n                mid = i;\n                break;\n            }\n        }\n\n        int[] leftPreorder = Arrays.copyOfRange(preorder, 1, mid + 1);\n        int[] leftInorder = Arrays.copyOfRange(inorder, 0, mid);\n        root.left = buildTree(leftPreorder, leftInorder);\n\n        int[] rightPreorder = Arrays.copyOfRange(preorder, mid + 1, preorder.length);\n        int[] rightInorder = Arrays.copyOfRange(inorder, mid + 1, inorder.length);\n        root.right = buildTree(rightPreorder, rightInorder);\n\n        return root;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\n        if (preorder.Length == 0 || inorder.Length == 0) {\n            return null;\n        }\n\n        TreeNode root = new TreeNode(preorder[0]);\n        int mid = Array.IndexOf(inorder, preorder[0]);\n        root.left = BuildTree(preorder.Skip(1).Take(mid).ToArray(), inorder.Take(mid).ToArray());\n        root.right = BuildTree(preorder.Skip(mid + 1).ToArray(), inorder.Skip(mid + 1).ToArray());\n        return root;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def buildTree(self, preorder: List[int], inorder: List[int]) -> Optional[TreeNode]:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {number[]} preorder\n     * @param {number[]} inorder\n     * @return {TreeNode}\n     */\n    buildTree(preorder, inorder) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public TreeNode BuildTree(int[] preorder, int[] inorder) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/ihj4IQGZ2zc"},{"id":"binary-tree-maximum-path-sum","name":"Binary Tree Maximum Path Sum","description":"Given the `root` of a *non-empty* binary tree, return the maximum **path sum** of any *non-empty* path.\n\nA **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes has an edge connecting them. A node can *not* appear in the sequence more than once. The path does *not* necessarily need to include the root.\n\nThe **path sum** of a path is the sum of the node's values in the path.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9896b041-9021-44c2-ab3e-5cff76adf100/public)\n\n```java\nInput: root = [1,2,3]\n\nOutput: 6\n```\n\nExplanation: The path is 2 -> 1 -> 3 with a sum of 2 + 1 + 3 = 6.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/19ce1187-387e-4323-f2c9-1a317ab36200/public)\n\n```java\nInput: root = [-15,10,20,null,null,15,5,-5]\n\nOutput: 40\n```\n\nExplanation: The path is 15 -> 20 -> 5 with a sum of 15 + 20 + 5 = 40.\n\n**Constraints:**\n* `1 <= The number of nodes in the tree <= 1000`.\n* `-1000 <= Node.val <= 1000`\n","difficulty":"Hard","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        res = [root.val]\n\n        def dfs(root):\n            if not root:\n                return 0\n\n            leftMax = dfs(root.left)\n            rightMax = dfs(root.right)\n            leftMax = max(leftMax, 0)\n            rightMax = max(rightMax, 0)\n\n            res[0] = max(res[0], root.val + leftMax + rightMax)\n            return root.val + max(leftMax, rightMax)\n\n        dfs(root)\n        return res[0]\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    maxPathSum(root) {\n        const res = [root.val];\n        this.dfs(root, res);\n        return res[0];\n    }\n\n    /**\n     * @param {TreeNode} root\n     * @param {number[]} res\n     * @return {number}\n     */\n    dfs(root, res) {\n        if (root === null) {\n            return 0;\n        }\n\n        const leftMax = Math.max(this.dfs(root.left, res), 0);\n        const rightMax = Math.max(this.dfs(root.right, res), 0);\n\n        res[0] = Math.max(res[0], root.val + leftMax + rightMax);\n        return root.val + Math.max(leftMax, rightMax);\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n        int res = root->val;\n        dfs(root, res);\n        return res;\n    }\n\nprivate:\n    int dfs(TreeNode* root, int& res) {\n        if (!root) {\n            return 0;\n        }\n\n        int leftMax = max(dfs(root->left, res), 0);\n        int rightMax = max(dfs(root->right, res), 0);\n\n        res = max(res, root->val + leftMax + rightMax);\n        return root->val + max(leftMax, rightMax);\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n\n    public int maxPathSum(TreeNode root) {\n        int[] res = new int[]{root.val};\n        dfs(root, res);\n        return res[0];\n    }\n\n    private int dfs(TreeNode root, int[] res) {\n        if (root == null) {\n            return 0;\n        }\n\n        int leftMax = Math.max(dfs(root.left, res), 0);\n        int rightMax = Math.max(dfs(root.right, res), 0);\n\n        res[0] = Math.max(res[0], root.val + leftMax + rightMax);\n        return root.val + Math.max(leftMax, rightMax);\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n\n    public int MaxPathSum(TreeNode root) {\n        int res = root.val;\n        Dfs(root, ref res);\n        return res;\n    }\n\n    private int Dfs(TreeNode root, ref int res) {\n        if (root == null) {\n            return 0;\n        }\n\n        int leftMax = Math.Max(Dfs(root.left, ref res), 0);\n        int rightMax = Math.Max(Dfs(root.right, ref res), 0);\n\n        res = Math.Max(res, root.val + leftMax + rightMax);\n        return root.val + Math.Max(leftMax, rightMax);\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def maxPathSum(self, root: Optional[TreeNode]) -> int:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    maxPathSum(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int maxPathSum(TreeNode* root) {\n\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int maxPathSum(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int MaxPathSum(TreeNode root) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Hr5cWUld4vU"},{"id":"serialize-and-deserialize-binary-tree","name":"Serialize and Deserialize Binary Tree","description":"Implement an algorithm to serialize and deserialize a binary tree.\n\nSerialization is the process of converting an in-memory structure into a sequence of bits so that it can be stored or sent across a network to be reconstructed later in another computer environment.\n\nYou just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure. There is no additional restriction on how your serialization/deserialization algorithm should work.\n\n**Note:** The input/output format in the examples is the same as how NeetCode serializes a binary tree. You do not necessarily need to follow this format.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/a9dfb17f-70e9-42a3-ba97-33cfd82f6100/public)\n\n```java\nInput: root = [1,2,3,null,null,4,5]\n\nOutput: [1,2,3,null,null,4,5]\n```\n\n**Example 2:**\n\n```java\nInput: root = []\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= The number of nodes in the tree <= 1000`.\n* `-1000 <= Node.val <= 1000`\n","difficulty":"Hard","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    \n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -> str:\n        res = []\n\n        def dfs(node):\n            if not node:\n                res.append(\"N\")\n                return\n            res.append(str(node.val))\n            dfs(node.left)\n            dfs(node.right)\n\n        dfs(root)\n        return \",\".join(res)\n        \n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n        vals = data.split(\",\")\n        self.i = 0\n\n        def dfs():\n            if vals[self.i] == \"N\":\n                self.i += 1\n                return None\n            node = TreeNode(int(vals[self.i]))\n            self.i += 1\n            node.left = dfs()\n            node.right = dfs()\n            return node\n\n        return dfs()\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Codec {\n    /**\n     * Encodes a tree to a single string.\n     *\n     * @param {TreeNode} root\n     * @return {string}\n     */\n    serialize(root) {\n        const res = [];\n        this.dfsSerialize(root, res);\n        return res.join(',');\n    }\n\n    dfsSerialize(node, res) {\n        if (node === null) {\n            res.push('N');\n            return;\n        }\n        res.push(node.val.toString());\n        this.dfsSerialize(node.left, res);\n        this.dfsSerialize(node.right, res);\n    }\n\n    /**\n     * Decodes your encoded data to tree.\n     *\n     * @param {string} data\n     * @return {TreeNode}\n     */\n    deserialize(data) {\n        const vals = data.split(',');\n        const i = { val: 0 };\n        return this.dfsDeserialize(vals, i);\n    }\n\n    dfsDeserialize(vals, i) {\n        if (vals[i.val] === 'N') {\n            i.val++;\n            return null;\n        }\n        const node = new TreeNode(parseInt(vals[i.val]));\n        i.val++;\n        node.left = this.dfsDeserialize(vals, i);\n        node.right = this.dfsDeserialize(vals, i);\n        return node;\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Codec {\npublic:\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        vector<string> res;\n        dfsSerialize(root, res);\n        return join(res, \",\");\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        vector<string> vals = split(data, ',');\n        int i = 0;\n        return dfsDeserialize(vals, i);\n    }\n\nprivate:\n    void dfsSerialize(TreeNode* node, vector<string>& res) {\n        if (!node) {\n            res.push_back(\"N\");\n            return;\n        }\n        res.push_back(to_string(node->val));\n        dfsSerialize(node->left, res);\n        dfsSerialize(node->right, res);\n    }\n\n    TreeNode* dfsDeserialize(vector<string>& vals, int& i) {\n        if (vals[i] == \"N\") {\n            i++;\n            return NULL;\n        }\n        TreeNode* node = new TreeNode(stoi(vals[i]));\n        i++;\n        node->left = dfsDeserialize(vals, i);\n        node->right = dfsDeserialize(vals, i);\n        return node;\n    }\n\n    vector<string> split(const string &s, char delim) {\n        vector<string> elems;\n        stringstream ss(s);\n        string item;\n        while (getline(ss, item, delim)) {\n            elems.push_back(item);\n        }\n        return elems;\n    }\n\n    string join(const vector<string> &v, const string &delim) {\n        ostringstream s;\n        for (const auto &i : v) {\n            if (&i != &v[0])\n                s << delim;\n            s << i;\n        }\n        return s.str();\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Codec {\n    \n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        List<String> res = new ArrayList<>();\n        dfsSerialize(root, res);\n        return String.join(\",\", res);\n    }\n\n    private void dfsSerialize(TreeNode node, List<String> res) {\n        if (node == null) {\n            res.add(\"N\");\n            return;\n        }\n        res.add(String.valueOf(node.val));\n        dfsSerialize(node.left, res);\n        dfsSerialize(node.right, res);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        String[] vals = data.split(\",\");\n        int[] i = {0};\n        return dfsDeserialize(vals, i);\n    }\n\n    private TreeNode dfsDeserialize(String[] vals, int[] i) {\n        if (vals[i[0]].equals(\"N\")) {\n            i[0]++;\n            return null;\n        }\n        TreeNode node = new TreeNode(Integer.parseInt(vals[i[0]]));\n        i[0]++;\n        node.left = dfsDeserialize(vals, i);\n        node.right = dfsDeserialize(vals, i);\n        return node;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Codec {\n    \n    // Encodes a tree to a single string.\n    public string Serialize(TreeNode root) {\n        List<string> res = new List<string>();\n        dfsSerialize(root, res);\n        return String.Join(\",\", res);\n    }\n\n    private void dfsSerialize(TreeNode node, List<string> res) {\n        if (node == null) {\n            res.Add(\"N\");\n            return;\n        }\n        res.Add(node.val.ToString());\n        dfsSerialize(node.left, res);\n        dfsSerialize(node.right, res);\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode Deserialize(string data) {\n        string[] vals = data.Split(',');\n        int i = 0;\n        return dfsDeserialize(vals, ref i);\n    }\n\n    private TreeNode dfsDeserialize(string[] vals, ref int i) {\n        if (vals[i] == \"N\") {\n            i++;\n            return null;\n        }\n        TreeNode node = new TreeNode(Int32.Parse(vals[i]));\n        i++;\n        node.left = dfsDeserialize(vals, ref i);\n        node.right = dfsDeserialize(vals, ref i);\n        return node;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Codec:\n    \n    # Encodes a tree to a single string.\n    def serialize(self, root: Optional[TreeNode]) -> str:\n\n        \n    # Decodes your encoded data to tree.\n    def deserialize(self, data: str) -> Optional[TreeNode]:\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Codec {\n    /**\n     * Encodes a tree to a single string.\n     *\n     * @param {TreeNode} root\n     * @return {string}\n     */\n    serialize(root) {}\n\n    /**\n     * Decodes your encoded data to tree.\n     *\n     * @param {string} data\n     * @return {TreeNode}\n     */\n    deserialize(data) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Codec {\npublic:\n\n    // Encodes a tree to a single string.\n    string serialize(TreeNode* root) {\n        \n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(string data) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Codec {\n\n    // Encodes a tree to a single string.\n    public string Serialize(TreeNode root) {\n        \n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode Deserialize(string data) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/u4JAi2JJhI8"},{"id":"valid-sudoku","name":"Valid Sudoku","description":"You are given a a `9 x 9` Sudoku board `board`. A Sudoku board is valid if the following rules are followed:\n\n1. Each row must contain the digits `1-9` without duplicates.\n2. Each column must contain the digits `1-9` without duplicates.\n3. Each of the nine `3 x 3` sub-boxes of the grid must contain the digits `1-9` without duplicates.\n\nReturn `true` if the Sudoku board is valid, otherwise return `false`\n\nNote: A board does not need to be full or be solvable to be valid.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0be40c5d-2d18-42b8-261b-13ca50de4100/public)\n\n```java\nInput: board = \n[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],\n [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\".\",\"3\"],\n [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],\n [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: true\n```\n\n**Example 2:**\n\n```java\nInput: board = \n[[\"1\",\"2\",\".\",\".\",\"3\",\".\",\".\",\".\",\".\"],\n [\"4\",\".\",\".\",\"5\",\".\",\".\",\".\",\".\",\".\"],\n [\".\",\"9\",\"1\",\".\",\".\",\".\",\".\",\".\",\"3\"],\n [\"5\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"4\"],\n [\".\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"5\"],\n [\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],\n [\".\",\".\",\".\",\".\",\".\",\".\",\"2\",\".\",\".\"],\n [\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"8\"],\n [\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\n\nOutput: false\n```\n\nExplanation: There are two 1's in the top-left 3x3 sub-box.\n\n**Constraints:**\n* `board.length == 9`\n* `board[i].length == 9`\n* `board[i][j]` is a digit `1-9` or `'.'`.\n","difficulty":"Medium","concepts":["Hash Usage"],"solutions":{"python":"class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        cols = defaultdict(set)\n        rows = defaultdict(set)\n        squares = defaultdict(set)  # key = (r /3, c /3)\n\n        for r in range(9):\n            for c in range(9):\n                if board[r][c] == \".\":\n                    continue\n                if (\n                    board[r][c] in rows[r]\n                    or board[r][c] in cols[c]\n                    or board[r][c] in squares[(r // 3, c // 3)]\n                ):\n                    return False\n                cols[c].add(board[r][c])\n                rows[r].add(board[r][c])\n                squares[(r // 3, c // 3)].add(board[r][c])\n\n        return True\n","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @return {boolean}\n     */\n    isValidSudoku(board) {\n        const cols = new Map();\n        const rows = new Map();\n        const squares = new Map(); // key = (r / 3) * 3 + c / 3\n\n        for (let r = 0; r < 9; r++) {\n            for (let c = 0; c < 9; c++) {\n                const cell = board[r][c];\n                if (cell === '.') {\n                    continue;\n                }\n                if (\n                    rows.get(r)?.has(cell) ||\n                    cols.get(c)?.has(cell) ||\n                    squares\n                        .get(Math.floor(r / 3) * 3 + Math.floor(c / 3))\n                        ?.has(cell)\n                ) {\n                    return false;\n                }\n                cols.set(c, new Set(cols.get(c)).add(cell));\n                rows.set(r, new Set(rows.get(r)).add(cell));\n                squares.set(\n                    Math.floor(r / 3) * 3 + Math.floor(c / 3),\n                    new Set(\n                        squares.get(Math.floor(r / 3) * 3 + Math.floor(c / 3)),\n                    ).add(cell),\n                );\n            }\n        }\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        unordered_map<int, unordered_set<char>> cols;\n        unordered_map<int, unordered_set<char>> rows;\n        unordered_map<int, unordered_set<char>> squares;  // key = (r / 3) * 3 + c / 3\n\n        for (int r = 0; r < 9; r++) {\n            for (int c = 0; c < 9; c++) {\n                char cell = board[r][c];\n                if (cell == '.') {\n                    continue;\n                }\n                if (rows[r].count(cell) || cols[c].count(cell) || squares[(r / 3) * 3 + c / 3].count(cell)) {\n                    return false;\n                }\n                cols[c].insert(cell);\n                rows[r].insert(cell);\n                squares[(r / 3) * 3 + c / 3].insert(cell);\n            }\n        }\n        return true;\n    }\n};\n","java":"class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        Map<Integer, Set<Character>> cols = new HashMap<>();\n        Map<Integer, Set<Character>> rows = new HashMap<>();\n        Map<Integer, Set<Character>> squares = new HashMap<>();  // key = (r / 3) * 3 + c / 3\n\n        for (int r = 0; r < 9; r++) {\n            for (int c = 0; c < 9; c++) {\n                char cell = board[r][c];\n                if (cell == '.') {\n                    continue;\n                }\n                if (rows.getOrDefault(r, new HashSet<>()).contains(cell)\n                        || cols.getOrDefault(c, new HashSet<>()).contains(cell)\n                        || squares.getOrDefault((r / 3) * 3 + c / 3, new HashSet<>()).contains(cell)) {\n                    return false;\n                }\n                cols.computeIfAbsent(c, k -> new HashSet<>()).add(cell);\n                rows.computeIfAbsent(r, k -> new HashSet<>()).add(cell);\n                squares.computeIfAbsent((r / 3) * 3 + c / 3, k -> new HashSet<>()).add(cell);\n            }\n        }\n        return true;\n    }\n}\n","csharp":"public class Solution {\n    public bool IsValidSudoku(char[][] board) {\n        Dictionary<int, HashSet<char>> cols = new Dictionary<int, HashSet<char>>();\n        Dictionary<int, HashSet<char>> rows = new Dictionary<int, HashSet<char>>();\n        Dictionary<int, HashSet<char>> squares = new Dictionary<int, HashSet<char>>();  // key = (r / 3) * 3 + c / 3\n\n        for (int r = 0; r < 9; r++) {\n            for (int c = 0; c < 9; c++) {\n                char cell = board[r][c];\n                if (cell == '.') {\n                    continue;\n                }\n                if (rows.TryGetValue(r, out var rowSet) && rowSet.Contains(cell)\n                        || cols.TryGetValue(c, out var colSet) && colSet.Contains(cell)\n                        || squares.TryGetValue((r / 3) * 3 + c / 3, out var squareSet) && squareSet.Contains(cell)) {\n                    return false;\n                }\n                cols.TryAdd(c, new HashSet<char>());\n                rows.TryAdd(r, new HashSet<char>());\n                squares.TryAdd((r / 3) * 3 + c / 3, new HashSet<char>());\n                cols[c].Add(cell);\n                rows[r].Add(cell);\n                squares[(r / 3) * 3 + c / 3].Add(cell);\n            }\n        }\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isValidSudoku(self, board: List[List[str]]) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @return {boolean}\n     */\n    isValidSudoku(board) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isValidSudoku(vector<vector<char>>& board) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isValidSudoku(char[][] board) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsValidSudoku(char[][] board) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/TjFXEUCMqI8"},{"id":"two-integer-sum-ii","name":"Two Integer Sum II","description":"Given an array of integers `numbers` that is sorted in **non-decreasing order**.\n\nReturn the indices (**1-indexed**) of two numbers, `[index1, index2]`, such that they add up to a given target number `target` and `index1 < index2`. Note that `index1` and `index2` cannot be equal, therefore you may not use the same element twice.\n\nThere will always be **exactly one valid solution**.\n\nYour solution must use $O(1)$ additional space.\n\n**Example 1:**\n\n```java\nInput: numbers = [1,2,3,4], target = 3\n\nOutput: [1,2]\n```\n\nExplanation:\nThe sum of 1 and 2 is 3. Since we are assuming a 1-indexed array, `index1` = 1, `index2` = 2. We return `[1, 2]`.\n\n**Constraints:**\n* `2 <= numbers.length <= 1000`\n* `-1000 <= numbers[i] <= 1000`\n* `-1000 <= target <= 1000`\n","difficulty":"Medium","concepts":["Two Pointers"],"solutions":{"python":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n\n        while l < r:\n            curSum = numbers[l] + numbers[r]\n\n            if curSum > target:\n                r -= 1\n            elif curSum < target:\n                l += 1\n            else:\n                return [l + 1, r + 1]\n","javascript":"class Solution {\n    /**\n     * @param {number[]} numbers\n     * @param {number} target\n     * @return {number[]}\n     */\n    twoSum(numbers, target) {\n        let l = 0;\n        let r = numbers.length - 1;\n\n        while (l < r) {\n            const curSum = numbers[l] + numbers[r];\n\n            if (curSum > target) {\n                r--;\n            } else if (curSum < target) {\n                l++;\n            } else {\n                return [l + 1, r + 1];\n            }\n        }\n\n        return [];\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        int l = 0, r = numbers.size() - 1;\n\n        while (l < r) {\n            int curSum = numbers[l] + numbers[r];\n\n            if (curSum > target) {\n                r--;\n            } else if (curSum < target) {\n                l++;\n            } else {\n                return {l + 1, r + 1};\n            }\n        }\n        \n        return {};\n    }\n};\n","java":"class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int l = 0, r = numbers.length - 1;\n\n        while (l < r) {\n            int curSum = numbers[l] + numbers[r];\n\n            if (curSum > target) {\n                r--;\n            } else if (curSum < target) {\n                l++;\n            } else {\n                return new int[]{l + 1, r + 1};\n            }\n        }\n\n        return new int[0];\n    }\n}\n","csharp":"public class Solution {\n    public int[] TwoSum(int[] numbers, int target) {\n        int l = 0, r = numbers.Length - 1;\n\n        while (l < r) {\n            int curSum = numbers[l] + numbers[r];\n\n            if (curSum > target) {\n                r--;\n            } else if (curSum < target) {\n                l++;\n            } else {\n                return new int[]{l + 1, r + 1};\n            }\n        }\n        \n        return new int[0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} numbers\n     * @param {number} target\n     * @return {number[]}\n     */\n    twoSum(numbers, target) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& numbers, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] TwoSum(int[] numbers, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/cQ1Oz4ckceM"},{"id":"trapping-rain-water","name":"Trapping Rain Water","description":"You are given an array non-negative integers `heights` which represent an elevation map. Each value `heights[i]` represents the height of a bar, which has a width of `1`.\n\nReturn the maximum area of water that can be trapped between the bars.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/0c25cb81-1095-4382-fff2-6ef77c1fd100/public)\n\n```java\nInput: height = [0,2,0,3,1,0,1,3,2,1]\n\nOutput: 9\n```\n\n**Constraints:**\n* `1 <= height.length <= 1000`\n* `0 <= height[i] <= 1000`\n","difficulty":"Hard","concepts":["Two Pointers"],"solutions":{"python":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n\n        l, r = 0, len(height) - 1\n        leftMax, rightMax = height[l], height[r]\n        res = 0\n        while l < r:\n            if leftMax < rightMax:\n                l += 1\n                leftMax = max(leftMax, height[l])\n                res += leftMax - height[l]\n            else:\n                r -= 1\n                rightMax = max(rightMax, height[r])\n                res += rightMax - height[r]\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} height\n     * @return {number}\n     */\n    trap(height) {\n        if (!height || height.length === 0) {\n            return 0;\n        }\n\n        let l = 0;\n        let r = height.length - 1;\n        let leftMax = height[l];\n        let rightMax = height[r];\n        let res = 0;\n        while (l < r) {\n            if (leftMax < rightMax) {\n                l++;\n                leftMax = Math.max(leftMax, height[l]);\n                res += leftMax - height[l];\n            } else {\n                r--;\n                rightMax = Math.max(rightMax, height[r]);\n                res += rightMax - height[r];\n            }\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int trap(vector<int>& height) {\n        if (height.empty()) {\n            return 0;\n        }\n\n        int l = 0, r = height.size() - 1;\n        int leftMax = height[l], rightMax = height[r];\n        int res = 0;\n        while (l < r) {\n            if (leftMax < rightMax) {\n                l++;\n                leftMax = max(leftMax, height[l]);\n                res += leftMax - height[l];\n            } else {\n                r--;\n                rightMax = max(rightMax, height[r]);\n                res += rightMax - height[r];\n            }\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n\n        int l = 0, r = height.length - 1;\n        int leftMax = height[l], rightMax = height[r];\n        int res = 0;\n        while (l < r) {\n            if (leftMax < rightMax) {\n                l++;\n                leftMax = Math.max(leftMax, height[l]);\n                res += leftMax - height[l];\n            } else {\n                r--;\n                rightMax = Math.max(rightMax, height[r]);\n                res += rightMax - height[r];\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int Trap(int[] height) {\n        if (height == null || height.Length == 0) {\n            return 0;\n        }\n\n        int l = 0, r = height.Length - 1;\n        int leftMax = height[l], rightMax = height[r];\n        int res = 0;\n        while (l < r) {\n            if (leftMax < rightMax) {\n                l++;\n                leftMax = Math.Max(leftMax, height[l]);\n                res += leftMax - height[l];\n            } else {\n                r--;\n                rightMax = Math.Max(rightMax, height[r]);\n                res += rightMax - height[r];\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} height\n     * @return {number}\n     */\n    trap(height) {}\n}\n","cpp":"class Solution {\npublic:\n    int trap(vector<int>& height) {\n        \n    }\n};\n","java":"class Solution {\n    public int trap(int[] height) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Trap(int[] height) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/ZI2z5pq0TqA"},{"id":"permutation-string","name":"Permutation String","description":"You are given two strings `s1` and `s2`.\n    \nReturn `true` if `s2` contains a permutation of `s1`, or `false` otherwise. That means if a permutation of `s1` exists as a substring of `s2`, then return `true`.\n\nBoth strings only contain lowercase letters.\n\n**Example 1:**\n\n```java\nInput: s1 = \"abc\", s2 = \"lecabee\"\n\nOutput: true\n```\n\nExplanation: The substring `\"cab\"` is a permutation of `\"abc\"` and is present in `\"lecabee\"`.\n\n**Example 2:**\n\n```java\nInput: s1 = \"abc\", s2 = \"lecaabee\"\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= s1.length, s2.length <= 1000`\n","difficulty":"Medium","concepts":["Sliding Window Fixed Size","Sliding Window Variable Size"],"solutions":{"python":"class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        if len(s1) > len(s2):\n            return False\n\n        s1Count, s2Count = [0] * 26, [0] * 26\n        for i in range(len(s1)):\n            s1Count[ord(s1[i]) - ord(\"a\")] += 1\n            s2Count[ord(s2[i]) - ord(\"a\")] += 1\n\n        matches = 0\n        for i in range(26):\n            matches += 1 if s1Count[i] == s2Count[i] else 0\n\n        l = 0\n        for r in range(len(s1), len(s2)):\n            if matches == 26:\n                return True\n\n            index = ord(s2[r]) - ord(\"a\")\n            s2Count[index] += 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] + 1 == s2Count[index]:\n                matches -= 1\n\n            index = ord(s2[l]) - ord(\"a\")\n            s2Count[index] -= 1\n            if s1Count[index] == s2Count[index]:\n                matches += 1\n            elif s1Count[index] - 1 == s2Count[index]:\n                matches -= 1\n            l += 1\n        return matches == 26\n","javascript":"class Solution {\n    /**\n     * @param {string} s1\n     * @param {string} s2\n     * @return {boolean}\n     */\n    checkInclusion(s1, s2) {\n        if (s1.length > s2.length) {\n            return false;\n        }\n\n        const s1Count = new Array(26).fill(0);\n        const s2Count = new Array(26).fill(0);\n        for (let i = 0; i < s1.length; i++) {\n            s1Count[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n            s2Count[s2.charCodeAt(i) - 'a'.charCodeAt(0)]++;\n        }\n\n        let matches = 0;\n        for (let i = 0; i < 26; i++) {\n            if (s1Count[i] === s2Count[i]) {\n                matches++;\n            }\n        }\n\n        let l = 0;\n        for (let r = s1.length; r < s2.length; r++) {\n            if (matches === 26) {\n                return true;\n            }\n\n            let index = s2.charCodeAt(r) - 'a'.charCodeAt(0);\n            s2Count[index]++;\n            if (s1Count[index] === s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] + 1 === s2Count[index]) {\n                matches--;\n            }\n\n            index = s2.charCodeAt(l) - 'a'.charCodeAt(0);\n            s2Count[index]--;\n            if (s1Count[index] === s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] - 1 === s2Count[index]) {\n                matches--;\n            }\n            l++;\n        }\n        return matches === 26;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        if (s1.length() > s2.length()) {\n            return false;\n        }\n\n        vector<int> s1Count(26, 0);\n        vector<int> s2Count(26, 0);\n        for (int i = 0; i < s1.length(); i++) {\n            s1Count[s1[i] - 'a']++;\n            s2Count[s2[i] - 'a']++;\n        }\n\n        int matches = 0;\n        for (int i = 0; i < 26; i++) {\n            if (s1Count[i] == s2Count[i]) {\n                matches++;\n            }\n        }\n\n        int l = 0;\n        for (int r = s1.length(); r < s2.length(); r++) {\n            if (matches == 26) {\n                return true;\n            }\n\n            int index = s2[r] - 'a';\n            s2Count[index]++;\n            if (s1Count[index] == s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] + 1 == s2Count[index]) {\n                matches--;\n            }\n\n            index = s2[l] - 'a';\n            s2Count[index]--;\n            if (s1Count[index] == s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] - 1 == s2Count[index]) {\n                matches--;\n            }\n            l++;\n        }\n        return matches == 26;\n    }\n};\n","java":"class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) {\n            return false;\n        }\n\n        int[] s1Count = new int[26];\n        int[] s2Count = new int[26];\n        for (int i = 0; i < s1.length(); i++) {\n            s1Count[s1.charAt(i) - 'a']++;\n            s2Count[s2.charAt(i) - 'a']++;\n        }\n\n        int matches = 0;\n        for (int i = 0; i < 26; i++) {\n            if (s1Count[i] == s2Count[i]) {\n                matches++;\n            }\n        }\n\n        int l = 0;\n        for (int r = s1.length(); r < s2.length(); r++) {\n            if (matches == 26) {\n                return true;\n            }\n\n            int index = s2.charAt(r) - 'a';\n            s2Count[index]++;\n            if (s1Count[index] == s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] + 1 == s2Count[index]) {\n                matches--;\n            }\n\n            index = s2.charAt(l) - 'a';\n            s2Count[index]--;\n            if (s1Count[index] == s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] - 1 == s2Count[index]) {\n                matches--;\n            }\n            l++;\n        }\n        return matches == 26;\n    }\n}\n","csharp":"public class Solution {\n    public bool CheckInclusion(string s1, string s2) {\n        if (s1.Length > s2.Length) {\n            return false;\n        }\n\n        int[] s1Count = new int[26];\n        int[] s2Count = new int[26];\n        for (int i = 0; i < s1.Length; i++) {\n            s1Count[s1[i] - 'a']++;\n            s2Count[s2[i] - 'a']++;\n        }\n\n        int matches = 0;\n        for (int i = 0; i < 26; i++) {\n            if (s1Count[i] == s2Count[i]) {\n                matches++;\n            }\n        }\n\n        int l = 0;\n        for (int r = s1.Length; r < s2.Length; r++) {\n            if (matches == 26) {\n                return true;\n            }\n\n            int index = s2[r] - 'a';\n            s2Count[index]++;\n            if (s1Count[index] == s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] + 1 == s2Count[index]) {\n                matches--;\n            }\n\n            index = s2[l] - 'a';\n            s2Count[index]--;\n            if (s1Count[index] == s2Count[index]) {\n                matches++;\n            } else if (s1Count[index] - 1 == s2Count[index]) {\n                matches--;\n            }\n            l++;\n        }\n        return matches == 26;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def checkInclusion(self, s1: str, s2: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s1\n     * @param {string} s2\n     * @return {boolean}\n     */\n    checkInclusion(s1, s2) {}\n}\n","cpp":"class Solution {\npublic:\n    bool checkInclusion(string s1, string s2) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool CheckInclusion(string s1, string s2) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/UbyhOgBN834"},{"id":"sliding-window-maximum","name":"Sliding Window Maximum","description":"You are given an array of integers `nums` and an integer `k`. There is a sliding window of size `k` that starts at the left edge of the array. The window slides one position to the right until it reaches the right edge of the array.\n\nReturn a list that contains the maximum element in the window at each step.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,1,0,4,2,6], k = 3\n\nOutput: [2,2,4,4,6]\n\nExplanation: \nWindow position            Max\n---------------           -----\n[1  2  1] 0  4  2  6        2\n 1 [2  1  0] 4  2  6        2\n 1  2 [1  0  4] 2  6        4\n 1  2  1 [0  4  2] 6        4\n 1  2  1  0 [4  2  6]       6\n```\n\n**Constraints:**\n* `1 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n* `1 <= k <= nums.length`\n","difficulty":"Hard","concepts":["Queues","Sliding Window Fixed Size","Sliding Window Variable Size"],"solutions":{"python":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        output = []\n        q = deque()  # index\n        l = r = 0\n\n        while r < len(nums):\n            while q and nums[q[-1]] < nums[r]:\n                q.pop()\n            q.append(r)\n\n            if l > q[0]:\n                q.popleft()\n\n            if (r + 1) >= k:\n                output.append(nums[q[0]])\n                l += 1\n            r += 1\n\n        return output\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} k\n     * @return {number[]}\n     */\n    maxSlidingWindow(nums, k) {\n        const n = nums.length;\n        const output = new Array(n - k + 1);\n        const q = [];\n        let l = 0;\n        let r = 0;\n\n        while (r < n) {\n            while (q.length > 0 && nums[q[q.length - 1]] < nums[r]) {\n                q.pop();\n            }\n            q.push(r);\n\n            if (l > q[0]) {\n                q.shift();\n            }\n\n            if (r + 1 >= k) {\n                output[l] = nums[q[0]];\n                l++;\n            }\n            r++;\n        }\n\n        return output;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> output(n - k + 1);\n        deque<int> q;\n        int l = 0, r = 0;\n\n        while (r < n) {\n            while (!q.empty() && nums[q.back()] < nums[r]) {\n                q.pop_back();\n            }\n            q.push_back(r);\n\n            if (l > q.front()) {\n                q.pop_front();\n            }\n\n            if (r + 1 >= k) {\n                output[l] = nums[q.front()];\n                l++;\n            }\n            r++;\n        }\n\n        return output;\n    }\n};\n","java":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        int[] output = new int[n - k + 1];\n        Deque<Integer> q = new ArrayDeque<>();\n        int l = 0, r = 0;\n\n        while (r < n) {\n            while (!q.isEmpty() && nums[q.peekLast()] < nums[r]) {\n                q.pollLast();\n            }\n            q.offer(r);\n\n            if (l > q.peekFirst()) {\n                q.pollFirst();\n            }\n\n            if (r + 1 >= k) {\n                output[l] = nums[q.peekFirst()];\n                l++;\n            }\n            r++;\n        }\n\n        return output;\n    }\n}\n","csharp":"public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        int n = nums.Length;\n        int[] output = new int[n - k + 1];\n        LinkedList<int> q = new LinkedList<int>();\n        int l = 0, r = 0;\n\n        while (r < n) {\n            while (q.Count > 0 && nums[q.Last.Value] < nums[r]) {\n                q.RemoveLast();\n            }\n            q.AddLast(r);\n\n            if (l > q.First.Value) {\n                q.RemoveFirst();\n            }\n\n            if (r + 1 >= k) {\n                output[l] = nums[q.First.Value];\n                l++;\n            }\n            r++;\n        }\n\n        return output;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} k\n     * @return {number[]}\n     */\n    maxSlidingWindow(nums, k) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] MaxSlidingWindow(int[] nums, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/DfljaUwZsOk"},{"id":"minimum-stack","name":"Minimum Stack","description":"Design a stack class that supports the `push`, `pop`, `top`, and `getMin` operations.\n\n* `MinStack()` initializes the stack object.\n* `void push(int val)` pushes the element `val` onto the stack.\n* `void pop()` removes the element on the top of the stack.\n* `int top()` gets the top element of the stack.\n* `int getMin()` retrieves the minimum element in the stack.\n\nEach function should run in $O(1)$ time.\n\n**Example 1:**\n\n```java\nInput: [\"MinStack\", \"push\", 1, \"push\", 2, \"push\", 0, \"getMin\", \"pop\", \"top\", \"getMin\"]\n\nOutput: [null,null,null,null,0,null,2,1]\n\nExplanation:\nMinStack minStack = new MinStack();\nminStack.push(1);\nminStack.push(2);\nminStack.push(0);\nminStack.getMin(); // return 0\nminStack.pop();\nminStack.top();    // return 2\nminStack.getMin(); // return 1\n```\n\n**Constraints:**\n* `-2^31 <= val <= 2^31 - 1`.\n* `pop`, `top` and `getMin` will always be called on **non-empty** stacks.\n","difficulty":"Medium","concepts":["Stacks"],"solutions":{"python":"class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.minStack = []\n\n    def push(self, val: int) -> None:\n        self.stack.append(val)\n        val = min(val, self.minStack[-1] if self.minStack else val)\n        self.minStack.append(val)\n\n    def pop(self) -> None:\n        self.stack.pop()\n        self.minStack.pop()\n\n    def top(self) -> int:\n        return self.stack[-1]\n\n    def getMin(self) -> int:\n        return self.minStack[-1]\n","javascript":"class MinStack {\n    constructor() {\n        this.stack = [];\n        this.minStack = [];\n    }\n\n    /**\n     * @param {number} val\n     * @return {void}\n     */\n    push(val) {\n        this.stack.push(val);\n        val = Math.min(\n            val,\n            this.minStack.length === 0\n                ? val\n                : this.minStack[this.minStack.length - 1],\n        );\n        this.minStack.push(val);\n    }\n\n    /**\n     * @return {void}\n     */\n    pop() {\n        this.stack.pop();\n        this.minStack.pop();\n    }\n\n    /**\n     * @return {number}\n     */\n    top() {\n        return this.stack[this.stack.length - 1];\n    }\n\n    /**\n     * @return {number}\n     */\n    getMin() {\n        return this.minStack[this.minStack.length - 1];\n    }\n}\n","cpp":"class MinStack {\nprivate:\n    std::stack<int> stack;\n    std::stack<int> minStack;\n\npublic:\n    MinStack() {}\n\n    void push(int val) {\n        stack.push(val);\n        val = std::min(val, minStack.empty() ? val : minStack.top());\n        minStack.push(val);\n    }\n\n    void pop() {\n        stack.pop();\n        minStack.pop();\n    }\n\n    int top() {\n        return stack.top();\n    }\n\n    int getMin() {\n        return minStack.top();\n    }\n};\n","java":"class MinStack {\n    \n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        val = Math.min(val, minStack.isEmpty() ? val : minStack.peek());\n        minStack.push(val);\n    }\n\n    public void pop() {\n        stack.pop();\n        minStack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n","csharp":"public class MinStack {\n    \n    private Stack<int> stack;\n    private Stack<int> minStack;\n\n    public MinStack() {\n        stack = new Stack<int>();\n        minStack = new Stack<int>();\n    }\n\n    public void Push(int val) {\n        stack.Push(val);\n        val = Math.Min(val, minStack.Count == 0 ? val : minStack.Peek());\n        minStack.Push(val);\n    }\n\n    public void Pop() {\n        stack.Pop();\n        minStack.Pop();\n    }\n\n    public int Top() {\n        return stack.Peek();\n    }\n\n    public int GetMin() {\n        return minStack.Peek();\n    }\n}\n"},"starterCode":{"python":"class MinStack:\n\n    def __init__(self):\n        \n\n    def push(self, val: int) -> None:\n        \n\n    def pop(self) -> None:\n        \n\n    def top(self) -> int:\n        \n\n    def getMin(self) -> int:\n        \n","javascript":"class MinStack {\n    constructor() {}\n\n    /**\n     * @param {number} val\n     * @return {void}\n     */\n    push(val) {}\n\n    /**\n     * @return {void}\n     */\n    pop() {}\n\n    /**\n     * @return {number}\n     */\n    top() {}\n\n    /**\n     * @return {number}\n     */\n    getMin() {}\n}\n","cpp":"class MinStack {\npublic:\n    MinStack() {\n        \n    }\n    \n    void push(int val) {\n        \n    }\n    \n    void pop() {\n        \n    }\n    \n    int top() {\n        \n    }\n    \n    int getMin() {\n        \n    }\n};\n","java":"class MinStack {\n\n    public MinStack() {\n        \n    }\n    \n    public void push(int val) {\n        \n    }\n    \n    public void pop() {\n        \n    }\n    \n    public int top() {\n        \n    }\n    \n    public int getMin() {\n        \n    }\n}\n","csharp":"public class MinStack {\n\n    public MinStack() {\n        \n    }\n    \n    public void Push(int val) {\n        \n    }\n    \n    public void Pop() {\n        \n    }\n    \n    public int Top() {\n        \n    }\n    \n    public int GetMin() {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/qkLl7nAwDPo"},{"id":"evaluate-reverse-polish-notation","name":"Evaluate Reverse Polish Notation","description":"You are given an array of strings `tokens` that represents a **valid** arithmetic expression in [Reverse Polish Notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation).\n\nReturn the integer that represents the evaluation of the expression.\n\n* The operands may be integers or the results of other operations.\n* The operators include `'+'`, `'-'`, `'*'`, and `'/'`.\n* Assume that division between integers always truncates toward zero.\n\n**Example 1:**\n\n```java\nInput: tokens = [\"1\",\"2\",\"+\",\"3\",\"*\",\"4\",\"-\"]\n\nOutput: 5\n\nExplanation: ((1 + 2) * 3) - 4 = 5\n```\n\n**Constraints:**\n* `1 <= tokens.length <= 1000`.\n* tokens[i] is `\"+\"`, `\"-\"`, `\"*\"`, or `\"/\"`, or a string representing an integer in the range `[-100, 100]`.\n","difficulty":"Medium","concepts":["Stacks"],"solutions":{"python":"class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        stack = []\n        for c in tokens:\n            if c == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif c == \"-\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(b - a)\n            elif c == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif c == \"/\":\n                a, b = stack.pop(), stack.pop()\n                stack.append(int(float(b) / a))\n            else:\n                stack.append(int(c))\n        return stack[0]\n","javascript":"class Solution {\n    /**\n     * @param {string[]} tokens\n     * @return {number}\n     */\n    evalRPN(tokens) {\n        const stack = [];\n        for (const c of tokens) {\n            if (c === '+') {\n                stack.push(stack.pop() + stack.pop());\n            } else if (c === '-') {\n                const a = stack.pop();\n                const b = stack.pop();\n                stack.push(b - a);\n            } else if (c === '*') {\n                stack.push(stack.pop() * stack.pop());\n            } else if (c === '/') {\n                const a = stack.pop();\n                const b = stack.pop();\n                stack.push(Math.trunc(b / a));\n            } else {\n                stack.push(parseInt(c));\n            }\n        }\n        return stack.pop();\n    }\n}\n","cpp":"class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        stack<int> stack;\n        for (const string& c : tokens) {\n            if (c == \"+\") {\n                int a = stack.top(); stack.pop();\n                int b = stack.top(); stack.pop();\n                stack.push(b + a);\n            } else if (c == \"-\") {\n                int a = stack.top(); stack.pop();\n                int b = stack.top(); stack.pop();\n                stack.push(b - a);\n            } else if (c == \"*\") {\n                int a = stack.top(); stack.pop();\n                int b = stack.top(); stack.pop();\n                stack.push(b * a);\n            } else if (c == \"/\") {\n                int a = stack.top(); stack.pop();\n                int b = stack.top(); stack.pop();\n                stack.push(static_cast<int>(static_cast<double>(b) / a));\n            } else {\n                stack.push(stoi(c));\n            }\n        }\n        return stack.top();\n    }\n};\n","java":"class Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n        for (String c : tokens) {\n            if (c.equals(\"+\")) {\n                stack.push(stack.pop() + stack.pop());\n            } else if (c.equals(\"-\")) {\n                int a = stack.pop();\n                int b = stack.pop();\n                stack.push(b - a);\n            } else if (c.equals(\"*\")) {\n                stack.push(stack.pop() * stack.pop());\n            } else if (c.equals(\"/\")) {\n                int a = stack.pop();\n                int b = stack.pop();\n                stack.push((int) ((double) b / a));\n            } else {\n                stack.push(Integer.parseInt(c));\n            }\n        }\n        return stack.pop();\n    }\n}\n","csharp":"public class Solution {\n    public int EvalRPN(string[] tokens) {\n        Stack<int> stack = new Stack<int>();\n        foreach (string c in tokens) {\n            if (c == \"+\") {\n                stack.Push(stack.Pop() + stack.Pop());\n            } else if (c == \"-\") {\n                int a = stack.Pop();\n                int b = stack.Pop();\n                stack.Push(b - a);\n            } else if (c == \"*\") {\n                stack.Push(stack.Pop() * stack.Pop());\n            } else if (c == \"/\") {\n                int a = stack.Pop();\n                int b = stack.Pop();\n                stack.Push((int) ((double) b / a));\n            } else {\n                stack.Push(int.Parse(c));\n            }\n        }\n        return stack.Pop();\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def evalRPN(self, tokens: List[str]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string[]} tokens\n     * @return {number}\n     */\n    evalRPN(tokens) {}\n}\n","cpp":"class Solution {\npublic:\n    int evalRPN(vector<string>& tokens) {\n        \n    }\n};\n","java":"class Solution {\n    public int evalRPN(String[] tokens) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int EvalRPN(string[] tokens) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/iu0082c4HDE"},{"id":"generate-parentheses","name":"Generate Parentheses","description":"You are given an integer `n`. Return all well-formed parentheses strings that you can generate with `n` pairs of parentheses.\n\n**Example 1:**\n\n```java\nInput: n = 1\n\nOutput: [\"()\"]\n```\n\n**Example 2:**\n\n```java\nInput: n = 3\n\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\n```\n\nYou may return the answer in **any order**.\n\n**Constraints:**\n* `1 <= n <= 7`\n","difficulty":"Medium","concepts":["Stacks","Tree Maze"],"solutions":{"python":"class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        stack = []\n        res = []\n\n        def backtrack(openN, closedN):\n            if openN == closedN == n:\n                res.append(\"\".join(stack))\n                return\n\n            if openN < n:\n                stack.append(\"(\")\n                backtrack(openN + 1, closedN)\n                stack.pop()\n            if closedN < openN:\n                stack.append(\")\")\n                backtrack(openN, closedN + 1)\n                stack.pop()\n\n        backtrack(0, 0)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {string[]}\n     */\n    generateParenthesis(n) {\n        const res = [];\n        this.backtrack(n, 0, 0, '', res);\n        return res;\n    }\n\n    /**\n     * @param {number} n\n     * @param {number} openN\n     * @param {number} closedN\n     * @param {string} current\n     * @param {string[]}\n     * @return {void}\n     */\n    backtrack(n, openN, closedN, current, res) {\n        if (openN === closedN && openN === n) {\n            res.push(current);\n            return;\n        }\n\n        if (openN < n) {\n            this.backtrack(n, openN + 1, closedN, current + '(', res);\n        }\n        if (closedN < openN) {\n            this.backtrack(n, openN, closedN + 1, current + ')', res);\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        vector<string> res;\n        backtrack(n, 0, 0, \"\", res);\n        return res;\n    }\n\nprivate:\n    void backtrack(int n, int openN, int closedN, string current, vector<string>& res) {\n        if (openN == closedN && openN == n) {\n            res.push_back(current);\n            return;\n        }\n\n        if (openN < n) {\n            backtrack(n, openN + 1, closedN, current + \"(\", res);\n        }\n        if (closedN < openN) {\n            backtrack(n, openN, closedN + 1, current + \")\", res);\n        }\n    }\n};\n","java":"class Solution {\n    \n    public List<String> generateParenthesis(int n) {\n        List<String> res = new ArrayList<>();\n        Stack<Character> stack = new Stack<>();\n        backtrack(n, 0, 0, stack, res);\n        return res;\n    }\n\n    private void backtrack(int n, int openN, int closedN, Stack<Character> stack, List<String> res) {\n        if (openN == closedN && openN == n) {\n            StringBuilder sb = new StringBuilder();\n            for (char c : stack) {\n                sb.append(c);\n            }\n            res.add(sb.toString());\n            return;\n        }\n\n        if (openN < n) {\n            stack.push('(');\n            backtrack(n, openN + 1, closedN, stack, res);\n            stack.pop();\n        }\n        if (closedN < openN) {\n            stack.push(')');\n            backtrack(n, openN, closedN + 1, stack, res);\n            stack.pop();\n        }\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<string> GenerateParenthesis(int n) {\n        List<string> res = new List<string>();\n        Backtrack(n, 0, 0, \"\", res);\n        return res;\n    }\n\n    private void Backtrack(int n, int openN, int closedN, string current, List<string> res) {\n        if (openN == closedN && openN == n) {\n            res.Add(current);\n            return;\n        }\n\n        if (openN < n) {\n            Backtrack(n, openN + 1, closedN, current + \"(\", res);\n        }\n        if (closedN < openN) {\n            Backtrack(n, openN, closedN + 1, current + \")\", res);\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {string[]}\n     */\n    generateParenthesis(n) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<string> generateParenthesis(int n) {\n        \n    }\n};\n","java":"class Solution {\n    public List<String> generateParenthesis(int n) {\n        \n    }\n}\n","csharp":"public class Solution {  \n    public List<string> GenerateParenthesis(int n) {\n\n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/s9fokUqJ76A"},{"id":"daily-temperatures","name":"Daily Temperatures","description":"You are given an array of integers `temperatures` where `temperatures[i]` represents the daily temperatures on the `ith` day.\n    \nReturn an array `result` where `result[i]` is the number of days after the `ith` day before a warmer temperature appears on a future day. If there is no day in the future where a warmer temperature will appear for the `ith` day, set `result[i]` to `0` instead.\n\n**Example 1:**\n\n```java\nInput: temperatures = [30,38,30,36,35,40,28]\n\nOutput: [1,4,1,2,1,0,0]\n```\n\n**Example 2:**\n\n```java\nInput: temperatures = [22,21,20]\n\nOutput: [0,0,0]\n```\n\n**Constraints:**\n* `1 <= temperatures.length <= 1000`.\n* `1 <= temperatures[i] <= 100`\n","difficulty":"Medium","concepts":["Stacks"],"solutions":{"python":"class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        res = [0] * len(temperatures)\n        stack = []  # pair: [temp, index]\n\n        for i, t in enumerate(temperatures):\n            while stack and t > stack[-1][0]:\n                stackT, stackInd = stack.pop()\n                res[stackInd] = i - stackInd\n            stack.append((t, i))\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} temperatures\n     * @return {number[]}\n     */\n    dailyTemperatures(temperatures) {\n        const res = new Array(temperatures.length).fill(0);\n        const stack = []; // pair: [temp, index]\n\n        for (let i = 0; i < temperatures.length; i++) {\n            const t = temperatures[i];\n            while (stack.length > 0 && t > stack[stack.length - 1][0]) {\n                const [stackT, stackInd] = stack.pop();\n                res[stackInd] = i - stackInd;\n            }\n            stack.push([t, i]);\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        vector<int> res(temperatures.size(), 0);\n        stack<pair<int, int>> stack; // pair: {temp, index}\n\n        for (int i = 0; i < temperatures.size(); i++) {\n            int t = temperatures[i];\n            while (!stack.empty() && t > stack.top().first) {\n                auto pair = stack.top();\n                stack.pop();\n                res[pair.second] = i - pair.second;\n            }\n            stack.push({t, i});\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        int[] res = new int[temperatures.length];\n        Stack<int[]> stack = new Stack<>(); // pair: [temp, index]\n\n        for (int i = 0; i < temperatures.length; i++) {\n            int t = temperatures[i];\n            while (!stack.isEmpty() && t > stack.peek()[0]) {\n                int[] pair = stack.pop();\n                res[pair[1]] = i - pair[1];\n            }\n            stack.push(new int[]{t, i});\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int[] DailyTemperatures(int[] temperatures) {\n        int[] res = new int[temperatures.Length];\n        Stack<int[]> stack = new Stack<int[]>(); // pair: [temp, index]\n\n        for (int i = 0; i < temperatures.Length; i++) {\n            int t = temperatures[i];\n            while (stack.Count > 0 && t > stack.Peek()[0]) {\n                int[] pair = stack.Pop();\n                res[pair[1]] = i - pair[1];\n            }\n            stack.Push(new int[] { t, i });\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} temperatures\n     * @return {number[]}\n     */\n    dailyTemperatures(temperatures) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> dailyTemperatures(vector<int>& temperatures) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] dailyTemperatures(int[] temperatures) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] DailyTemperatures(int[] temperatures) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/cTBiBSnjO3c"},{"id":"car-fleet","name":"Car Fleet","description":"There are `n` cars traveling to the same destination on a one-lane highway.\n\nYou are given two arrays of integers `position` and `speed`, both of length `n`. \n* `position[i]` is the position of the `ith car` (in miles)\n* `speed[i]` is the speed of the `ith` car (in miles per hour)\n\nThe **destination** is at position `target` miles.\n\nA car can **not** pass another car ahead of it. It can only catch up to another car and then drive at the same speed as the car ahead of it.\n\nA **car fleet** is a non-empty set of cars driving at the same position and same speed. A single car is also considered a car fleet.\n\nIf a car catches up to a car fleet the moment the fleet reaches the destination, then the car is considered to be part of the fleet.\n\nReturn the number of **different car fleets** that will arrive at the destination.\n\n**Example 1:**\n\n```java\nInput: target = 10, position = [1,4], speed = [3,2]\n\nOutput: 1\n```\n\nExplanation: The cars starting at 1 (speed 3) and 4 (speed 2) become a fleet, meeting each other at 10, the destination.\n\n**Example 2:**\n\n```java\nInput: target = 10, position = [4,1,0,7], speed = [2,2,1,1]\n\nOutput: 3\n```\n\nExplanation: The cars starting at 4 and 7 become a fleet at position 10. The cars starting at 1 and 0 never catch up to the car ahead of them. Thus, there are 3 car fleets that will arrive at the destination.\n\n**Constraints:**\n* `n == position.length == speed.length`.\n* `1 <= n <= 1000`\n* `0 < target <= 1000`\n* `0 < speed[i] <= 100`\n* `0 <= position[i] < target`\n* All the values of `position` are **unique**.\n","difficulty":"Medium","concepts":["Stacks"],"solutions":{"python":"class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        pair = [(p, s) for p, s in zip(position, speed)]\n        pair.sort(reverse=True)\n        stack = []\n        for p, s in pair:  # Reverse Sorted Order\n            stack.append((target - p) / s)\n            if len(stack) >= 2 and stack[-1] <= stack[-2]:\n                stack.pop()\n        return len(stack)\n","javascript":"class Solution {\n    /**\n     * @param {number} target\n     * @param {number[]} position\n     * @param {number[]} speed\n     * @return {number}\n     */\n    carFleet(target, position, speed) {\n        const n = position.length;\n        const pairs = position.map((p, i) => [p, speed[i]]);\n        pairs.sort((a, b) => b[0] - a[0]);\n\n        let fleetCount = 0;\n        const timeToReach = new Array(n);\n        for (let i = 0; i < n; i++) {\n            timeToReach[i] = (target - pairs[i][0]) / pairs[i][1];\n            if (i >= 1 && timeToReach[i] <= timeToReach[i - 1]) {\n                timeToReach[i] = timeToReach[i - 1];\n            } else {\n                fleetCount++;\n            }\n        }\n        return fleetCount;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        int n = position.size();\n        vector<pair<double, double>> pairs(n);\n        for (int i = 0; i < n; i++) {\n            pairs[i] = { position[i], speed[i] };\n        }\n        sort(pairs.begin(), pairs.end(), [](const pair<double, double>& a, const pair<double, double>& b) {\n            return b.first < a.first;\n        });\n\n\n        int fleetCount = 0;\n        vector<double> timeToReach(n);\n        for (int i = 0; i < n; i++) {\n            timeToReach[i] = (target - pairs[i].first) / pairs[i].second;\n            if (i >= 1 && timeToReach[i] <= timeToReach[i - 1]) {\n                timeToReach[i] = timeToReach[i - 1];\n            } else {\n                fleetCount++;\n            }\n        }\n        return fleetCount;\n    }\n};\n","java":"class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        int n = position.length;\n        double[][] pairs = new double[n][2];\n        for (int i = 0; i < n; i++) {\n            pairs[i][0] = position[i];\n            pairs[i][1] = speed[i];\n        }\n        Arrays.sort(pairs, (a, b) -> Double.compare(b[0], a[0]));\n\n        int fleetCount = 0;\n        double[] timeToReach = new double[n];\n        for (int i = 0; i < n; i++) {\n            timeToReach[i] = (target - pairs[i][0]) / pairs[i][1];\n            if (i >= 1 && timeToReach[i] <= timeToReach[i - 1]) {\n                timeToReach[i] = timeToReach[i - 1];\n            } else {\n                fleetCount++;\n            }\n        }\n        return fleetCount;\n    }\n}\n","csharp":"public class Solution {\n    public int CarFleet(int target, int[] position, int[] speed) {\n        int n = position.Length;\n        double[][] pairs = new double[n][];\n        for (int i = 0; i < n; i++) {\n            pairs[i] = new double[] { position[i], speed[i] };\n        }\n        Array.Sort(pairs, (a, b) => b[0].CompareTo(a[0]));\n\n        int fleetCount = 0;\n        double[] timeToReach = new double[n];\n        for (int i = 0; i < n; i++) {\n            timeToReach[i] = (target - pairs[i][0]) / pairs[i][1];\n            if (i >= 1 && timeToReach[i] <= timeToReach[i - 1]) {\n                timeToReach[i] = timeToReach[i - 1];\n            } else {\n                fleetCount++;\n            }\n        }\n        return fleetCount;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def carFleet(self, target: int, position: List[int], speed: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} target\n     * @param {number[]} position\n     * @param {number[]} speed\n     * @return {number}\n     */\n    carFleet(target, position, speed) {}\n}\n","cpp":"class Solution {\npublic:\n    int carFleet(int target, vector<int>& position, vector<int>& speed) {\n        \n    }\n};\n","java":"class Solution {\n    public int carFleet(int target, int[] position, int[] speed) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int CarFleet(int target, int[] position, int[] speed) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Pr6T-3yB9RM"},{"id":"largest-rectangle-in-histogram","name":"Largest Rectangle In Histogram","description":"You are given an array of integers `heights` where `heights[i]` represents the height of a bar. The width of each bar is `1`.\n    \nReturn the area of the largest rectangle that can be formed among the bars.\n\nNote: This chart is known as a [histogram](https://en.wikipedia.org/wiki/Histogram).\n\n**Example 1:**\n\n```java\nInput: heights = [7,1,7,2,2,4]\n\nOutput: 8\n```\n\n**Example 2:**\n\n```java\nInput: heights = [1,3,7]\n\nOutput: 7\n```\n\n**Constraints:**\n* `1 <= heights.length <= 1000`.\n* `0 <= heights[i] <= 1000`\n","difficulty":"Hard","concepts":["Stacks"],"solutions":{"python":"class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        maxArea = 0\n        stack = []  # pair: (index, height)\n\n        for i, h in enumerate(heights):\n            start = i\n            while stack and stack[-1][1] > h:\n                index, height = stack.pop()\n                maxArea = max(maxArea, height * (i - index))\n                start = index\n            stack.append((start, h))\n\n        for i, h in stack:\n            maxArea = max(maxArea, h * (len(heights) - i))\n        return maxArea\n","javascript":"class Solution {\n    /**\n     * @param {number[]} heights\n     * @return {number}\n     */\n    largestRectangleArea(heights) {\n        let maxArea = 0;\n        const stack = []; // pair: (index, height)\n\n        for (let i = 0; i < heights.length; i++) {\n            let start = i;\n            while (\n                stack.length > 0 &&\n                stack[stack.length - 1][1] > heights[i]\n            ) {\n                const [index, height] = stack.pop();\n                maxArea = Math.max(maxArea, height * (i - index));\n                start = index;\n            }\n            stack.push([start, heights[i]]);\n        }\n\n        for (const [index, height] of stack) {\n            maxArea = Math.max(maxArea, height * (heights.length - index));\n        }\n        return maxArea;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        int maxArea = 0;\n        stack<pair<int, int>> stack; // pair: (index, height)\n\n        for (int i = 0; i < heights.size(); i++) {\n            int start = i;\n            while (!stack.empty() && stack.top().second > heights[i]) {\n                pair<int, int> top = stack.top();\n                int index = top.first;\n                int height = top.second;\n                maxArea = max(maxArea, height * (i - index));\n                start = index;\n                stack.pop();\n            }\n            stack.push({ start, heights[i] });\n        }\n\n        while (!stack.empty()) {\n            int index = stack.top().first;\n            int height = stack.top().second;\n            maxArea = max(maxArea, height * (static_cast<int>(heights.size()) - index));\n            stack.pop();\n        }\n        return maxArea;\n    }\n};\n","java":"class Solution {\n    public int largestRectangleArea(int[] heights) {\n        int maxArea = 0;\n        Stack<int[]> stack = new Stack<>(); // pair: (index, height)\n\n        for (int i = 0; i < heights.length; i++) {\n            int start = i;\n            while (!stack.isEmpty() && stack.peek()[1] > heights[i]) {\n                int[] top = stack.pop();\n                int index = top[0];\n                int height = top[1];\n                maxArea = Math.max(maxArea, height * (i - index));\n                start = index;\n            }\n            stack.push(new int[]{start, heights[i]});\n        }\n\n        for (int[] pair : stack) {\n            int index = pair[0];\n            int height = pair[1];\n            maxArea = Math.max(maxArea, height * (heights.length - index));\n        }\n        return maxArea;\n    }\n}\n","csharp":"public class Solution {\n    public int LargestRectangleArea(int[] heights) {\n        int maxArea = 0;\n        Stack<int[]> stack = new Stack<int[]>(); // pair: (index, height)\n\n        for (int i = 0; i < heights.Length; i++) {\n            int start = i;\n            while (stack.Count > 0 && stack.Peek()[1] > heights[i]) {\n                int[] top = stack.Pop();\n                int index = top[0];\n                int height = top[1];\n                maxArea = Math.Max(maxArea, height * (i - index));\n                start = index;\n            }\n            stack.Push(new int[] { start, heights[i] });\n        }\n\n        foreach (int[] pair in stack) {\n            int index = pair[0];\n            int height = pair[1];\n            maxArea = Math.Max(maxArea, height * (heights.Length - index));\n        }\n        return maxArea;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} heights\n     * @return {number}\n     */\n    largestRectangleArea(heights) {}\n}\n","cpp":"class Solution {\npublic:\n    int largestRectangleArea(vector<int>& heights) {\n        \n    }\n};\n","java":"class Solution {\n    public int largestRectangleArea(int[] heights) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LargestRectangleArea(int[] heights) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/zx5Sw9130L0"},{"id":"binary-search","name":"Binary Search","description":"You are given an array of **distinct** integers `nums`, sorted in ascending order, and an integer `target`.\n    \nImplement a function to search for `target` within `nums`. If it exists, then return its index, otherwise, return `-1`.\n\nYour solution must run in $O(log n)$ time.\n\n**Example 1:**\n\n```java\nInput: nums = [-1,0,2,4,6,8], target = 4\n\nOutput: 3\n```\n\n**Example 2:**\n\n```java\nInput: nums = [-1,0,2,4,6,8], target = 3\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10000`.\n* `-10000 < nums[i], target < 10000`\n","difficulty":"Easy","concepts":["Search Array"],"solutions":{"python":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        l, r = 0, len(nums) - 1\n\n        while l <= r:\n            m = l + ((r - l) // 2)  # (l + r) // 2 can lead to overflow\n            if nums[m] > target:\n                r = m - 1\n            elif nums[m] < target:\n                l = m + 1\n            else:\n                return m\n        return -1\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number}\n     */\n    search(nums, target) {\n        let l = 0;\n        let r = nums.length - 1;\n\n        while (l <= r) {\n            const m = l + Math.floor((r - l) / 2);\n            if (nums[m] > target) {\n                r = m - 1;\n            } else if (nums[m] < target) {\n                l = m + 1;\n            } else {\n                return m;\n            }\n        }\n        return -1;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        int l = 0, r = nums.size() - 1;\n\n        while (l <= r) {\n            int m = l + ((r - l) / 2);\n            if (nums[m] > target) {\n                r = m - 1;\n            } else if (nums[m] < target) {\n                l = m + 1;\n            } else {\n                return m;\n            }\n        }\n        return -1;\n    }\n};\n","java":"class Solution {\n    public int search(int[] nums, int target) {\n        int l = 0, r = nums.length - 1;\n\n        while (l <= r) {\n            int m = l + ((r - l) / 2);\n            if (nums[m] > target) {\n                r = m - 1;\n            } else if (nums[m] < target) {\n                l = m + 1;\n            } else {\n                return m;\n            }\n        }\n        return -1;\n    }\n}\n","csharp":"public class Solution {\n    public int Search(int[] nums, int target) {\n        int l = 0, r = nums.Length - 1;\n\n        while (l <= r) {\n            int m = l + ((r - l) / 2);\n            if (nums[m] > target) {\n                r = m - 1;\n            } else if (nums[m] < target) {\n                l = m + 1;\n            } else {\n                return m;\n            }\n        }\n        return -1;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def search(self, nums: List[int], target: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number}\n     */\n    search(nums, target) {}\n}\n","cpp":"class Solution {\npublic:\n    int search(vector<int>& nums, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public int search(int[] nums, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Search(int[] nums, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/s4DPM8ct1pI"},{"id":"search-2d-matrix","name":"Search 2D Matrix","description":"You are given an `m x n` 2-D integer array `matrix` and an integer `target`.\n\n* Each row in `matrix` is sorted in *non-decreasing* order.\n* The first integer of every row is greater than the last integer of the previous row.\n\nReturn `true` if `target` exists within `matrix` or `false` otherwise.\n\nCan you write a solution that runs in `O(log(m * n))` time?\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/7ca61f56-00d4-4fa0-26cf-56809028ac00/public)\n\n```java\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 10\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/f25f2085-ce04-4447-9cee-f0a66c32a300/public)\n\n```java\nInput: matrix = [[1,2,4,8],[10,11,12,13],[14,20,30,40]], target = 15\n\nOutput: false\n```\n\n**Constraints:**\n* `m == matrix.length`\n* `n == matrix[i].length`\n* `1 <= m, n <= 100`\n* `-10000 <= matrix[i][j], target <= 10000`\n","difficulty":"Medium","concepts":["Search Array"],"solutions":{"python":"class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ROWS, COLS = len(matrix), len(matrix[0])\n\n        top, bot = 0, ROWS - 1\n        while top <= bot:\n            row = (top + bot) // 2\n            if target > matrix[row][-1]:\n                top = row + 1\n            elif target < matrix[row][0]:\n                bot = row - 1\n            else:\n                break\n\n        if not (top <= bot):\n            return False\n        row = (top + bot) // 2\n        l, r = 0, COLS - 1\n        while l <= r:\n            m = (l + r) // 2\n            if target > matrix[row][m]:\n                l = m + 1\n            elif target < matrix[row][m]:\n                r = m - 1\n            else:\n                return True\n        return False\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} matrix\n     * @param {number} target\n     * @return {boolean}\n     */\n    searchMatrix(matrix, target) {\n        const ROWS = matrix.length;\n        const COLS = matrix[0].length;\n\n        let top = 0;\n        let bot = ROWS - 1;\n        while (top <= bot) {\n            const row = Math.floor((top + bot) / 2);\n            if (target > matrix[row][COLS - 1]) {\n                top = row + 1;\n            } else if (target < matrix[row][0]) {\n                bot = row - 1;\n            } else {\n                break;\n            }\n        }\n\n        if (!(top <= bot)) {\n            return false;\n        }\n        const row = Math.floor((top + bot) / 2);\n        let l = 0;\n        let r = COLS - 1;\n        while (l <= r) {\n            const m = Math.floor((l + r) / 2);\n            if (target > matrix[row][m]) {\n                l = m + 1;\n            } else if (target < matrix[row][m]) {\n                r = m - 1;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        int ROWS = matrix.size();\n        int COLS = matrix[0].size();\n\n        int top = 0, bot = ROWS - 1;\n        while (top <= bot) {\n            int row = (top + bot) / 2;\n            if (target > matrix[row][COLS - 1]) {\n                top = row + 1;\n            } else if (target < matrix[row][0]) {\n                bot = row - 1;\n            } else {\n                break;\n            }\n        }\n\n        if (!(top <= bot)) {\n            return false;\n        }\n        int row = (top + bot) / 2;\n        int l = 0, r = COLS - 1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (target > matrix[row][m]) {\n                l = m + 1;\n            } else if (target < matrix[row][m]) {\n                r = m - 1;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n","java":"class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        int ROWS = matrix.length;\n        int COLS = matrix[0].length;\n\n        int top = 0, bot = ROWS - 1;\n        while (top <= bot) {\n            int row = (top + bot) / 2;\n            if (target > matrix[row][COLS - 1]) {\n                top = row + 1;\n            } else if (target < matrix[row][0]) {\n                bot = row - 1;\n            } else {\n                break;\n            }\n        }\n\n        if (!(top <= bot)) {\n            return false;\n        }\n        int row = (top + bot) / 2;\n        int l = 0, r = COLS - 1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (target > matrix[row][m]) {\n                l = m + 1;\n            } else if (target < matrix[row][m]) {\n                r = m - 1;\n            } else {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n","csharp":"public class Solution {\n    public bool SearchMatrix(int[][] matrix, int target) {\n        int ROWS = matrix.Length;\n        int COLS = matrix[0].Length;\n\n        int top = 0, bot = ROWS - 1;\n        int row = 0;\n        while (top <= bot) {\n            row = (top + bot) / 2;\n            if (target > matrix[row][COLS - 1]) {\n                top = row + 1;\n            }\n            else if (target < matrix[row][0]) {\n                bot = row - 1;\n            }\n            else {\n                break;\n            }\n        }\n\n        if (!(top <= bot)) {\n            return false;\n        }\n\n        int l = 0, r = COLS - 1;\n        while (l <= r) {\n            int m = (l + r) / 2;\n            if (target > matrix[row][m]) {\n                l = m + 1;\n            }\n            else if (target < matrix[row][m]) {\n                r = m - 1;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def searchMatrix(self, matrix: List[List[int]], target: int) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} matrix\n     * @param {number} target\n     * @return {boolean}\n     */\n    searchMatrix(matrix, target) {}\n}\n","cpp":"class Solution {\npublic:\n    bool searchMatrix(vector<vector<int>>& matrix, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool SearchMatrix(int[][] matrix, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Ber2pi2C0j0"},{"id":"eating-bananas","name":"Eating Bananas","description":"You are given an integer array `piles` where `piles[i]` is the number of bananas in the `ith` pile. You are also given an integer `h`, which represents the number of hours you have to eat all the bananas.\n\nYou may decide your bananas-per-hour eating rate of `k`. Each hour, you may choose a pile of bananas and eats `k` bananas from that pile. If the pile has less than `k` bananas, you may finish eating the pile but you can not eat from another pile in the same hour.\n\nReturn the minimum integer `k` such that you can eat all the bananas within `h` hours.\n\n**Example 1:**\n\n```java\nInput: piles = [1,4,3,2], h = 9\n\nOutput: 2\n```\n\nExplanation: With an eating rate of 2, you can eat the bananas in 6 hours. With an eating rate of 1, you would need 10 hours to eat all the bananas (which exceeds h=9), thus the minimum eating rate is 2.\n\n**Example 2:**\n\n```java\nInput: piles = [25,10,23,4], h = 4\n\nOutput: 25\n```\n\n**Constraints:**\n* `1 <= piles.length <= 1,000`\n* `piles.length <= h <= 1,000,000`\n* `1 <= piles[i] <= 1,000,000,000`\n","difficulty":"Medium","concepts":["Search Array","Search Range"],"solutions":{"python":"class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        l, r = 1, max(piles)\n        res = r\n\n        while l <= r:\n            k = (l + r) // 2\n\n            totalTime = 0\n            for p in piles:\n                totalTime += math.ceil(float(p) / k)\n            if totalTime <= h:\n                res = k\n                r = k - 1\n            else:\n                l = k + 1\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} piles\n     * @param {number} h\n     * @return {number}\n     */\n    minEatingSpeed(piles, h) {\n        let l = 1;\n        let r = Math.max(...piles);\n        let res = r;\n\n        while (l <= r) {\n            const k = Math.floor((l + r) / 2);\n\n            let totalTime = 0;\n            for (const p of piles) {\n                totalTime += Math.ceil(p / k);\n            }\n            if (totalTime <= h) {\n                res = k;\n                r = k - 1;\n            } else {\n                l = k + 1;\n            }\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        int l = 1;\n        int r = *max_element(piles.begin(), piles.end());\n        int res = r;\n\n        while (l <= r) {\n            int k = (l + r) / 2;\n\n            long long totalTime = 0;\n            for (int p : piles) {\n                totalTime += ceil(static_cast<double>(p) / k);\n            }\n            if (totalTime <= h) {\n                res = k;\n                r = k - 1;\n            } else {\n                l = k + 1;\n            }\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        int l = 1;\n        int r = Arrays.stream(piles).max().getAsInt();\n        int res = r;\n\n        while (l <= r) {\n            int k = (l + r) / 2;\n\n            int totalTime = 0;\n            for (int p : piles) {\n                totalTime += Math.ceil((double) p / k);\n            }\n            if (totalTime <= h) {\n                res = k;\n                r = k - 1;\n            } else {\n                l = k + 1;\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int MinEatingSpeed(int[] piles, int h) {\n        int l = 1;\n        int r = piles.Max();\n        int res = r;\n\n        while (l <= r) {\n            int k = (l + r) / 2;\n\n            long totalTime = 0;\n            foreach (int p in piles) {\n                totalTime += (int)Math.Ceiling((double)p / k);\n            }\n            if (totalTime <= h) {\n                res = k;\n                r = k - 1;\n            } else {\n                l = k + 1;\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def minEatingSpeed(self, piles: List[int], h: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} piles\n     * @param {number} h\n     * @return {number}\n     */\n    minEatingSpeed(piles, h) {}\n}\n","cpp":"class Solution {\npublic:\n    int minEatingSpeed(vector<int>& piles, int h) {\n        \n    }\n};\n","java":"class Solution {\n    public int minEatingSpeed(int[] piles, int h) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MinEatingSpeed(int[] piles, int h) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/U2SozAs9RzA"},{"id":"time-based-key-value-store","name":"Time Based Key-Value Store","description":"Implement a time-based key-value data structure that supports:\n \n* Storing multiple values for the same key at specified time stamps\n* Retrieving the key's value at a specified timestamp\n\nImplement the `TimeMap` class:\n* `TimeMap()` Initializes the object.\n* `void set(String key, String value, int timestamp)` Stores the key `key` with the value `value` at the given time `timestamp`.\n* `String get(String key, int timestamp)` Returns the most recent value of `key` if `set` was previously called on it *and* the most recent timestamp for that key `prev_timestamp` is less than or equal to the given timestamp (`prev_timestamp <= timestamp`). If there are no values, it returns `\"\"`.\n\nNote: For all calls to `set`, the timestamps are in strictly increasing order.\n\n**Example 1:**\n\n```java\nInput:\n[\"TimeMap\", \"set\", [\"alice\", \"happy\", 1], \"get\", [\"alice\", 1], \"get\", [\"alice\", 2], \"set\", [\"alice\", \"sad\", 3], \"get\", [\"alice\", 3]]\n\nOutput:\n[null, null, \"happy\", \"happy\", null, \"sad\"]\n\nExplanation:\nTimeMap timeMap = new TimeMap();\ntimeMap.set(\"alice\", \"happy\", 1);  // store the key \"alice\" and value \"happy\" along with timestamp = 1.\ntimeMap.get(\"alice\", 1);           // return \"happy\"\ntimeMap.get(\"alice\", 2);           // return \"happy\", there is no value stored for timestamp 2, thus we return the value at timestamp 1.\ntimeMap.set(\"alice\", \"sad\", 3);    // store the key \"alice\" and value \"sad\" along with timestamp = 3.\ntimeMap.get(\"alice\", 3);           // return \"sad\"\n```\n\n**Constraints:**\n* `1 <= key.length, value.length <= 100`\n* `key` and `value` only include lowercase English letters and digits.\n* `1 <= timestamp <= 1000`\n","difficulty":"Medium","concepts":["Hash Usage","Search Array"],"solutions":{"python":"class TimeMap:\n\n    def __init__(self):\n        self.keyStore = {}  # key : list of [val, timestamp]\n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        if key not in self.keyStore:\n            self.keyStore[key] = []\n        self.keyStore[key].append([value, timestamp])\n\n    def get(self, key: str, timestamp: int) -> str:\n        res, values = \"\", self.keyStore.get(key, [])\n        l, r = 0, len(values) - 1\n        while l <= r:\n            m = (l + r) // 2\n            if values[m][1] <= timestamp:\n                res = values[m][0]\n                l = m + 1\n            else:\n                r = m - 1\n        return res\n","javascript":"class TimeMap {\n    constructor() {\n        this.keyStore = new Map();\n    }\n\n    /**\n     * @param {string} key\n     * @param {string} value\n     * @param {number} timestamp\n     * @return {void}\n     */\n    set(key, value, timestamp) {\n        if (!this.keyStore.has(key)) {\n            this.keyStore.set(key, []);\n        }\n        this.keyStore.get(key).push([timestamp, value]);\n    }\n\n    /**\n     * @param {string} key\n     * @param {number} timestamp\n     * @return {string}\n     */\n    get(key, timestamp) {\n        const values = this.keyStore.get(key) || [];\n        let left = 0;\n        let right = values.length - 1;\n        let result = '';\n\n        while (left <= right) {\n            const mid = Math.floor((left + right) / 2);\n            if (values[mid][0] <= timestamp) {\n                result = values[mid][1];\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n}\n","cpp":"class TimeMap {\nprivate:\n    unordered_map<string, vector<pair<int, string>>> keyStore;\n\npublic:\n    TimeMap() {}\n\n    void set(string key, string value, int timestamp) {\n        keyStore[key].emplace_back(timestamp, value);\n    }\n\n    string get(string key, int timestamp) {\n        auto& values = keyStore[key];\n        int left = 0, right = values.size() - 1;\n        string result = \"\";\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (values[mid].first <= timestamp) {\n                result = values[mid].second;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n};\n","java":"class TimeMap {\n    \n    private Map<String, List<Pair<Integer, String>>> keyStore;\n\n    public TimeMap() {\n        keyStore = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        keyStore.computeIfAbsent(key, k -> new ArrayList<>()).add(new Pair<>(timestamp, value));\n    }\n\n    public String get(String key, int timestamp) {\n        List<Pair<Integer, String>> values = keyStore.getOrDefault(key, new ArrayList<>());\n        int left = 0, right = values.size() - 1;\n        String result = \"\";\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (values.get(mid).getKey() <= timestamp) {\n                result = values.get(mid).getValue();\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n\n    private static class Pair<K, V> {\n        private final K key;\n        private final V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n}\n","csharp":"public class TimeMap {\n    \n    private Dictionary<string, List<Tuple<int, string>>> keyStore;\n\n    public TimeMap() {\n        keyStore = new Dictionary<string, List<Tuple<int, string>>>();\n    }\n\n    public void Set(string key, string value, int timestamp) {\n        if (!keyStore.ContainsKey(key)) {\n            keyStore[key] = new List<Tuple<int, string>>();\n        }\n        keyStore[key].Add(Tuple.Create(timestamp, value));\n    }\n\n    public string Get(string key, int timestamp) {\n        if (!keyStore.ContainsKey(key)) {\n            return \"\";\n        }\n\n        var values = keyStore[key];\n        int left = 0, right = values.Count - 1;\n        string result = \"\";\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (values[mid].Item1 <= timestamp) {\n                result = values[mid].Item2;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return result;\n    }\n}\n"},"starterCode":{"python":"class TimeMap:\n\n    def __init__(self):\n        \n\n    def set(self, key: str, value: str, timestamp: int) -> None:\n        \n\n    def get(self, key: str, timestamp: int) -> str:\n        \n","javascript":"class TimeMap {\n    constructor() {\n        this.keyStore = new Map();\n    }\n\n    /**\n     * @param {string} key\n     * @param {string} value\n     * @param {number} timestamp\n     * @return {void}\n     */\n    set(key, value, timestamp) {}\n\n    /**\n     * @param {string} key\n     * @param {number} timestamp\n     * @return {string}\n     */\n    get(key, timestamp) {}\n}\n","cpp":"class TimeMap {\npublic:\n    TimeMap() {\n        \n    }\n    \n    void set(string key, string value, int timestamp) {\n        \n    }\n    \n    string get(string key, int timestamp) {\n        \n    }\n};\n","java":"class TimeMap {\n\n    public TimeMap() {\n        \n    }\n    \n    public void set(String key, String value, int timestamp) {\n        \n    }\n    \n    public String get(String key, int timestamp) {\n        \n    }\n}\n","csharp":"public class TimeMap {\n\n    public TimeMap() {\n        \n    }\n    \n    public void Set(string key, string value, int timestamp) {\n        \n    }\n    \n    public string Get(string key, int timestamp) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/fu2cD_6E8Hw"},{"id":"median-of-two-sorted-arrays","name":"Median of Two Sorted Arrays","description":"You are given two integer arrays `nums1` and `nums2` of size `m` and `n` respectively, where each is sorted in ascending order. Return the [median](https://en.wikipedia.org/wiki/Median) value among all elements of the two arrays.\n\nYour solution must run in $O(log (m+n))$ time.\n\n**Example 1:**\n\n```java\nInput: nums1 = [1,2], nums2 = [3]\n\nOutput: 2.0\n```\n\nExplanation: Among `[1, 2, 3]` the median is 2.\n\n**Example 2:**\n\n```java\nInput: nums1 = [1,3], nums2 = [2,4]\n\nOutput: 2.5\n```\n\nExplanation: Among `[1, 2, 3, 4]` the median is (2 + 3) / 2 = 2.5.\n\n**Constraints:**\n* `nums1.length == m`\n* `nums2.length == n`\n* `0 <= m <= 1000`\n* `0 <= n <= 1000`\n* `-10^6 <= nums1[i], nums2[i] <= 10^6`\n","difficulty":"Hard","concepts":["Search Array"],"solutions":{"python":"class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        A, B = nums1, nums2\n        total = len(nums1) + len(nums2)\n        half = total // 2\n\n        if len(B) < len(A):\n            A, B = B, A\n\n        l, r = 0, len(A) - 1\n        while True:\n            i = (l + r) // 2\n            j = half - i - 2\n\n            Aleft = A[i] if i >= 0 else float(\"-infinity\")\n            Aright = A[i + 1] if (i + 1) < len(A) else float(\"infinity\")\n            Bleft = B[j] if j >= 0 else float(\"-infinity\")\n            Bright = B[j + 1] if (j + 1) < len(B) else float(\"infinity\")\n\n            if Aleft <= Bright and Bleft <= Aright:\n                if total % 2:\n                    return min(Aright, Bright)\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2\n            elif Aleft > Bright:\n                r = i - 1\n            else:\n                l = i + 1\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums1\n     * @param {number[]} nums2\n     * @return {number}\n     */\n    findMedianSortedArrays(nums1, nums2) {\n        let A = nums1;\n        let B = nums2;\n        const total = A.length + B.length;\n        const half = Math.floor((total + 1) / 2);\n\n        if (B.length < A.length) {\n            [A, B] = [B, A];\n        }\n\n        let l = 0;\n        let r = A.length;\n        while (l <= r) {\n            const i = Math.floor((l + r) / 2);\n            const j = half - i;\n\n            const Aleft = i > 0 ? A[i - 1] : Number.MIN_SAFE_INTEGER;\n            const Aright = i < A.length ? A[i] : Number.MAX_SAFE_INTEGER;\n            const Bleft = j > 0 ? B[j - 1] : Number.MIN_SAFE_INTEGER;\n            const Bright = j < B.length ? B[j] : Number.MAX_SAFE_INTEGER;\n\n            if (Aleft <= Bright && Bleft <= Aright) {\n                if (total % 2 !== 0) {\n                    return Math.max(Aleft, Bleft);\n                }\n                return (Math.max(Aleft, Bleft) + Math.min(Aright, Bright)) / 2;\n            } else if (Aleft > Bright) {\n                r = i - 1;\n            } else {\n                l = i + 1;\n            }\n        }\n        return -1;\n    }\n}\n","cpp":"class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        vector<int>& A = nums1;\n        vector<int>& B = nums2;\n        int total = A.size() + B.size();\n        int half = (total + 1) / 2;\n\n        if (B.size() < A.size()) {\n            swap(A, B);\n        }\n\n        int l = 0;\n        int r = A.size();\n        while (l <= r) {\n            int i = (l + r) / 2;\n            int j = half - i;\n\n            int Aleft = i > 0 ? A[i - 1] : INT_MIN;\n            int Aright = i < A.size() ? A[i] : INT_MAX;\n            int Bleft = j > 0 ? B[j - 1] : INT_MIN;\n            int Bright = j < B.size() ? B[j] : INT_MAX;\n\n            if (Aleft <= Bright && Bleft <= Aright) {\n                if (total % 2 != 0) {\n                    return max(Aleft, Bleft);\n                }\n                return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0;\n            } else if (Aleft > Bright) {\n                r = i - 1;\n            } else {\n                l = i + 1;\n            }\n        }\n        return -1;\n    }\n};\n","java":"public class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        int[] A = nums1;\n        int[] B = nums2;\n        int total = A.length + B.length;\n        int half = (total + 1) / 2;\n\n        if (B.length < A.length) {\n            int[] temp = A;\n            A = B;\n            B = temp;\n        }\n\n        int l = 0;\n        int r = A.length;\n        while (l <= r) {\n            int i = (l + r) / 2;\n            int j = half - i;\n\n            int Aleft = i > 0 ? A[i - 1] : Integer.MIN_VALUE;\n            int Aright = i < A.length ? A[i] : Integer.MAX_VALUE;\n            int Bleft = j > 0 ? B[j - 1] : Integer.MIN_VALUE;\n            int Bright = j < B.length ? B[j] : Integer.MAX_VALUE;\n\n            if (Aleft <= Bright && Bleft <= Aright) {\n                if (total % 2 != 0) {\n                    return Math.max(Aleft, Bleft);\n                }\n                return (Math.max(Aleft, Bleft) + Math.min(Aright, Bright)) / 2.0;\n            } else if (Aleft > Bright) {\n                r = i - 1;\n            } else {\n                l = i + 1;\n            }\n        }\n        return -1;\n    }\n}\n","csharp":"public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        int[] A = nums1;\n        int[] B = nums2;\n        int total = A.Length + B.Length;\n        int half = (total + 1) / 2;\n\n        if (B.Length < A.Length) {\n            int[] temp = A;\n            A = B;\n            B = temp;\n        }\n\n        int l = 0;\n        int r = A.Length;\n        while (l <= r) {\n            int i = (l + r) / 2;\n            int j = half - i;\n\n            int Aleft = i > 0 ? A[i - 1] : int.MinValue;\n            int Aright = i < A.Length ? A[i] : int.MaxValue;\n            int Bleft = j > 0 ? B[j - 1] : int.MinValue;\n            int Bright = j < B.Length ? B[j] : int.MaxValue;\n\n            if (Aleft <= Bright && Bleft <= Aright) {\n                if (total % 2 != 0) {\n                    return Math.Max(Aleft, Bleft);\n                }\n                return (Math.Max(Aleft, Bleft) + Math.Min(Aright, Bright)) / 2.0;\n            }\n            else if (Aleft > Bright) {\n                r = i - 1;\n            }\n            else {\n                l = i + 1;\n            }\n        }\n        return -1;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums1\n     * @param {number[]} nums2\n     * @return {number}\n     */\n    findMedianSortedArrays(nums1, nums2) {}\n}\n","cpp":"class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        \n    }\n};\n","java":"class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public double FindMedianSortedArrays(int[] nums1, int[] nums2) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/q6IEA26hvXc"},{"id":"copy-linked-list-with-random-pointer","name":"Copy Linked List with Random Pointer","description":"You are given the head of a linked list of length `n`. Unlike a singly linked list, each node contains an additional pointer `random`, which may point to any node in the list, or `null`.\n\nCreate a **deep copy** of the list. \n\nThe deep copy should consist of exactly `n` **new** nodes, each including:\n* The original value `val` of the copied node\n* A `next` pointer to the new node corresponding to the `next` pointer of the original node\n* A `random` pointer to the new node corresponding to the `random` pointer of the original node\n\nNote: None of the pointers in the new list should point to nodes in the original list.\n\n*Return the head of the copied linked list.*\n\nIn the examples, the linked list is represented as a list of `n` nodes. Each node is represented as a pair of `[val, random_index]` where `random_index` is the index of the node (0-indexed) that the `random` pointer points to, or `null` if it does not point to any node.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5a5c2bdd-51e2-4795-4544-096af4b6cc00/public)\n\n```java\nInput: head = [[3,null],[7,3],[4,0],[5,1]]\n\nOutput: [[3,null],[7,3],[4,0],[5,1]]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/6e56fa98-cf1e-4ca6-18d4-716dac4ba900/public)\n\n```java\nInput: head = [[1,null],[2,2],[3,2]]\n\nOutput: [[1,null],[2,2],[3,2]]\n```\n\n**Constraints:**\n* `0 <= n <= 100`\n* `-100 <= Node.val <= 100`\n* `random` is `null` or is pointing to some node in the linked list.\n","difficulty":"Medium","concepts":["Singly Linked Lists","Doubly Linked Lists","Hash Usage"],"solutions":{"python":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        oldToCopy = {None: None}\n\n        cur = head\n        while cur:\n            copy = Node(cur.val)\n            oldToCopy[cur] = copy\n            cur = cur.next\n        cur = head\n        while cur:\n            copy = oldToCopy[cur]\n            copy.next = oldToCopy[cur.next]\n            copy.random = oldToCopy[cur.random]\n            cur = cur.next\n        return oldToCopy[head]\n","javascript":"// class Node {\n//   constructor(val, next = null, random = null) {\n//       this.val = val;\n//       this.next = next;\n//       this.random = random;\n//   }\n// }\n\nclass Solution {\n    /**\n     * @param {Node} head\n     * @return {Node}\n     */\n    copyRandomList(head) {\n        const oldToCopy = new Map();\n        oldToCopy.set(null, null);\n\n        let cur = head;\n        while (cur) {\n            const copy = new Node(cur.val);\n            oldToCopy.set(cur, copy);\n            cur = cur.next;\n        }\n\n        cur = head;\n        while (cur) {\n            const copy = oldToCopy.get(cur);\n            copy.next = oldToCopy.get(cur.next);\n            copy.random = oldToCopy.get(cur.random);\n            cur = cur.next;\n        }\n\n        return oldToCopy.get(head);\n    }\n}\n","cpp":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        map<Node*, Node*> oldToCopy;\n        oldToCopy[NULL] = NULL;\n\n        Node* cur = head;\n        while (cur != NULL) {\n            Node* copy = new Node(cur->val);\n            oldToCopy[cur] = copy;\n            cur = cur->next;\n        }\n\n        cur = head;\n        while (cur != NULL) {\n            Node* copy = oldToCopy[cur];\n            copy->next = oldToCopy[cur->next];\n            copy->random = oldToCopy[cur->random];\n            cur = cur->next;\n        }\n\n        return oldToCopy[head];\n    }\n};\n","java":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        Map<Node, Node> oldToCopy = new HashMap<>();\n        oldToCopy.put(null, null);\n\n        Node cur = head;\n        while (cur != null) {\n            Node copy = new Node(cur.val);\n            oldToCopy.put(cur, copy);\n            cur = cur.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            Node copy = oldToCopy.get(cur);\n            copy.next = oldToCopy.get(cur.next);\n            copy.random = oldToCopy.get(cur.random);\n            cur = cur.next;\n        }\n\n        return oldToCopy.get(head);\n    }\n}\n","csharp":"/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class Solution {\n    public Node copyRandomList(Node head) {\n        Dictionary<Node, Node> oldToCopy = new Dictionary<Node, Node>();\n\n        Node cur = head;\n        while (cur != null) {\n            Node copy = new Node(cur.val);\n            oldToCopy[cur] = copy;\n            cur = cur.next;\n        }\n\n        cur = head;\n        while (cur != null) {\n            Node copy = oldToCopy[cur];\n            copy.next = cur.next != null ? oldToCopy[cur.next] : null;\n            copy.random = cur.random != null ? oldToCopy[cur.random] : null;\n            cur = cur.next;\n        }\n\n        return head != null ? oldToCopy[head] : null;\n    }\n}\n"},"starterCode":{"python":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):\n        self.val = int(x)\n        self.next = next\n        self.random = random\n\"\"\"\n\nclass Solution:\n    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':\n        ","javascript":"// class Node {\n//   constructor(val, next = null, random = null) {\n//       this.val = val;\n//       this.next = next;\n//       this.random = random;\n//   }\n// }\n\nclass Solution {\n    /**\n     * @param {Node} head\n     * @return {Node}\n     */\n    copyRandomList(head) {}\n}\n","cpp":"/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    Node* copyRandomList(Node* head) {\n        \n    }\n};\n","java":"/*\n// Definition for a Node.\nclass Node {\n    int val;\n    Node next;\n    Node random;\n\n    public Node(int val) {\n        this.val = val;\n        this.next = null;\n        this.random = null;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        \n    }\n}\n","csharp":"/*\n// Definition for a Node.\npublic class Node {\n    public int val;\n    public Node next;\n    public Node random;\n    \n    public Node(int _val) {\n        val = _val;\n        next = null;\n        random = null;\n    }\n}\n*/\n\npublic class Solution {\n    public Node copyRandomList(Node head) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/5Y2EiZST97Y"},{"id":"add-two-numbers","name":"Add Two Numbers","description":"You are given two **non-empty** linked lists, `l1` and `l2`, where each represents a non-negative integer.\n    \nThe digits are stored in **reverse order**, e.g. the number 123 is represented as `3 -> 2 -> 1 ->` in the linked list.\n\nEach of the nodes contains a single digit. You may assume the two numbers do not contain any leading zero, except the number 0 itself.\n\nReturn the sum of the two numbers as a linked list.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fee72e19-6a21-45a5-365e-3cb45aba9700/public)\n\n```java\nInput: l1 = [1,2,3], l2 = [4,5,6]\n\nOutput: [5,7,9]\n\nExplanation: 321 + 654 = 975.\n```\n\n**Example 2:**\n\n```java\nInput: l1 = [9], l2 = [9]\n\nOutput: [8,1]\n```\n\n**Constraints:**\n* `1 <= l1.length, l2.length <= 100`.\n* `0 <= Node.val <= 9`\n","difficulty":"Medium","concepts":["Singly Linked Lists"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        dummy = ListNode()\n        cur = dummy\n\n        carry = 0\n        while l1 or l2 or carry:\n            v1 = l1.val if l1 else 0\n            v2 = l2.val if l2 else 0\n\n            # new digit\n            val = v1 + v2 + carry\n            carry = val // 10\n            val = val % 10\n            cur.next = ListNode(val)\n\n            # update ptrs\n            cur = cur.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n\n        return dummy.next\n ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} l1\n     * @param {ListNode} l2\n     * @return {ListNode}\n     */\n    addTwoNumbers(l1, l2) {\n        const dummy = new ListNode();\n        let cur = dummy;\n\n        let carry = 0;\n        while (l1 || l2 || carry) {\n            const v1 = l1 ? l1.val : 0;\n            const v2 = l2 ? l2.val : 0;\n\n            let val = v1 + v2 + carry;\n            carry = Math.floor(val / 10);\n            val = val % 10;\n            cur.next = new ListNode(val);\n\n            cur = cur.next;\n            l1 = l1 ? l1.next : null;\n            l2 = l2 ? l2.next : null;\n        }\n\n        return dummy.next;\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        ListNode* dummy = new ListNode();\n        ListNode* cur = dummy;\n\n        int carry = 0;\n        while (l1 != nullptr || l2 != nullptr || carry != 0) {\n            int v1 = (l1 != nullptr) ? l1->val : 0;\n            int v2 = (l2 != nullptr) ? l2->val : 0;\n\n            int val = v1 + v2 + carry;\n            carry = val / 10;\n            val = val % 10;\n            cur->next = new ListNode(val);\n\n            cur = cur->next;\n            l1 = (l1 != nullptr) ? l1->next : nullptr;\n            l2 = (l2 != nullptr) ? l2->next : nullptr;\n        }\n\n        return dummy->next;\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\n class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int v1 = (l1 != null) ? l1.val : 0;\n            int v2 = (l2 != null) ? l2.val : 0;\n\n            int val = v1 + v2 + carry;\n            carry = val / 10;\n            val = val % 10;\n            cur.next = new ListNode(val);\n\n            cur = cur.next;\n            l1 = (l1 != null) ? l1.next : null;\n            l2 = (l2 != null) ? l2.next : null;\n        }\n\n        return dummy.next;\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode cur = dummy;\n\n        int carry = 0;\n        while (l1 != null || l2 != null || carry != 0) {\n            int v1 = (l1 != null) ? l1.val : 0;\n            int v2 = (l2 != null) ? l2.val : 0;\n\n            int val = v1 + v2 + carry;\n            carry = val / 10;\n            val = val % 10;\n            cur.next = new ListNode(val);\n\n            cur = cur.next;\n            l1 = (l1 != null) ? l1.next : null;\n            l2 = (l2 != null) ? l2.next : null;\n        }\n\n        return dummy.next;\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} l1\n     * @param {ListNode} l2\n     * @return {ListNode}\n     */\n    addTwoNumbers(l1, l2) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode AddTwoNumbers(ListNode l1, ListNode l2) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/wgFPrzTjm7s"},{"id":"find-duplicate-integer","name":"Find Duplicate Integer","description":"You are given an array of integers `nums` containing `n + 1` integers. Each integer in `nums` is in the range `[1, n]` inclusive.\n\nEvery integer appears **exactly once**, except for one integer which appears **two or more times**. Return the integer that appears more than once.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3,2,2]\n\nOutput: 2\n```\n\n**Example 2:**\n\n```java\nInput: nums = [1,2,3,4,4]\n\nOutput: 4\n```\n\nFollow-up: Can you solve the problem **without** modifying the array `nums` and using $O(1)$ extra space?\n\n**Constraints:**\n* `1 <= n <= 10000`\n* `nums.length == n + 1`\n* `1 <= nums[i] <= n`\n","difficulty":"Medium","concepts":["Singly Linked Lists","Fast and Slow Pointers"],"solutions":{"python":"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        slow, fast = 0, 0\n        while True:\n            slow = nums[slow]\n            fast = nums[nums[fast]]\n            if slow == fast:\n                break\n\n        slow2 = 0\n        while True:\n            slow = nums[slow]\n            slow2 = nums[slow2]\n            if slow == slow2:\n                return slow\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    findDuplicate(nums) {\n        let slow = 0;\n        let fast = 0;\n        while (true) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n            if (slow === fast) {\n                break;\n            }\n        }\n\n        let slow2 = 0;\n        while (true) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n            if (slow === slow2) {\n                return slow;\n            }\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        int slow = 0, fast = 0;\n        while (true) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n            if (slow == fast) {\n                break;\n            }\n        }\n\n        int slow2 = 0;\n        while (true) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n            if (slow == slow2) {\n                return slow;\n            }\n        }\n    }\n};\n","java":"class Solution {\n    public int findDuplicate(int[] nums) {\n        int slow = 0, fast = 0;\n        while (true) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n            if (slow == fast) {\n                break;\n            }\n        }\n\n        int slow2 = 0;\n        while (true) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n            if (slow == slow2) {\n                return slow;\n            }\n        }\n    }\n}\n","csharp":"public class Solution {\n    public int FindDuplicate(int[] nums) {\n        int slow = 0, fast = 0;\n        while (true) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n            if (slow == fast) {\n                break;\n            }\n        }\n\n        int slow2 = 0;\n        while (true) {\n            slow = nums[slow];\n            slow2 = nums[slow2];\n            if (slow == slow2) {\n                return slow;\n            }\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    findDuplicate(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int findDuplicate(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int findDuplicate(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int FindDuplicate(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/wjYnzkAhcNk"},{"id":"lru-cache","name":"LRU Cache","description":"Implement the [Least Recently Used (LRU)](https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU) cache class `LRUCache`. The class should support the following operations\n\n* `LRUCache(int capacity)` Initialize the LRU cache of size `capacity`.\n* `int get(int key)` Return the value cooresponding to the `key` if the `key` exists, otherwise return `-1`.\n* `void put(int key, int value)` Update the `value` of the `key` if the `key` exists. Otherwise, add the `key`-`value` pair to the cache. If the introduction of the new pair causes the cache to exceed its capacity, remove the least recently used key.\n\nA key is considered used if a `get` or a `put` operation is called on it.\n\nEnsure that `get` and `put` each run in $O(1)$ average time complexity.\n\n**Example 1:**\n\n```java\nInput:\n[\"LRUCache\", [2], \"put\", [1, 10],  \"get\", [1], \"put\", [2, 20], \"put\", [3, 30], \"get\", [2], \"get\", [1]]\n\nOutput:\n[null, null, 10, null, null, 20, -1]\n\nExplanation:\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 10);  // cache: {1=10}\nlRUCache.get(1);      // return 10\nlRUCache.put(2, 20);  // cache: {1=10, 2=20}\nlRUCache.put(3, 30);  // cache: {2=20, 3=30}, key=1 was evicted\nlRUCache.get(2);      // returns 20 \nlRUCache.get(1);      // return -1 (not found)\n```\n\n**Constraints:**\n* `1 <= capacity <= 100`\n* `0 <= key <= 1000`\n* `0 <= value <= 1000`\n","difficulty":"Medium","concepts":["Singly Linked Lists","Doubly Linked Lists","Hash Usage"],"solutions":{"python":"class Node:\n    def __init__(self, key, val):\n        self.key, self.val = key, val\n        self.prev = self.next = None\n\n\nclass LRUCache:\n    def __init__(self, capacity: int):\n        self.cap = capacity\n        self.cache = {}  # map key to node\n\n        self.left, self.right = Node(0, 0), Node(0, 0)\n        self.left.next, self.right.prev = self.right, self.left\n\n    def remove(self, node):\n        prev, nxt = node.prev, node.next\n        prev.next, nxt.prev = nxt, prev\n\n    def insert(self, node):\n        prev, nxt = self.right.prev, self.right\n        prev.next = nxt.prev = node\n        node.next, node.prev = nxt, prev\n\n    def get(self, key: int) -> int:\n        if key in self.cache:\n            self.remove(self.cache[key])\n            self.insert(self.cache[key])\n            return self.cache[key].val\n        return -1\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            self.remove(self.cache[key])\n        self.cache[key] = Node(key, value)\n        self.insert(self.cache[key])\n\n        if len(self.cache) > self.cap:\n            lru = self.left.next\n            self.remove(lru)\n            del self.cache[lru.key]\n","javascript":"class Node {\n    constructor(key, val) {\n        this.key = key;\n        this.val = val;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass LRUCache {\n    /**\n     * @param {number} capacity\n     */\n    constructor(capacity) {\n        this.cap = capacity;\n        this.cache = new Map();\n        this.left = new Node(0, 0);\n        this.right = new Node(0, 0);\n        this.left.next = this.right;\n        this.right.prev = this.left;\n    }\n\n    /**\n     * @param {Node} node\n     */\n    remove(node) {\n        const prev = node.prev;\n        const nxt = node.next;\n        prev.next = nxt;\n        nxt.prev = prev;\n    }\n\n    /**\n     * @param {Node} node\n     */\n    insert(node) {\n        const prev = this.right.prev;\n        prev.next = node;\n        node.prev = prev;\n        node.next = this.right;\n        this.right.prev = node;\n    }\n\n    /**\n     * @param {number} key\n     * @return {number}\n     */\n    get(key) {\n        if (this.cache.has(key)) {\n            const node = this.cache.get(key);\n            this.remove(node);\n            this.insert(node);\n            return node.val;\n        }\n        return -1;\n    }\n\n    /**\n     * @param {number} key\n     * @param {number} value\n     * @return {void}\n     */\n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.remove(this.cache.get(key));\n        }\n        const newNode = new Node(key, value);\n        this.cache.set(key, newNode);\n        this.insert(newNode);\n\n        if (this.cache.size > this.cap) {\n            const lru = this.left.next;\n            this.remove(lru);\n            this.cache.delete(lru.key);\n        }\n    }\n}\n","cpp":"class Node {\npublic:\n    int key;\n    int val;\n    Node* prev;\n    Node* next;\n\n    Node(int k, int v) : key(k), val(v), prev(nullptr), next(nullptr) {}\n};\n\nclass LRUCache {\nprivate:\n    int cap;\n    unordered_map<int, Node*> cache;\n    Node* left;\n    Node* right;\n\n    void remove(Node* node) {\n        Node* prev = node->prev;\n        Node* nxt = node->next;\n        prev->next = nxt;\n        nxt->prev = prev;\n    }\n\n    void insert(Node* node) {\n        Node* prev = right->prev;\n        prev->next = node;\n        node->prev = prev;\n        node->next = right;\n        right->prev = node;\n    }\n\npublic:\n    LRUCache(int capacity) {\n        cap = capacity;\n        cache.clear();\n        left = new Node(0, 0);\n        right = new Node(0, 0);\n        left->next = right;\n        right->prev = left;\n    }\n\n    int get(int key) {\n        if (cache.find(key) != cache.end()) {\n            Node* node = cache[key];\n            remove(node);\n            insert(node);\n            return node->val;\n        }\n        return -1;\n    }\n\n    void put(int key, int value) {\n        if (cache.find(key) != cache.end()) {\n            remove(cache[key]);\n        }\n        Node* newNode = new Node(key, value);\n        cache[key] = newNode;\n        insert(newNode);\n\n        if (cache.size() > cap) {\n            Node* lru = left->next;\n            remove(lru);\n            cache.erase(lru->key);\n            delete lru;\n        }\n    }\n};\n","java":"class Node {\n    int key;\n    int val;\n    Node prev;\n    Node next;\n\n    public Node(int key, int val) {\n        this.key = key;\n        this.val = val;\n        this.prev = null;\n        this.next = null;\n    }\n}\n\nclass LRUCache {\n    \n    private int cap;\n    private HashMap<Integer, Node> cache;\n    private Node left;\n    private Node right;\n\n    public LRUCache(int capacity) {\n        this.cap = capacity;\n        this.cache = new HashMap<>();\n        this.left = new Node(0, 0);\n        this.right = new Node(0, 0);\n        this.left.next = this.right;\n        this.right.prev = this.left;\n    }\n\n    private void remove(Node node) {\n        Node prev = node.prev;\n        Node nxt = node.next;\n        prev.next = nxt;\n        nxt.prev = prev;\n    }\n\n    private void insert(Node node) {\n        Node prev = this.right.prev;\n        prev.next = node;\n        node.prev = prev;\n        node.next = this.right;\n        this.right.prev = node;\n    }\n\n    public int get(int key) {\n        if (cache.containsKey(key)) {\n            Node node = cache.get(key);\n            remove(node);\n            insert(node);\n            return node.val;\n        }\n        return -1;\n    }\n\n    public void put(int key, int value) {\n        if (cache.containsKey(key)) {\n            remove(cache.get(key));\n        }\n        Node newNode = new Node(key, value);\n        cache.put(key, newNode);\n        insert(newNode);\n\n        if (cache.size() > cap) {\n            Node lru = this.left.next;\n            remove(lru);\n            cache.remove(lru.key);\n        }\n    }\n}\n","csharp":"public class Node {\n    public int Key { get; set; }\n    public int Val { get; set; }\n    public Node Prev { get; set; }\n    public Node Next { get; set; }\n\n    public Node(int key, int val) {\n        Key = key;\n        Val = val;\n        Prev = null;\n        Next = null;\n    }\n}\n\npublic class LRUCache {\n    \n    private int cap;\n    private Dictionary<int, Node> cache;\n    private Node left;\n    private Node right;\n\n    public LRUCache(int capacity) {\n        cap = capacity;\n        cache = new Dictionary<int, Node>();\n        left = new Node(0, 0);\n        right = new Node(0, 0);\n        left.Next = right;\n        right.Prev = left;\n    }\n\n    private void Remove(Node node) {\n        Node prev = node.Prev;\n        Node nxt = node.Next;\n        prev.Next = nxt;\n        nxt.Prev = prev;\n    }\n\n    private void Insert(Node node) {\n        Node prev = right.Prev;\n        prev.Next = node;\n        node.Prev = prev;\n        node.Next = right;\n        right.Prev = node;\n    }\n\n    public int Get(int key) {\n        if (cache.ContainsKey(key)) {\n            Node node = cache[key];\n            Remove(node);\n            Insert(node);\n            return node.Val;\n        }\n        return -1;\n    }\n\n    public void Put(int key, int value) {\n        if (cache.ContainsKey(key)) {\n            Remove(cache[key]);\n        }\n        Node newNode = new Node(key, value);\n        cache[key] = newNode;\n        Insert(newNode);\n\n        if (cache.Count > cap) {\n            Node lru = left.Next;\n            Remove(lru);\n            cache.Remove(lru.Key);\n        }\n    }\n}\n"},"starterCode":{"python":"class LRUCache:\n\n    def __init__(self, capacity: int):\n        \n\n    def get(self, key: int) -> int:\n        \n\n    def put(self, key: int, value: int) -> None:\n        \n","javascript":"class LRUCache {\n    /**\n     * @param {number} capacity\n     */\n    constructor(capacity) {}\n\n    /**\n     * @param {number} key\n     * @return {number}\n     */\n    get(key) {}\n\n    /**\n     * @param {number} key\n     * @param {number} value\n     * @return {void}\n     */\n    put(key, value) {}\n}\n","cpp":"class LRUCache {\npublic:\n    LRUCache(int capacity) {\n        \n    }\n    \n    int get(int key) {\n        \n    }\n    \n    void put(int key, int value) {\n        \n    }\n};\n","java":"class LRUCache {\n\n    public LRUCache(int capacity) {\n        \n    }\n    \n    public int get(int key) {\n        \n    }\n    \n    public void put(int key, int value) {\n        \n    }\n}\n","csharp":"public class LRUCache {\n\n    public LRUCache(int capacity) {\n        \n    }\n    \n    public int Get(int key) {\n        \n    }\n    \n    public void Put(int key, int value) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/7ABFKPK2hD4"},{"id":"reverse-nodes-in-k-group","name":"Reverse Nodes in K-Group","description":"You are given the head of a singly linked list `head` and a positive integer `k`.\n\nYou must reverse the first `k` nodes in the linked list, and then reverse the next `k` nodes, and so on. If there are fewer than `k` nodes left, leave the nodes as they are.\n\nReturn the modified list after reversing the nodes in each group of `k`.\n\nYou are only allowed to modify the nodes' `next` pointers, not the values of the nodes.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/67cf2fff-f20a-4558-6091-c3e857f56e00/public)\n\n```java\nInput: head = [1,2,3,4,5,6], k = 3\n\nOutput: [3,2,1,6,5,4]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/af843e59-df12-4c55-652b-6ddab0a92900/public)\n\n```java\nInput: head = [1,2,3,4,5], k = 3\n\nOutput: [3,2,1,4,5]\n```\n\n**Constraints:**\n* The length of the linked list is `n`.\n* `1 <= k <= n <= 100`\n* `0 <= Node.val <= 100`\n","difficulty":"Hard","concepts":["Singly Linked Lists"],"solutions":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        dummy = ListNode(0, head)\n        groupPrev = dummy\n\n        while True:\n            kth = self.getKth(groupPrev, k)\n            if not kth:\n                break\n            groupNext = kth.next\n\n            prev, curr = kth.next, groupPrev.next\n            while curr != groupNext:\n                tmp = curr.next\n                curr.next = prev\n                prev = curr\n                curr = tmp\n\n            tmp = groupPrev.next\n            groupPrev.next = kth\n            groupPrev = tmp\n        return dummy.next\n\n    def getKth(self, curr, k):\n        while curr and k > 0:\n            curr = curr.next\n            k -= 1\n        return curr\n","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @param {number} k\n     * @return {ListNode}\n     */\n    reverseKGroup(head, k) {\n        const dummy = new ListNode(0, head);\n        let groupPrev = dummy;\n\n        while (true) {\n            const kth = this.getKth(groupPrev, k);\n            if (!kth) {\n                break;\n            }\n            const groupNext = kth.next;\n\n            let prev = kth.next;\n            let curr = groupPrev.next;\n            while (curr != groupNext) {\n                const tmp = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = tmp;\n            }\n\n            const tmp = groupPrev.next;\n            groupPrev.next = kth;\n            groupPrev = tmp;\n        }\n        return dummy.next;\n    }\n\n    getKth(curr, k) {\n        while (curr && k > 0) {\n            curr = curr.next;\n            k--;\n        }\n        return curr;\n    }\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        ListNode* dummy = new ListNode(0, head);\n        ListNode* groupPrev = dummy;\n\n        while (true) {\n            ListNode* kth = getKth(groupPrev, k);\n            if (!kth) {\n                break;\n            }\n            ListNode* groupNext = kth->next;\n\n            ListNode* prev = kth->next;\n            ListNode* curr = groupPrev->next;\n            while (curr != groupNext) {\n                ListNode* tmp = curr->next;\n                curr->next = prev;\n                prev = curr;\n                curr = tmp;\n            }\n\n            ListNode* tmp = groupPrev->next;\n            groupPrev->next = kth;\n            groupPrev = tmp;\n        }\n        return dummy->next;\n    }\n\nprivate:\n    ListNode* getKth(ListNode* curr, int k) {\n        while (curr && k > 0) {\n            curr = curr->next;\n            k--;\n        }\n        return curr;\n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    \n    public ListNode reverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode groupPrev = dummy;\n\n        while (true) {\n            ListNode kth = getKth(groupPrev, k);\n            if (kth == null) {\n                break;\n            }\n            ListNode groupNext = kth.next;\n\n            ListNode prev = kth.next;\n            ListNode curr = groupPrev.next;\n            while (curr != groupNext) {\n                ListNode tmp = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = tmp;\n            }\n\n            ListNode tmp = groupPrev.next;\n            groupPrev.next = kth;\n            groupPrev = tmp;\n        }\n        return dummy.next;\n    }\n\n    private ListNode getKth(ListNode curr, int k) {\n        while (curr != null && k > 0) {\n            curr = curr.next;\n            k--;\n        }\n        return curr;\n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode groupPrev = dummy;\n\n        while (true) {\n            ListNode kth = GetKth(groupPrev, k);\n            if (kth == null) {\n                break;\n            }\n            ListNode groupNext = kth.next;\n\n            ListNode prev = kth.next;\n            ListNode curr = groupPrev.next;\n            while (curr != groupNext) {\n                ListNode tmp = curr.next;\n                curr.next = prev;\n                prev = curr;\n                curr = tmp;\n            }\n\n            ListNode tmpNode = groupPrev.next;\n            groupPrev.next = kth;\n            groupPrev = tmpNode;\n        }\n        return dummy.next;\n    }\n\n    private ListNode GetKth(ListNode curr, int k) {\n        while (curr != null && k > 0) {\n            curr = curr.next;\n            k--;\n        }\n        return curr;\n    }\n}\n"},"starterCode":{"python":"# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def reverseKGroup(self, head: Optional[ListNode], k: int) -> Optional[ListNode]:\n        ","javascript":"/**\n * Definition for singly-linked list.\n * class ListNode {\n *     constructor(val = 0, next = null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {ListNode} head\n     * @param {number} k\n     * @return {ListNode}\n     */\n    reverseKGroup(head, k) {}\n}\n","cpp":"/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n\nclass Solution {\npublic:\n    ListNode* reverseKGroup(ListNode* head, int k) {\n        \n    }\n};\n","java":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode reverseKGroup(ListNode head, int k) {\n        \n    }\n}\n","csharp":"/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     public int val;\n *     public ListNode next;\n *     public ListNode(int val=0, ListNode next=null) {\n *         this.val = val;\n *         this.next = next;\n *     }\n * }\n */\n\npublic class Solution {\n    public ListNode ReverseKGroup(ListNode head, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/1UOPsfP85V4"},{"id":"binary-tree-diameter","name":"Binary Tree Diameter","description":"The **diameter** of a binary tree is defined as the **length** of the longest path between *any two nodes within the tree*. The path does not necessarily have to pass through the root.\n    \nThe **length** of a path between two nodes in a binary tree is the number of edges between the nodes.\n\nGiven the root of a binary tree `root`, return the **diameter** of the tree.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/90e1d7a0-4322-4c5d-c59b-dde2bf92bb00/public)\n\n```java\nInput: root = [1,null,2,3,4,5]\n\nOutput: 3\n```\n\nExplanation: 3 is the length of the path `[1,2,3,5]` or `[5,3,2,4]`.\n\n**Example 2:**\n\n```java\nInput: root = [1,2,3]\n\nOutput: 2\n```\n\n**Constraints:**\n* `1 <= number of nodes in the tree <= 100`\n* `-100 <= Node.val <= 100`\n","difficulty":"Easy","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        res = 0\n\n        def dfs(root):\n            nonlocal res\n\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            res = max(res, left + right)\n\n            return 1 + max(left, right)\n\n        dfs(root)\n        return res\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    diameterOfBinaryTree(root) {\n        const res = [0];\n        this.dfs(root, res);\n        return res[0];\n    }\n\n    /**\n     * @param {TreeNode} root\n     * @param {number[]} res\n     * @return {number}\n     */\n    dfs(root, res) {\n        if (root === null) {\n            return 0;\n        }\n        const left = this.dfs(root.left, res);\n        const right = this.dfs(root.right, res);\n        res[0] = Math.max(res[0], left + right);\n        return 1 + Math.max(left, right);\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int diameterOfBinaryTree(TreeNode* root) {\n        int res = 0;\n        dfs(root, res);\n        return res;\n    }\n\nprivate:\n    int dfs(TreeNode* root, int& res) {\n        if (!root) {\n            return 0;\n        }\n        int left = dfs(root->left, res);\n        int right = dfs(root->right, res);\n        res = max(res, left + right);\n        return 1 + max(left, right);\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    \n    public int diameterOfBinaryTree(TreeNode root) {\n        int[] res = new int[1];\n        dfs(root, res);\n        return res[0];\n    }\n\n    private int dfs(TreeNode root, int[] res) {\n        if (root == null) {\n            return 0;\n        }\n        int left = dfs(root.left, res);\n        int right = dfs(root.right, res);\n        res[0] = Math.max(res[0], left + right);\n        return 1 + Math.max(left, right);\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public int DiameterOfBinaryTree(TreeNode root) {\n        int res = 0;\n        DFS(root, ref res);\n        return res;\n    }\n\n    private int DFS(TreeNode root, ref int res) {\n        if (root == null) {\n            return 0;\n        }\n        int left = DFS(root.left, ref res);\n        int right = DFS(root.right, ref res);\n        res = Math.Max(res, left + right);\n        return 1 + Math.Max(left, right);\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    diameterOfBinaryTree(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int diameterOfBinaryTree(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int diameterOfBinaryTree(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int DiameterOfBinaryTree(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/K81C31ytOZE"},{"id":"balanced-binary-tree","name":"Balanced Binary Tree","description":"Given a binary tree, return `true` if it is **height-balanced** and `false` otherwise.\n\nA **height-balanced** binary tree is defined as a binary tree in which the left and right subtrees of every node differ in height by no more than 1.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c19c3727-ea28-416c-3873-79ee75f2b400/public)\n\n```java\nInput: root = [1,2,3,null,null,4]\n\nOutput: true\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/24fcc2da-e012-4f9e-856e-040f200f3c00/public)\n\n```java\nInput: root = [1,2,3,null,null,4,null,5]\n\nOutput: false\n```\n\n**Example 3:**\n\n```java\nInput: root = []\n\nOutput: true\n```\n\n**Constraints:**\n* The number of nodes in the tree is in the range `[0, 1000]`.\n* `-1000 <= Node.val <= 1000`\n","difficulty":"Easy","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        def dfs(root):\n            if not root:\n                return [True, 0]\n\n            left, right = dfs(root.left), dfs(root.right)\n            balanced = left[0] and right[0] and abs(left[1] - right[1]) <= 1\n            return [balanced, 1 + max(left[1], right[1])]\n\n        return dfs(root)[0]\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {boolean}\n     */\n    isBalanced(root) {\n        return this.dfs(root)[0] === 1;\n    }\n\n    /**\n     * @param {TreeNode} root\n     * @return {number[]}\n     */\n    dfs(root) {\n        if (!root) {\n            return [1, 0];\n        }\n\n        const left = this.dfs(root.left);\n        const right = this.dfs(root.right);\n\n        const balanced =\n            left[0] === 1 &&\n            right[0] === 1 &&\n            Math.abs(left[1] - right[1]) <= 1;\n        const height = 1 + Math.max(left[1], right[1]);\n\n        return [balanced ? 1 : 0, height];\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        return dfs(root)[0] == 1;\n    }\n\nprivate:\n    vector<int> dfs(TreeNode* root) {\n        if (!root) {\n            return {1, 0};\n        }\n\n        vector<int> left = dfs(root->left);\n        vector<int> right = dfs(root->right);\n\n        bool balanced = left[0] == 1 && right[0] == 1 && abs(left[1] - right[1]) <= 1;\n        int height = 1 + max(left[1], right[1]);\n\n        return {balanced ? 1 : 0, height};\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    \n    public boolean isBalanced(TreeNode root) {\n        return dfs(root)[0] == 1;\n    }\n\n    private int[] dfs(TreeNode root) {\n        if (root == null) {\n            return new int[]{1, 0};\n        }\n\n        int[] left = dfs(root.left);\n        int[] right = dfs(root.right);\n\n        boolean balanced = left[0] == 1 && right[0] == 1 && Math.abs(left[1] - right[1]) <= 1;\n        int height = 1 + Math.max(left[1], right[1]);\n\n        return new int[]{balanced ? 1 : 0, height};\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public bool IsBalanced(TreeNode root) {\n        return Dfs(root)[0] == 1;\n    }\n\n    private int[] Dfs(TreeNode root) {\n        if (root == null) {\n            return new int[]{1, 0};\n        }\n\n        int[] left = Dfs(root.left);\n        int[] right = Dfs(root.right);\n\n        bool balanced = left[0] == 1 && right[0] == 1 && Math.Abs(left[1] - right[1]) <= 1;\n        int height = 1 + Math.Max(left[1], right[1]);\n\n        return new int[]{balanced ? 1 : 0, height};\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def isBalanced(self, root: Optional[TreeNode]) -> bool:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {boolean}\n     */\n    isBalanced(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    bool isBalanced(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public bool IsBalanced(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/QfJsau0ItOY"},{"id":"binary-tree-right-side-view","name":"Binary Tree Right Side View","description":"You are given the `root` of a binary tree. Return only the values of the nodes that are visible from the right side of the tree, ordered from top to bottom.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/d348893a-8917-456c-9599-c405cfc4e000/public)\n\n```java\nInput: root = [1,2,3]\n\nOutput: [1,3]\n```\n\n**Example 2:**\n\n```java\nInput: root = [1,2,3,4,5,6,7]\n\nOutput: [1,3,7]\n```\n\n**Constraints:**\n* `1 <= number of nodes in the tree <= 100`\n* `-100 <= Node.val <= 100`\n","difficulty":"Medium","concepts":["Breadth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        res = []\n        q = deque([root])\n\n        while q:\n            rightSide = None\n            qLen = len(q)\n\n            for i in range(qLen):\n                node = q.popleft()\n                if node:\n                    rightSide = node\n                    q.append(node.left)\n                    q.append(node.right)\n            if rightSide:\n                res.append(rightSide.val)\n        return res\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number[]}\n     */\n    rightSideView(root) {\n        const res = [];\n        const q = [];\n\n        q.push(root);\n\n        while (q.length > 0) {\n            let rightSide = null;\n            const qLen = q.length;\n\n            for (let i = 0; i < qLen; i++) {\n                const node = q.shift();\n                if (node) {\n                    rightSide = node;\n                    q.push(node.left);\n                    q.push(node.right);\n                }\n            }\n            if (rightSide) {\n                res.push(rightSide.val);\n            }\n        }\n        return res;\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        vector<int> res;\n        queue<TreeNode*> q;\n        q.push(root);\n\n        while (!q.empty()) {\n            TreeNode* rightSide = nullptr;\n            int qLen = q.size();\n\n            for (int i = 0; i < qLen; i++) {\n                TreeNode* node = q.front();\n                q.pop();\n                if (node) {\n                    rightSide = node;\n                    q.push(node->left);\n                    q.push(node->right);\n                }\n            }\n            if (rightSide) {\n                res.push_back(rightSide->val);\n            }\n        }\n        return res;\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> res = new ArrayList<>();\n        Queue<TreeNode> q = new LinkedList<>();\n        q.offer(root);\n\n        while (!q.isEmpty()) {\n            TreeNode rightSide = null;\n            int qLen = q.size();\n\n            for (int i = 0; i < qLen; i++) {\n                TreeNode node = q.poll();\n                if (node != null) {\n                    rightSide = node;\n                    q.offer(node.left);\n                    q.offer(node.right);\n                }\n            }\n            if (rightSide != null) {\n                res.add(rightSide.val);\n            }\n        }\n        return res;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public List<int> RightSideView(TreeNode root) {\n        List<int> res = new List<int>();\n        Queue<TreeNode> q = new Queue<TreeNode>();\n        q.Enqueue(root);\n\n        while (q.Count > 0) {\n            TreeNode rightSide = null;\n            int qLen = q.Count;\n\n            for (int i = 0; i < qLen; i++) {\n                TreeNode node = q.Dequeue();\n                if (node != null) {\n                    rightSide = node;\n                    q.Enqueue(node.left);\n                    q.Enqueue(node.right);\n                }\n            }\n            if (rightSide != null) {\n                res.Add(rightSide.val);\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def rightSideView(self, root: Optional[TreeNode]) -> List[int]:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number[]}\n     */\n    rightSideView(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    vector<int> rightSideView(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public List<int> RightSideView(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/d4zLyf32e3I"},{"id":"count-good-nodes-in-binary-tree","name":"Count Good Nodes in Binary Tree","description":"Within a binary tree, a node `x` is considered **good** if the path from the root of the tree to the node `x` contains no nodes with a value greater than the value of node `x`\n\nGiven the root of a binary tree `root`, return the number of **good** nodes within the tree.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9bf374f1-71fe-469e-2840-5d223d9d1b00/public)\n\n```java\nInput: root = [2,1,1,3,null,1,5]\n\nOutput: 3\n```\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8df65da7-abac-4948-9a92-0bc7a8dda100/public)\n\n**Example 2:**\n\n```java\nInput: root = [1,2,-1,3,4]\n\nOutput: 4\n```\n\n\n**Constraints:**\n* `1 <= number of nodes in the tree <= 100`\n* `-100 <= Node.val <= 100`\n","difficulty":"Medium","concepts":["Binary Tree","Depth-First Search"],"solutions":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        def dfs(node, maxVal):\n            if not node:\n                return 0\n\n            res = 1 if node.val >= maxVal else 0\n            maxVal = max(maxVal, node.val)\n            res += dfs(node.left, maxVal)\n            res += dfs(node.right, maxVal)\n            return res\n\n        return dfs(root, root.val)\n","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    goodNodes(root) {\n        return this.dfs(root, root.val);\n    }\n\n    /**\n     * @param {TreeNode} node\n     * @param {number} maxVal\n     * @return {number}\n     */\n    dfs(node, maxVal) {\n        if (!node) {\n            return 0;\n        }\n\n        const res = node.val >= maxVal ? 1 : 0;\n        maxVal = Math.max(maxVal, node.val);\n        return res + this.dfs(node.left, maxVal) + this.dfs(node.right, maxVal);\n    }\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int goodNodes(TreeNode* root) {\n        return dfs(root, root->val);\n    }\n\nprivate:\n    int dfs(TreeNode* node, int maxVal) {\n        if (!node) {\n            return 0;\n        }\n\n        int res = (node->val >= maxVal) ? 1 : 0;\n        maxVal = max(maxVal, node->val);\n        res += dfs(node->left, maxVal);\n        res += dfs(node->right, maxVal);\n        return res;\n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    \n    public int goodNodes(TreeNode root) {\n        return dfs(root, root.val);\n    }\n\n    private int dfs(TreeNode node, int maxVal) {\n        if (node == null) {\n            return 0;\n        }\n\n        int res = (node.val >= maxVal) ? 1 : 0;\n        maxVal = Math.max(maxVal, node.val);\n        res += dfs(node.left, maxVal);\n        res += dfs(node.right, maxVal);\n        return res;\n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    \n    public int GoodNodes(TreeNode root) {\n        return Dfs(root, root.val);\n    }\n\n    private int Dfs(TreeNode node, int maxVal) {\n        if (node == null) {\n            return 0;\n        }\n\n        int res = (node.val >= maxVal) ? 1 : 0;\n        maxVal = Math.Max(maxVal, node.val);\n        res += Dfs(node.left, maxVal);\n        res += Dfs(node.right, maxVal);\n        return res;\n    }\n}\n"},"starterCode":{"python":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\n\nclass Solution:\n    def goodNodes(self, root: TreeNode) -> int:\n        ","javascript":"/**\n * Definition for a binary tree node.\n * class TreeNode {\n *     constructor(val = 0, left = null, right = null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    /**\n     * @param {TreeNode} root\n     * @return {number}\n     */\n    goodNodes(root) {}\n}\n","cpp":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\n\nclass Solution {\npublic:\n    int goodNodes(TreeNode* root) {\n        \n    }\n};\n","java":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n    public int goodNodes(TreeNode root) {\n        \n    }\n}\n","csharp":"/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     public int val;\n *     public TreeNode left;\n *     public TreeNode right;\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\npublic class Solution {\n    public int GoodNodes(TreeNode root) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/7cp5imvDzl4"},{"id":"kth-largest-integer-in-a-stream","name":"Kth Largest Integer in a Stream","description":"Design a class to find the `kth` largest integer in a stream of values, including duplicates. E.g. the `2nd` largest from [1, 2, 3, 3] is `3`. The stream is not necessarily sorted.\n\nImplement the following methods:\n* `constructor(int k, int[] nums)` Initializes the object given an integer `k` and the stream of integers `nums`.\n* `int add(int val)` Adds the integer `val` to the stream and returns the `kth` largest integer in the stream.\n\n**Example 1:**\n\n```java\nInput:\n[\"KthLargest\", [3, [1, 2, 3, 3]], \"add\", [3], \"add\", [5], \"add\", [6], \"add\", [7], \"add\", [8]]\n\nOutput:\n[null, 3, 3, 3, 5, 6]\n\nExplanation:\nKthLargest kthLargest = new KthLargest(3, [1, 2, 3, 3]);\nkthLargest.add(3);   // return 3\nkthLargest.add(5);   // return 3\nkthLargest.add(6);   // return 3\nkthLargest.add(7);   // return 5\nkthLargest.add(8);   // return 6\n```\n\n**Constraints:**\n* `1 <= k <= 1000`\n* `0 <= nums.length <= 1000`\n* `-1000 <= nums[i] <= 1000`\n* `-1000 <= val <= 1000`\n* There will always be at least `k` integers in the stream when you search for the `kth` integer.\n","difficulty":"Easy","concepts":["Heap Properties","Push and Pop","Heapify"],"solutions":{"python":"class KthLargest:\n    \n    def __init__(self, k: int, nums: List[int]):\n        self.minHeap, self.k = nums, k\n        heapq.heapify(self.minHeap)\n        while len(self.minHeap) > k:\n            heapq.heappop(self.minHeap)\n\n    def add(self, val: int) -> int:\n        heapq.heappush(self.minHeap, val)\n        if len(self.minHeap) > self.k:\n            heapq.heappop(self.minHeap)\n        return self.minHeap[0]\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass KthLargest {\n    /**\n     * @param {number} k\n     * @param {number[]} nums\n     */\n    constructor(k, nums) {\n        this.minHeap = new MinPriorityQueue();\n        this.k = k;\n\n        for (const num of nums) {\n            this.minHeap.enqueue(num);\n        }\n\n        while (this.minHeap.size() > k) {\n            this.minHeap.dequeue();\n        }\n    }\n\n    /**\n     * @param {number} val\n     * @return {number}\n     */\n    add(val) {\n        this.minHeap.enqueue(val);\n        if (this.minHeap.size() > this.k) {\n            this.minHeap.dequeue();\n        }\n        return this.minHeap.front();\n    }\n}\n","cpp":"class KthLargest {\nprivate:\n    priority_queue<int, vector<int>, greater<int>> minHeap;\n    int k;\n\npublic:\n    KthLargest(int k, vector<int>& nums) {\n        this->k = k;\n        for (int num : nums) {\n            minHeap.push(num);\n            if (minHeap.size() > k) {\n                minHeap.pop();\n            }\n        }\n    }\n\n    int add(int val) {\n        minHeap.push(val);\n        if (minHeap.size() > k) {\n            minHeap.pop();\n        }\n        return minHeap.top();\n    }\n};\n","java":"class KthLargest {\n    \n    private PriorityQueue<Integer> minHeap;\n    private int k;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        this.minHeap = new PriorityQueue<>();\n        for (int num : nums) {\n            minHeap.offer(num);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n    }\n\n    public int add(int val) {\n        minHeap.offer(val);\n        if (minHeap.size() > k) {\n            minHeap.poll();\n        }\n        return minHeap.peek();\n    }\n}\n","csharp":"public class KthLargest {\n    \n    private PriorityQueue<int, int> minHeap;\n    private int k;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        this.minHeap = new PriorityQueue<int, int>();\n        foreach (int num in nums) {\n            minHeap.Enqueue(num, num);\n            if (minHeap.Count > k) {\n                minHeap.Dequeue();\n            }\n        }\n    }\n\n    public int Add(int val) {\n        minHeap.Enqueue(val, val);\n        if (minHeap.Count > k) {\n            minHeap.Dequeue();\n        }\n        return minHeap.Peek();\n    }\n}\n"},"starterCode":{"python":"class KthLargest:\n\n    def __init__(self, k: int, nums: List[int]):\n        \n\n    def add(self, val: int) -> int:\n        \n","javascript":"class KthLargest {\n    /**\n     * @param {number} k\n     * @param {number[]} nums\n     */\n    constructor(k, nums) {}\n\n    /**\n     * @param {number} val\n     * @return {number}\n     */\n    add(val) {}\n}\n","cpp":"class KthLargest {\npublic:\n    KthLargest(int k, vector<int>& nums) {\n        \n    }\n    \n    int add(int val) {\n        \n    }\n};\n","java":"class KthLargest {\n\n    public KthLargest(int k, int[] nums) {\n        \n    }\n    \n    public int add(int val) {\n        \n    }\n}\n","csharp":"public class KthLargest {\n\n    public KthLargest(int k, int[] nums) {\n        \n    }\n    \n    public int Add(int val) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/hOjcdrqMoQ8"},{"id":"last-stone-weight","name":"Last Stone Weight","description":"You are given an array of integers `stones` where `stones[i]` represents the weight of the `ith` stone.\n\nWe want to run a simulation on the stones as follows:\n\n* At each step we choose the **two heaviest stones**, with weight `x` and `y` and smash them togethers\n* If `x == y`, both stones are destroyed\n* If `x < y`, the stone of weight `x` is destroyed, and the stone of weight `y` has new weight `y - x`.\n\nContinue the simulation until there is no more than one stone remaining.\n\nReturn the weight of the last remaining stone or return `0` if none remain.\n\n**Example 1:**\n\n```java\nInput: stones = [2,3,6,2,4]\n\nOutput: 1\n```\nExplanation: \nWe smash 6 and 4 and are left with a 2, so the array becomes [2,3,2,2].\nWe smash 3 and 2 and are left with a 1, so the array becomes [1,2,2].\nWe smash 2 and 2, so the array becomes [1].\n\n**Example 2:**\n\n```java\nInput: stones = [1,2]\n\nOutput: 1\n```\n\n**Constraints:**\n* `1 <= stones.length <= 20`\n* `1 <= stones[i] <= 100`\n","difficulty":"Easy","concepts":["Heap Properties","Push and Pop","Heapify"],"solutions":{"python":"class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        stones = [-s for s in stones]\n        heapq.heapify(stones)\n\n        while len(stones) > 1:\n            first = heapq.heappop(stones)\n            second = heapq.heappop(stones)\n            if second > first:\n                heapq.heappush(stones, first - second)\n\n        stones.append(0)\n        return abs(stones[0])\n","javascript":"/**\n * const { MaxPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[]} stones\n     * @return {number}\n     */\n    lastStoneWeight(stones) {\n        // Create a MaxPriorityQueue\n        const maxPQ = new MaxPriorityQueue();\n\n        // Add all stones to the priority queue\n        for (const stone of stones) {\n            maxPQ.enqueue(stone);\n        }\n\n        // Continue until there is one or no stones left in the queue\n        while (maxPQ.size() > 1) {\n            // Extract the two heaviest stones\n            const stone1 = maxPQ.dequeue();\n            const stone2 = maxPQ.dequeue();\n\n            // If they are not the same weight, push the difference back into the queue\n            if (stone1 !== stone2) {\n                maxPQ.enqueue(stone1 - stone2);\n            }\n        }\n\n        // If there is one stone left, return its weight; otherwise, return 0\n        return maxPQ.size() === 1 ? maxPQ.dequeue() : 0;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        priority_queue<int> maxHeap;\n        for (int s : stones) {\n            maxHeap.push(s);\n        }\n\n        while (maxHeap.size() > 1) {\n            int first = maxHeap.top();\n            maxHeap.pop();\n            int second = maxHeap.top();\n            maxHeap.pop();\n            if (second < first) {\n                maxHeap.push(first - second);\n            }\n        }\n\n        maxHeap.push(0);\n        return maxHeap.top();\n    }\n};\n","java":"class Solution {\n    public int lastStoneWeight(int[] stones) {\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        for (int s : stones) {\n            minHeap.offer(-s);\n        }\n\n        while (minHeap.size() > 1) {\n            int first = minHeap.poll();\n            int second = minHeap.poll();\n            if (second > first) {\n                minHeap.offer(first - second);\n            }\n        }\n\n        minHeap.offer(0);\n        return Math.abs(minHeap.peek());\n    }\n}\n","csharp":"public class Solution {\n    public int LastStoneWeight(int[] stones) {\n        PriorityQueue<int, int> minHeap = new PriorityQueue<int, int>();\n        foreach (int s in stones) {\n            minHeap.Enqueue(-s, -s);\n        }\n\n        while (minHeap.Count > 1) {\n            int first = minHeap.Dequeue();\n            int second = minHeap.Dequeue();\n            if (second > first) {\n                minHeap.Enqueue(first - second, first - second);\n            }\n        }\n\n        minHeap.Enqueue(0, 0);\n        return Math.Abs(minHeap.Peek());\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def lastStoneWeight(self, stones: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} stones\n     * @return {number}\n     */\n    lastStoneWeight(stones) {}\n}\n","cpp":"class Solution {\npublic:\n    int lastStoneWeight(vector<int>& stones) {\n        \n    }\n};\n","java":"class Solution {\n    public int lastStoneWeight(int[] stones) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LastStoneWeight(int[] stones) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/B-QCq79-Vfw"},{"id":"k-closest-points-to-origin","name":"K Closest Points to Origin","description":"You are given an 2-D array `points` where `points[i] = [xi, yi]` represents the coordinates of a point on an X-Y axis plane. You are also given an integer `k`.\n    \nReturn the `k` closest points to the origin `(0, 0)`. \n\nThe distance between two points is defined as the Euclidean distance (`sqrt((x1 - x2)^2 + (y1 - y2)^2))`.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ffe90895-5c8e-47f1-6719-d5c0f656d700/public)\n\n```java\nInput: points = [[0,2],[2,2]], k = 1\n\nOutput: [[0,2]]\n```\n\nExplanation : The distance between `(0, 2)` and the origin `(0, 0)` is `2`. The distance between `(2, 2)` and the origin is `sqrt(2^2 + 2^2) = 2.82842`. So the closest point to the origin is `(0, 2)`.\n\n**Example 2:**\n\n```java\nInput: points = [[0,2],[2,0],[2,2]], k = 2\n\nOutput: [[0,2],[2,0]]\n```\n\nExplanation: The output `[2,0],[0,2]` would also be accepted.\n\n**Constraints:**\n* `1 <= k <= points.length <= 1000`\n* `-100 <= points[i][0], points[i][1] <= 100`\n","difficulty":"Medium","concepts":["Heap Properties","Push and Pop","Heapify"],"solutions":{"python":"class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        minHeap = []\n        for x, y in points:\n            dist = (x ** 2) + (y ** 2)\n            minHeap.append((dist, x, y))\n        \n        heapq.heapify(minHeap)\n        res = []\n        for _ in range(k):\n            _, x, y = heapq.heappop(minHeap)\n            res.append((x, y))\n        return res\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[][]} points\n     * @param {number} k\n     * @return {number[][]}\n     */\n    kClosest(points, k) {\n        const minHeap = new MinPriorityQueue(point => point[0]);\n\n        for (const [x, y] of points) {\n            const dist = x ** 2 + y ** 2;\n            minHeap.enqueue([dist, x, y]);\n        }\n\n        const res = [];\n        for (let i = 0; i < k; i++) {\n            const [_, x, y] = minHeap.dequeue();\n            res.push([x, y]);\n        }\n\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n        auto comp = [](const vector<int>& a, const vector<int>& b) {\n            return a[0]*a[0] + a[1]*a[1] > b[0]*b[0] + b[1]*b[1];\n        };\n        \n        priority_queue<vector<int>, vector<vector<int>>, decltype(comp)> minHeap(comp);\n\n        for (const auto& point : points) {\n            minHeap.push({point[0], point[1]});\n        }\n\n        vector<vector<int>> result;\n        for (int i = 0; i < K; ++i) {\n            result.push_back(minHeap.top());\n            minHeap.pop();\n        }\n        return result;\n    }\n};\n","java":"class Solution {\n    public int[][] kClosest(int[][] points, int K) {\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparing(a -> a[0]));\n        for (int[] point : points) {\n            int dist = point[0] * point[0] + point[1] * point[1];\n            minHeap.offer(new int[]{dist, point[0], point[1]});\n        }\n\n        int[][] result = new int[K][2];\n        for (int i = 0; i < K; ++i) {\n            int[] point = minHeap.poll();\n            result[i] = new int[]{point[1], point[2]};\n        }\n        return result;\n    }\n}\n","csharp":"public class Solution {\n    public int[][] KClosest(int[][] points, int K) {\n        PriorityQueue<int[], int> minHeap = new PriorityQueue<int[], int>();\n        foreach (int[] point in points) {\n            int dist = point[0] * point[0] + point[1] * point[1];\n            minHeap.Enqueue(new int[] { dist, point[0], point[1] }, dist);\n        }\n\n        int[][] result = new int[K][];\n        for (int i = 0; i < K; ++i) {\n            int[] point = minHeap.Dequeue();\n            result[i] = new int[] { point[1], point[2] };\n        }\n        return result;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def kClosest(self, points: List[List[int]], k: int) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} points\n     * @param {number} k\n     * @return {number[][]}\n     */\n    kClosest(points, k) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int k) {\n        \n    }\n};\n","java":"class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        \n\n    }\n}\n","csharp":"public class Solution {\n    public int[][] KClosest(int[][] points, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/rI2EBUEMfTk"},{"id":"task-scheduling","name":"Task Scheduling","description":"You are given an array of CPU  tasks `tasks`, where `tasks[i]` is an uppercase english character from `A` to `Z`. You are also given an integer `n`. \n    \nEach CPU cycle allows the completion of a single task, and tasks may be completed in any order.\n\nThe only constraint is that **identical** tasks must be separated by at least `n` CPU cycles, to cooldown the CPU.\n\nReturn the *minimum number* of CPU cycles required to complete all tasks.\n\n**Example 1:**\n\n```java\nInput: tasks = [\"X\",\"X\",\"Y\",\"Y\"], n = 2\n\nOutput: 5\n```\n\nExplanation: A possible sequence is: X -> Y -> idle -> X -> Y.\n\n**Example 2:**\n\n```java\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"C\"], n = 3\n\nOutput: 9\n```\n\nExplanation: A possible sequence is: A -> B -> C -> Idle -> A -> Idle -> Idle -> Idle -> A.\n\n**Constraints:**\n* `1 <= tasks.length <= 1000`\n* `0 <= n <= 100`\n","difficulty":"Medium","concepts":["Heap Properties","Push and Pop","Heapify"],"solutions":{"python":"class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        count = Counter(tasks)\n        maxHeap = [-cnt for cnt in count.values()]\n        heapq.heapify(maxHeap)\n\n        time = 0\n        q = deque()  # pairs of [-cnt, idleTime]\n        while maxHeap or q:\n            time += 1\n\n            if not maxHeap:\n                time = q[0][1]\n            else:\n                cnt = 1 + heapq.heappop(maxHeap)\n                if cnt:\n                    q.append([cnt, time + n])\n            if q and q[0][1] == time:\n                heapq.heappush(maxHeap, q.popleft()[0])\n        return time\n","javascript":"/**\n * const { MaxPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {character[]} tasks\n     * @param {number} n\n     * @return {number}\n     */\n    leastInterval(tasks, n) {\n        const count = {};\n        for (const task of tasks) {\n            count[task] = (count[task] || 0) + 1;\n        }\n\n        const maxHeap = new MaxPriorityQueue(entry => entry[0]);\n        for (const cnt of Object.values(count)) {\n            maxHeap.enqueue([cnt]);\n        }\n\n        let time = 0;\n        const queue = []; // pairs of [cnt, idleTime]\n\n        while (!maxHeap.isEmpty() || queue.length > 0) {\n            time += 1;\n\n            if (!maxHeap.isEmpty()) {\n                const cnt = maxHeap.dequeue()[0] - 1;\n                if (cnt > 0) {\n                    queue.push([cnt, time + n]);\n                }\n            }\n\n            if (queue.length > 0 && queue[0][1] === time) {\n                maxHeap.enqueue([queue.shift()[0]]);\n            }\n        }\n\n        return time;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        unordered_map<char, int> counts;\n        for (char task : tasks) {\n            counts[task]++;\n        }\n\n        priority_queue<int> maxHeap;\n        for (auto& entry : counts) {\n            maxHeap.push(entry.second);\n        }\n\n        int time = 0;\n        queue<pair<int, int>> queue;  // pairs of {cnt, idleTime}\n        while (!maxHeap.empty() || !queue.empty()) {\n            if (!queue.empty() && time >= queue.front().second) {\n                maxHeap.push(queue.front().first);\n                queue.pop();\n            }\n            if (!maxHeap.empty()) {\n                int cnt = maxHeap.top() - 1;\n                maxHeap.pop();\n                if (cnt > 0) {\n                    queue.push({cnt, time + n + 1});\n                }\n            }\n            time++;\n        }\n        return time;\n    }\n};\n","java":"class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        Map<Character, Integer> counts = new HashMap<>();\n        for (char task : tasks) {\n            counts.put(task, counts.getOrDefault(task, 0) + 1);\n        }\n\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        maxHeap.addAll(counts.values());\n\n        int time = 0;\n        Deque<int[]> queue = new ArrayDeque<>();  // pairs of [cnt, idleTime]\n        while (!maxHeap.isEmpty() || !queue.isEmpty()) {\n            if (!queue.isEmpty() && time >= queue.peek()[1]) {\n                maxHeap.offer(queue.poll()[0]);\n            }\n            if (!maxHeap.isEmpty()) {\n                int cnt = maxHeap.poll() - 1;\n                if (cnt > 0) {\n                    queue.offer(new int[]{cnt, time + n + 1});\n                }\n            }\n            time++;\n        }\n        return time;\n    }\n}\n","csharp":"public class Solution {\n    public int LeastInterval(char[] tasks, int n) {\n        var counts = new Dictionary<char, int>();\n        foreach (char task in tasks) {\n            if (!counts.ContainsKey(task))\n                counts[task] = 0;\n            counts[task]++;\n        }\n\n        // Priority queue in descending order\n        var maxHeap = new PriorityQueue<int, int>();\n        foreach (var count in counts.Values) {\n            maxHeap.Enqueue(count, -count);  // Using negative for max-heap behavior\n        }\n\n        int time = 0;\n        Queue<int[]> queue = new Queue<int[]>();  // pairs of [cnt, idleTime]\n        while (maxHeap.Count > 0 || queue.Count > 0) {\n            if (queue.Count > 0 && time >= queue.Peek()[1]) {\n                int[] temp = queue.Dequeue();\n                maxHeap.Enqueue(temp[0], -temp[0]);\n            }\n            if (maxHeap.Count > 0) {\n                int cnt = maxHeap.Dequeue() - 1;\n                if (cnt > 0) {\n                    queue.Enqueue(new int[] { cnt, time + n + 1 });\n                }\n            }\n            time++;\n        }\n        return time;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def leastInterval(self, tasks: List[str], n: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {character[]} tasks\n     * @param {number} n\n     * @return {number}\n     */\n    leastInterval(tasks, n) {}\n}\n","cpp":"class Solution {\npublic:\n    int leastInterval(vector<char>& tasks, int n) {\n        \n    }\n};\n","java":"class Solution {\n    public int leastInterval(char[] tasks, int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LeastInterval(char[] tasks, int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/s8p8ukTyA2I"},{"id":"design-twitter-feed","name":"Design Twitter Feed","description":"Implement a simplified version of Twitter which allows users to post tweets, follow/unfollow each other, and view the `10` most recent tweets within their own news feed.\n\nUsers and tweets are uniquely identified by their IDs (integers).\n\nImplement the following methods:\n\n* `Twitter()` Initializes the twitter object.\n* `void postTweet(int userId, int tweetId)` Publish a new tweet with ID `tweetId` by the user `userId`. You may assume that each `tweetId` is unique.\n* `List<Integer> getNewsFeed(int userId)` Fetches at most the `10` most recent tweet IDs in the user's news feed. Each item must be posted by users who the user is following or by the user themself. Tweets IDs should be **ordered from most recent to least recent**.\n* `void follow(int followerId, int followeeId)` The user with ID `followerId` follows the user with ID `followeeId`.\n* `void unfollow(int followerId, int followeeId)` The user with ID `followerId` unfollows the user with ID `followeeId`.\n\n**Example 1:**\n\n```java\nInput:\n[\"Twitter\", \"postTweet\", [1, 10], \"postTweet\", [2, 20], \"getNewsFeed\", [1], \"getNewsFeed\", [2], \"follow\", [1, 2], \"getNewsFeed\", [1], \"getNewsFeed\", [2], \"unfollow\", [1, 2], \"getNewsFeed\", [1]]\n\nOutput:\n[null, null, null, [10], [20], null, [20, 10], [20], null, [10]]\n\nExplanation:\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 10); // User 1 posts a new tweet with id = 10.\ntwitter.postTweet(2, 20); // User 2 posts a new tweet with id = 20.\ntwitter.getNewsFeed(1);   // User 1's news feed should only contain their own tweets -> [10].\ntwitter.getNewsFeed(2);   // User 2's news feed should only contain their own tweets -> [20].\ntwitter.follow(1, 2);     // User 1 follows user 2.\ntwitter.getNewsFeed(1);   // User 1's news feed should contain both tweets from user 1 and user 2 -> [20, 10].\ntwitter.getNewsFeed(2);   // User 2's news feed should still only contain their own tweets -> [20].\ntwitter.unfollow(1, 2);   // User 1 follows user 2.\ntwitter.getNewsFeed(1);   // User 1's news feed should only contain their own tweets -> [10].\n```\n\n**Constraints:**\n* `1 <= userId, followerId, followeeId <= 100`\n* `0 <= tweetId <= 1000`\n","difficulty":"Medium","concepts":["Heap Properties","Push and Pop","Hash Usage"],"solutions":{"python":"class Twitter:\n    def __init__(self):\n        self.count = 0\n        self.tweetMap = defaultdict(list)  # userId -> list of [count, tweetIds]\n        self.followMap = defaultdict(set)  # userId -> set of followeeId\n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        self.tweetMap[userId].append([self.count, tweetId])\n        self.count -= 1\n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        res = []\n        minHeap = []\n\n        self.followMap[userId].add(userId)\n        for followeeId in self.followMap[userId]:\n            if followeeId in self.tweetMap:\n                index = len(self.tweetMap[followeeId]) - 1\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n\n        while minHeap and len(res) < 10:\n            count, tweetId, followeeId, index = heapq.heappop(minHeap)\n            res.append(tweetId)\n            if index >= 0:\n                count, tweetId = self.tweetMap[followeeId][index]\n                heapq.heappush(minHeap, [count, tweetId, followeeId, index - 1])\n        return res\n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        self.followMap[followerId].add(followeeId)\n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        if followeeId in self.followMap[followerId]:\n            self.followMap[followerId].remove(followeeId)\n","javascript":"/**\n * const { MaxPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Twitter {\n    constructor() {\n        this.users = new Map();\n        this.timestamp = 0;\n    }\n\n    /**\n     * @param {number} userId\n     * @param {number} tweetId\n     * @return {void}\n     */\n    postTweet(userId, tweetId) {\n        if (!this.users.has(userId)) {\n            this.users.set(userId, { tweets: [], following: new Set() });\n        }\n        this.users\n            .get(userId)\n            .tweets.push({ timestamp: this.timestamp, tweetId });\n        this.timestamp += 1;\n    }\n\n    /**\n     * @param {number} userId\n     * @return {number[]}\n     */\n    getNewsFeed(userId) {\n        if (!this.users.has(userId)) {\n            return [];\n        }\n\n        const maxPQ = new MaxPriorityQueue(tweet => tweet.timestamp);\n        const seenTweets = new Set();\n\n        const user = this.users.get(userId);\n        user.tweets.forEach(tweet => {\n            if (!seenTweets.has(tweet.tweetId)) {\n                maxPQ.enqueue(tweet);\n                seenTweets.add(tweet.tweetId);\n            }\n        });\n\n        user.following.forEach(followeeId => {\n            if (this.users.has(followeeId)) {\n                this.users.get(followeeId).tweets.forEach(tweet => {\n                    if (!seenTweets.has(tweet.tweetId)) {\n                        maxPQ.enqueue(tweet);\n                        seenTweets.add(tweet.tweetId);\n                    }\n                });\n            }\n        });\n\n        const newsFeed = [];\n        for (let i = 0; i < 10 && !maxPQ.isEmpty(); i++) {\n            newsFeed.push(maxPQ.dequeue().tweetId);\n        }\n\n        return newsFeed;\n    }\n\n    /**\n     * @param {number} followerId\n     * @param {number} followeeId\n     * @return {void}\n     */\n    follow(followerId, followeeId) {\n        if (!this.users.has(followerId)) {\n            this.users.set(followerId, { tweets: [], following: new Set() });\n        }\n        this.users.get(followerId).following.add(followeeId);\n    }\n\n    /**\n     * @param {number} followerId\n     * @param {number} followeeId\n     * @return {void}\n     */\n    unfollow(followerId, followeeId) {\n        if (this.users.has(followerId)) {\n            this.users.get(followerId).following.delete(followeeId);\n        }\n    }\n}\n","cpp":"class Twitter {\nprivate:\n    int count;\n    map<int, vector<vector<int>>> tweetMap;\n    map<int, set<int>> followMap;\n\npublic:\n    Twitter() {\n        count = 0;\n    }\n\n    void postTweet(int userId, int tweetId) {\n        tweetMap[userId].push_back({count++, tweetId});\n    }\n\n    vector<int> getNewsFeed(int userId) {\n        vector<int> res;\n        auto compare = [](const vector<int>& a, const vector<int>& b) {\n            return a[0] < b[0];\n        };\n        priority_queue<vector<int>, vector<vector<int>>, decltype(compare)> minHeap(compare);\n\n        followMap[userId].insert(userId);\n        for (int followeeId : followMap[userId]) {\n            if (tweetMap.count(followeeId)) {\n                const vector<vector<int>>& tweets = tweetMap[followeeId];\n                int index = tweets.size() - 1;\n                minHeap.push({tweets[index][0], tweets[index][1], followeeId, index});\n            }\n        }\n\n        while (!minHeap.empty() && res.size() < 10) {\n            vector<int> curr = minHeap.top();\n            minHeap.pop();\n            res.push_back(curr[1]);\n            int index = curr[3];\n            if (index > 0) {\n                const vector<int>& tweet = tweetMap[curr[2]][index - 1];\n                minHeap.push({tweet[0], tweet[1], curr[2], index - 1});\n            }\n        }\n        return res;\n    }\n\n    void follow(int followerId, int followeeId) {\n        followMap[followerId].insert(followeeId);\n    }\n\n    void unfollow(int followerId, int followeeId) {\n        followMap[followerId].erase(followeeId);\n    }\n};\n","java":"class Twitter {\n    \n    private int count;\n    private Map<Integer, List<int[]>> tweetMap;\n    private Map<Integer, Set<Integer>> followMap;\n\n    public Twitter() {\n        count = 0;\n        tweetMap = new HashMap<>();\n        followMap = new HashMap<>();\n    }\n\n    public void postTweet(int userId, int tweetId) {\n        tweetMap.computeIfAbsent(userId, k -> new ArrayList<>()).add(new int[]{count--, tweetId});\n    }\n\n    public List<Integer> getNewsFeed(int userId) {\n        List<Integer> res = new ArrayList<>();\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n\n        followMap.computeIfAbsent(userId, k -> new HashSet<>()).add(userId);\n        for (int followeeId : followMap.get(userId)) {\n            if (tweetMap.containsKey(followeeId)) {\n                List<int[]> tweets = tweetMap.get(followeeId);\n                int index = tweets.size() - 1;\n                int[] tweet = tweets.get(index);\n                minHeap.offer(new int[]{tweet[0], tweet[1], followeeId, index});\n            }\n        }\n\n        while (!minHeap.isEmpty() && res.size() < 10) {\n            int[] curr = minHeap.poll();\n            res.add(curr[1]);\n            int index = curr[3];\n            if (index > 0) {\n                int[] tweet = tweetMap.get(curr[2]).get(index - 1);\n                minHeap.offer(new int[]{tweet[0], tweet[1], curr[2], index - 1});\n            }\n        }\n        return res;\n    }\n\n    public void follow(int followerId, int followeeId) {\n        followMap.computeIfAbsent(followerId, k -> new HashSet<>()).add(followeeId);\n    }\n\n    public void unfollow(int followerId, int followeeId) {\n        followMap.computeIfPresent(followerId, (k, v) -> {\n            v.remove(followeeId);\n            return v;\n        });\n    }\n}\n","csharp":"public class Twitter {\n\n    private int count;\n    private Dictionary<int, List<int[]>> tweetMap;\n    private Dictionary<int, HashSet<int>> followMap;\n\n    public Twitter() {\n        count = 0;\n        tweetMap = new Dictionary<int, List<int[]>>();\n        followMap = new Dictionary<int, HashSet<int>>();\n    }\n\n    public void PostTweet(int userId, int tweetId) {\n        if (!tweetMap.ContainsKey(userId)) {\n            tweetMap[userId] = new List<int[]>();\n        }\n        tweetMap[userId].Add(new int[] { count--, tweetId });\n    }\n\n    public List<int> GetNewsFeed(int userId) {\n        List<int> res = new List<int>();\n        SortedSet<int[]> minHeap = new SortedSet<int[]>(Comparer<int[]>.Create((a, b) => a[0].CompareTo(b[0])));\n        \n        if (!followMap.ContainsKey(userId)) {\n            followMap[userId] = new HashSet<int>();\n        }\n        followMap[userId].Add(userId);\n        \n        foreach (int followeeId in followMap[userId]) {\n            if (tweetMap.ContainsKey(followeeId)) {\n                List<int[]> tweets = tweetMap[followeeId];\n                if (tweets.Count > 0) {\n                    int index = tweets.Count - 1;\n                    int[] tweet = tweets[index];\n                    minHeap.Add(new int[] { tweet[0], tweet[1], followeeId, index });\n                }\n            }\n        }\n\n        while (minHeap.Count > 0 && res.Count < 10) {\n            int[] curr = minHeap.Min;\n            minHeap.Remove(minHeap.Min);\n            res.Add(curr[1]);\n            int index = curr[3];\n            if (index > 0) {\n                int[] tweet = tweetMap[curr[2]][index - 1];\n                minHeap.Add(new int[] { tweet[0], tweet[1], curr[2], index - 1 });\n            }\n        }\n\n        return res;\n    }\n\n    public void Follow(int followerId, int followeeId) {\n        if (!followMap.ContainsKey(followerId)) {\n            followMap[followerId] = new HashSet<int>();\n        }\n        followMap[followerId].Add(followeeId);\n    }\n\n    public void Unfollow(int followerId, int followeeId) {\n        if (followMap.ContainsKey(followerId)) {\n            followMap[followerId].Remove(followeeId);\n        }\n    }\n}\n"},"starterCode":{"python":"class Twitter:\n\n    def __init__(self):\n        \n\n    def postTweet(self, userId: int, tweetId: int) -> None:\n        \n\n    def getNewsFeed(self, userId: int) -> List[int]:\n        \n\n    def follow(self, followerId: int, followeeId: int) -> None:\n        \n\n    def unfollow(self, followerId: int, followeeId: int) -> None:\n        \n","javascript":"class Twitter {\n    constructor() {}\n\n    /**\n     * @param {number} userId\n     * @param {number} tweetId\n     * @return {void}\n     */\n    postTweet(userId, tweetId) {}\n\n    /**\n     * @param {number} userId\n     * @return {number[]}\n     */\n    getNewsFeed(userId) {}\n\n    /**\n     * @param {number} followerId\n     * @param {number} followeeId\n     * @return {void}\n     */\n    follow(followerId, followeeId) {}\n\n    /**\n     * @param {number} followerId\n     * @param {number} followeeId\n     * @return {void}\n     */\n    unfollow(followerId, followeeId) {}\n}\n","cpp":"class Twitter {\npublic:\n    Twitter() {\n        \n    }\n    \n    void postTweet(int userId, int tweetId) {\n        \n    }\n    \n    vector<int> getNewsFeed(int userId) {\n        \n    }\n    \n    void follow(int followerId, int followeeId) {\n        \n    }\n    \n    void unfollow(int followerId, int followeeId) {\n        \n    }\n};\n","java":"class Twitter {\n\n    public Twitter() {\n        \n    }\n    \n    public void postTweet(int userId, int tweetId) {\n        \n    }\n    \n    public List<Integer> getNewsFeed(int userId) {\n        \n    }\n    \n    public void follow(int followerId, int followeeId) {\n        \n    }\n    \n    public void unfollow(int followerId, int followeeId) {\n        \n    }\n}\n","csharp":"public class Twitter {\n\n    public Twitter() {\n        \n    }\n    \n    public void PostTweet(int userId, int tweetId) {\n        \n    }\n    \n    public List<int> GetNewsFeed(int userId) {\n        \n    }\n    \n    public void Follow(int followerId, int followeeId) {\n        \n    }\n    \n    public void Unfollow(int followerId, int followeeId) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/pNichitDD2E"},{"id":"subsets","name":"Subsets","description":"Given an array `nums` of **unique** integers, return all possible subsets of `nums`.\n\nThe solution set must **not** contain duplicate subsets. You may return the solution in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3]\n\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7]\n\nOutput: [[],[7]]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10`\n* `-10 <= nums[i] <= 10`\n","difficulty":"Medium","concepts":["Tree Maze","Subsets"],"solutions":{"python":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        subset = []\n\n        def dfs(i):\n            if i >= len(nums):\n                res.append(subset.copy())\n                return\n            subset.append(nums[i])\n            dfs(i + 1)\n            subset.pop()\n            dfs(i + 1)\n\n        dfs(0)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    subsets(nums) {\n        const res = [];\n        const subset = [];\n        this.dfs(nums, 0, subset, res);\n        return res;\n    }\n\n    /**\n     * @param {number[]} nums\n     * @param {number} i\n     * @param {number[]} subset\n     * @param {number[][]} res\n     * @return {void}\n     */\n    dfs(nums, i, subset, res) {\n        if (i >= nums.length) {\n            res.push([...subset]);\n            return;\n        }\n        subset.push(nums[i]);\n        this.dfs(nums, i + 1, subset, res);\n        subset.pop();\n        this.dfs(nums, i + 1, subset, res);\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> res;\n        vector<int> subset;\n        dfs(nums, 0, subset, res);\n        return res;\n    }\n\nprivate:\n    void dfs(const vector<int>& nums, int i, vector<int>& subset, vector<vector<int>>& res) {\n        if (i >= nums.size()) {\n            res.push_back(subset);\n            return;\n        }\n        subset.push_back(nums[i]);\n        dfs(nums, i + 1, subset, res);\n        subset.pop_back();\n        dfs(nums, i + 1, subset, res);\n    }\n};\n","java":"class Solution {\n    \n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> subset = new ArrayList<>();\n        dfs(nums, 0, subset, res);\n        return res;\n    }\n\n    private void dfs(int[] nums, int i, List<Integer> subset, List<List<Integer>> res) {\n        if (i >= nums.length) {\n            res.add(new ArrayList<>(subset));\n            return;\n        }\n        subset.add(nums[i]);\n        dfs(nums, i + 1, subset, res);\n        subset.remove(subset.size() - 1);\n        dfs(nums, i + 1, subset, res);\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<List<int>> Subsets(int[] nums) {\n        var res = new List<List<int>>();\n        var subset = new List<int>();\n        Dfs(nums, 0, subset, res);\n        return res;\n    }\n\n    private void Dfs(int[] nums, int i, List<int> subset, List<List<int>> res) {\n        if (i >= nums.Length) {\n            res.Add(new List<int>(subset));\n            return;\n        }\n        subset.Add(nums[i]);\n        Dfs(nums, i + 1, subset, res);\n        subset.RemoveAt(subset.Count - 1);\n        Dfs(nums, i + 1, subset, res);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    subsets(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> subsets(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> Subsets(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/REOH22Xwdkk"},{"id":"permutations","name":"Permutations","description":"Given an array `nums` of **unique** integers, return all the possible permutations. You may return the answer in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3]\n\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7]\n\nOutput: [[7]]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 6`\n* `-10 <= nums[i] <= 10`\n","difficulty":"Medium","concepts":["Tree Maze","Permutations"],"solutions":{"python":"class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        res = []\n\n        if len(nums) == 1:\n            return [nums[:]]\n\n        for i in range(len(nums)):\n            n = nums.pop(0)\n            perms = self.permute(nums)\n\n            for perm in perms:\n                perm.append(n)\n            res.extend(perms)\n            nums.append(n)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    permute(nums) {\n        const res = [];\n\n        if (nums.length === 1) {\n            res.push([nums[0]]);\n            return res;\n        }\n\n        for (let i = 0; i < nums.length; i++) {\n            const n = nums[i];\n            const remainingNums = nums.filter((_, j) => j !== i);\n            const perms = this.permute(remainingNums);\n\n            for (const perm of perms) {\n                perm.push(n);\n                res.push([...perm]);\n            }\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        vector<vector<int>> res;\n\n        if (nums.size() == 1) {\n            vector<int> singleNum;\n            singleNum.push_back(nums[0]);\n            res.push_back(singleNum);\n            return res;\n        }\n\n        for (size_t i = 0; i < nums.size(); i++) {\n            int n = nums[i];\n            vector<int> remainingNums(nums.size() - 1);\n            size_t idx = 0;\n            for (size_t j = 0; j < nums.size(); j++) {\n                if (j != i) {\n                    remainingNums[idx++] = nums[j];\n                }\n            }\n            vector<vector<int>> perms = permute(remainingNums);\n\n            for (const auto& perm : perms) {\n                vector<int> newPerm = perm;\n                newPerm.push_back(n);\n                res.push_back(newPerm);\n            }\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n\n        if (nums.length == 1) {\n            List<Integer> singleNum = new ArrayList<>();\n            singleNum.add(nums[0]);\n            res.add(singleNum);\n            return res;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            int n = nums[i];\n            int[] remainingNums = new int[nums.length - 1];\n            int idx = 0;\n            for (int j = 0; j < nums.length; j++) {\n                if (j != i) {\n                    remainingNums[idx++] = nums[j];\n                }\n            }\n            List<List<Integer>> perms = permute(remainingNums);\n\n            for (List<Integer> perm : perms) {\n                perm.add(n);\n                res.add(new ArrayList<>(perm));\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> Permute(int[] nums) {\n        List<List<int>> res = new List<List<int>>();\n\n        if (nums.Length == 1) {\n            List<int> singleNum = new List<int>();\n            singleNum.Add(nums[0]);\n            res.Add(singleNum);\n            return res;\n        }\n\n        for (int i = 0; i < nums.Length; i++) {\n            int n = nums[i];\n            int[] remainingNums = new int[nums.Length - 1];\n            int idx = 0;\n            for (int j = 0; j < nums.Length; j++) {\n                if (j != i) {\n                    remainingNums[idx++] = nums[j];\n                }\n            }\n            List<List<int>> perms = Permute(remainingNums);\n\n            foreach (List<int> perm in perms) {\n                perm.Add(n);\n                res.Add(new List<int>(perm));\n            }\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    permute(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> permute(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> Permute(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/FZe0UqISmUw"},{"id":"subsets-ii","name":"Subsets II","description":"You are given an array `nums` of integers, which that may contain duplicates. Return all possible subsets.\n\nThe solution must **not** contain duplicate subsets. You may return the solution in **any order**.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,1]\n\nOutput: [[],[1],[1,2],[1,1],[1,2,1],[2]]\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7,7]\n\nOutput: [[],[7], [7,7]]\n```\n\n**Constraints:**\n* `1 <= nums.length <= 11`\n* `-20 <= nums[i] <= 20`\n","difficulty":"Medium","concepts":["Tree Maze","Subsets"],"solutions":{"python":"class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        nums.sort()\n\n        def backtrack(i, subset):\n            if i == len(nums):\n                res.append(subset[::])\n                return\n\n            subset.append(nums[i])\n            backtrack(i + 1, subset)\n            subset.pop()\n\n            while i + 1 < len(nums) and nums[i] == nums[i + 1]:\n                i += 1\n            backtrack(i + 1, subset)\n\n        backtrack(0, [])\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    subsetsWithDup(nums) {\n        const res = [];\n        nums.sort((a, b) => a - b);\n        this.backtrack(0, [], nums, res);\n        return res;\n    }\n\n    /**\n     * @param {number} start\n     * @param {number[]} subset\n     * @param {number[]} nums\n     * @param {number[][]} res\n     * @return {void}\n     */\n    backtrack(start, subset, nums, res) {\n        res.push([...subset]);\n        for (let i = start; i < nums.length; i++) {\n            if (i > start && nums[i] === nums[i - 1]) {\n                continue;\n            }\n            subset.push(nums[i]);\n            this.backtrack(i + 1, subset, nums, res);\n            subset.pop();\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        vector<vector<int>> res;\n        sort(nums.begin(), nums.end());\n        backtrack(0, {}, nums, res);\n        return res;\n    }\n\nprivate:\n    void backtrack(int start, vector<int> subset, vector<int>& nums, vector<vector<int>>& res) {\n        res.push_back(subset);\n        for (int i = start; i < nums.size(); i++) {\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            subset.push_back(nums[i]);\n            backtrack(i + 1, subset, nums, res);\n            subset.pop_back();\n        }\n    }\n};\n","java":"class Solution {\n    \n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(nums);\n        backtrack(0, new ArrayList<>(), nums, res);\n        return res;\n    }\n\n    private void backtrack(int start, List<Integer> subset, int[] nums, List<List<Integer>> res) {\n        res.add(new ArrayList<>(subset));\n        for (int i = start; i < nums.length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            subset.add(nums[i]);\n            backtrack(i + 1, subset, nums, res);\n            subset.remove(subset.size() - 1);\n        }\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<List<int>> SubsetsWithDup(int[] nums) {\n        List<List<int>> res = new List<List<int>>();\n        Array.Sort(nums);\n        Backtrack(0, new List<int>(), nums, res);\n        return res;\n    }\n\n    private void Backtrack(int start, List<int> subset, int[] nums, List<List<int>> res) {\n        res.Add(new List<int>(subset));\n        for (int i = start; i < nums.Length; i++) {\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            subset.Add(nums[i]);\n            Backtrack(i + 1, subset, nums, res);\n            subset.RemoveAt(subset.Count - 1);\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number[][]}\n     */\n    subsetsWithDup(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> SubsetsWithDup(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Vn2v6ajA7U0"},{"id":"combination-target-sum-ii","name":"Combination Target Sum II","description":"You are given an array of integers `nums`, which may contain duplicates, and a target integer `target`. Your task is to return a list of all **unique combinations** of `nums` where the chosen numbers sum to `target`.\n\nEach element from `nums` may be chosen **at most once** within a combination. The solution set must not contain duplicate combinations.\n\nYou may return the combinations in **any order** and the order of the numbers in each combination can be in **any order**.\n\n**Example 1:**\n\n```java\nInput: candidates = [9,2,2,4,6,1,5], target = 8\n\nOutput: [\n  [1,2,5],\n  [2,2,4],\n  [2,6]\n]\n```\n\n**Example 2:**\n\n```java\nInput: candidates = [1,2,3,4,5], target = 7\n\nOutput: [\n  [1,2,4],\n  [2,5],\n  [3,4]\n]\n```\n\n**Constraints:**\n* `1 <= candidates.length <= 100`\n* `1 <= candidates[i] <= 50`\n* `1 <= target <= 30`\n","difficulty":"Medium","concepts":["Tree Maze","Combinations"],"solutions":{"python":"class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        res = []\n        candidates.sort()\n\n        def dfs(i, cur, total):\n            if total == target:\n                res.append(cur.copy())\n                return\n            if total > target or i == len(candidates):\n                return\n            # include candidates[i]\n            cur.append(candidates[i])\n            dfs(i + 1, cur, total + candidates[i])\n            cur.pop()\n\n            # skip candidates[i]\n            while i + 1 < len(candidates) and candidates[i] == candidates[i+1]:\n                i += 1\n            dfs(i + 1, cur, total)\n            \n        dfs(0, [], 0)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} candidates\n     * @param {number} target\n     * @return {number[][]}\n     */\n    combinationSum2(candidates, target) {\n        const res = [];\n        candidates.sort((a, b) => a - b);\n        this.backtrack([], 0, target, candidates, res);\n        return res;\n    }\n\n    /**\n     * @param {number[]} cur\n     * @param {number} pos\n     * @param {number} target\n     * @param {number[]} candidates\n     * @param {number[][]} res\n     * @return {void}\n     */\n    backtrack(cur, pos, target, candidates, res) {\n        if (target === 0) {\n            res.push([...cur]);\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n\n        let prev = -1;\n        for (let i = pos; i < candidates.length; i++) {\n            if (candidates[i] === prev) {\n                continue;\n            }\n            cur.push(candidates[i]);\n            this.backtrack(cur, i + 1, target - candidates[i], candidates, res);\n            cur.pop();\n            prev = candidates[i];\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        vector<vector<int>> res;\n        sort(candidates.begin(), candidates.end());\n        backtrack({}, 0, target, candidates, res);\n        return res;\n    }\n\nprivate:\n    void backtrack(vector<int> cur, int pos, int target, vector<int>& candidates, vector<vector<int>>& res) {\n        if (target == 0) {\n            res.push_back(cur);\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n\n        int prev = -1;\n        for (int i = pos; i < candidates.size(); i++) {\n            if (candidates[i] == prev) {\n                continue;\n            }\n            cur.push_back(candidates[i]);\n            backtrack(cur, i + 1, target - candidates[i], candidates, res);\n            cur.pop_back();\n            prev = candidates[i];\n        }\n    }\n};\n","java":"class Solution {\n    \n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(candidates);\n        backtrack(new ArrayList<>(), 0, target, candidates, res);\n        return res;\n    }\n\n    private void backtrack(List<Integer> cur, int pos, int target, int[] candidates, List<List<Integer>> res) {\n        if (target == 0) {\n            res.add(new ArrayList<>(cur));\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n\n        int prev = -1;\n        for (int i = pos; i < candidates.length; i++) {\n            if (candidates[i] == prev) {\n                continue;\n            }\n            cur.add(candidates[i]);\n            backtrack(cur, i + 1, target - candidates[i], candidates, res);\n            cur.remove(cur.size() - 1);\n            prev = candidates[i];\n        }\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<List<int>> CombinationSum2(int[] candidates, int target) {\n        List<List<int>> res = new List<List<int>>();\n        Array.Sort(candidates);\n        Backtrack(new List<int>(), 0, target, candidates, res);\n        return res;\n    }\n\n    private void Backtrack(List<int> cur, int pos, int target, int[] candidates, List<List<int>> res) {\n        if (target == 0) {\n            res.Add(new List<int>(cur));\n            return;\n        }\n        if (target < 0) {\n            return;\n        }\n\n        int prev = -1;\n        for (int i = pos; i < candidates.Length; i++) {\n            if (candidates[i] == prev) {\n                continue;\n            }\n            cur.Add(candidates[i]);\n            Backtrack(cur, i + 1, target - candidates[i], candidates, res);\n            cur.RemoveAt(cur.Count - 1);\n            prev = candidates[i];\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} candidates\n     * @param {number} target\n     * @return {number[][]}\n     */\n    combinationSum2(candidates, target) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<int>> CombinationSum2(int[] candidates, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/FOyRpNUSFeA"},{"id":"palindrome-partitioning","name":"Palindrome Partitioning","description":"Given a string `s`, split `s` into substrings where every substring is a palindrome. Return all possible lists of palindromic substrings.\n\nYou may return the solution in **any order**.\n\n**Example 1:**\n\n```java\nInput: s = \"aab\"\n\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n```\n\n**Example 2:**\n\n```java\nInput: s = \"a\"\n\nOutput: [[\"a\"]]\n```\n\n**Constraints:**\n* `1 <= s.length <= 20`\n* `s` contains only lowercase English letters.\n","difficulty":"Medium","concepts":["Tree Maze"],"solutions":{"python":"class Solution:\n    \n    def partition(self, s: str) -> List[List[str]]:\n        res, part = [], []\n\n        def dfs(i):\n            if i >= len(s):\n                res.append(part.copy())\n                return\n            for j in range(i, len(s)):\n                if self.isPali(s, i, j):\n                    part.append(s[i : j + 1])\n                    dfs(j + 1)\n                    part.pop()\n\n        dfs(0)\n        return res\n\n    def isPali(self, s, l, r):\n        while l < r:\n            if s[l] != s[r]:\n                return False\n            l, r = l + 1, r - 1\n        return True\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {string[][]}\n     */\n    partition(s) {\n        const res = [];\n        const part = [];\n        this.dfs(0, s, part, res);\n        return res;\n    }\n\n    /**\n     * @param {number} i\n     * @param {string} s\n     * @param {string[]} part\n     * @param {string[][]} res\n     * @return {void}\n     */\n    dfs(i, s, part, res) {\n        if (i >= s.length) {\n            res.push([...part]);\n            return;\n        }\n        for (let j = i; j < s.length; j++) {\n            if (this.isPali(s, i, j)) {\n                part.push(s.substring(i, j + 1));\n                this.dfs(j + 1, s, part, res);\n                part.pop();\n            }\n        }\n    }\n\n    /**\n     * @param {string} s\n     * @param {number} l\n     * @param {number} r\n     * @return {boolean}\n     */\n    isPali(s, l, r) {\n        while (l < r) {\n            if (s[l] !== s[r]) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        vector<vector<string>> res;\n        vector<string> part;\n        dfs(0, s, part, res);\n        return res;\n    }\n\nprivate:\n    void dfs(int i, const string& s, vector<string>& part, vector<vector<string>>& res) {\n        if (i >= s.length()) {\n            res.push_back(part);\n            return;\n        }\n        for (int j = i; j < s.length(); j++) {\n            if (isPali(s, i, j)) {\n                part.push_back(s.substr(i, j - i + 1));\n                dfs(j + 1, s, part, res);\n                part.pop_back();\n            }\n        }\n    }\n\n    bool isPali(const string& s, int l, int r) {\n        while (l < r) {\n            if (s[l] != s[r]) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n};\n","java":"class Solution {\n    \n    public List<List<String>> partition(String s) {\n        List<List<String>> res = new ArrayList<>();\n        List<String> part = new ArrayList<>();\n        dfs(0, s, part, res);\n        return res;\n    }\n\n    private void dfs(int i, String s, List<String> part, List<List<String>> res) {\n        if (i >= s.length()) {\n            res.add(new ArrayList<>(part));\n            return;\n        }\n        for (int j = i; j < s.length(); j++) {\n            if (isPali(s, i, j)) {\n                part.add(s.substring(i, j + 1));\n                dfs(j + 1, s, part, res);\n                part.remove(part.size() - 1);\n            }\n        }\n    }\n\n    private boolean isPali(String s, int l, int r) {\n        while (l < r) {\n            if (s.charAt(l) != s.charAt(r)) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<List<string>> Partition(string s) {\n        List<List<string>> res = new List<List<string>>();\n        List<string> part = new List<string>();\n        Dfs(0, s, part, res);\n        return res;\n    }\n\n    private void Dfs(int i, string s, List<string> part, List<List<string>> res) {\n        if (i >= s.Length) {\n            res.Add(new List<string>(part));\n            return;\n        }\n        for (int j = i; j < s.Length; j++) {\n            if (IsPali(s, i, j)) {\n                part.Add(s.Substring(i, j - i + 1));\n                Dfs(j + 1, s, part, res);\n                part.RemoveAt(part.Count - 1);\n            }\n        }\n    }\n\n    private bool IsPali(string s, int l, int r) {\n        while (l < r) {\n            if (s[l] != s[r]) {\n                return false;\n            }\n            l++;\n            r--;\n        }\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @return {string[][]}\n     */\n    partition(s) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<string>> partition(string s) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<String>> partition(String s) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<string>> Partition(string s) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/3jvWodd7ht0"},{"id":"combinations-of-a-phone-number","name":"Combinations of a Phone Number","description":"You are given a string `digits` made up of digits from `2` through `9` inclusive.\n\nEach digit (not including 1) is mapped to a set of characters as shown below:\n\nA digit could represent any one of the characters it maps to.\n\nReturn all possible letter combinations that `digits` could represent. You may return the answer in **any order**.\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/796a0dc1-2fcd-4ebb-0686-28f9007ec800/public)\n\n**Example 1:**\n\n```java\nInput: digits = \"34\"\n\nOutput: [\"dg\",\"dh\",\"di\",\"eg\",\"eh\",\"ei\",\"fg\",\"fh\",\"fi\"]\n```\n\n**Example 2:**\n\n```java\nInput: digits = \"\"\n\nOutput: []\n```\n\n**Constraints:**\n* `0 <= digits.length <= 4`\n* `2 <= digits[i] <= 9`\n","difficulty":"Medium","concepts":["Tree Maze"],"solutions":{"python":"class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        res = []\n        digitToChar = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"qprs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n\n        def backtrack(i, curStr):\n            if len(curStr) == len(digits):\n                res.append(curStr)\n                return\n            for c in digitToChar[digits[i]]:\n                backtrack(i + 1, curStr + c)\n\n        if digits:\n            backtrack(0, \"\")\n\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {string} digits\n     * @return {string[]}\n     */\n    letterCombinations(digits) {\n        const res = [];\n        const digitToChar = {\n            2: 'abc',\n            3: 'def',\n            4: 'ghi',\n            5: 'jkl',\n            6: 'mno',\n            7: 'qprs',\n            8: 'tuv',\n            9: 'wxyz',\n        };\n\n        if (digits) {\n            this.backtrack(0, '', digits, res, digitToChar);\n        }\n\n        return res;\n    }\n\n    /**\n     * @param {number} i\n     * @param {string} curStr\n     * @param {string} digits\n     * @param {string[]} res\n     * @param {Map} digitToChar\n     * @return {void}\n     */\n    backtrack(i, curStr, digits, res, digitToChar) {\n        if (curStr.length === digits.length) {\n            res.push(curStr);\n            return;\n        }\n\n        for (const c of digitToChar[digits[i]]) {\n            this.backtrack(i + 1, curStr + c, digits, res, digitToChar);\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        vector<string> res;\n        if (digits.empty()) {\n            return res;\n        }\n\n        unordered_map<char, string> digitToChar = {\n            {'2', \"abc\"},\n            {'3', \"def\"},\n            {'4', \"ghi\"},\n            {'5', \"jkl\"},\n            {'6', \"mno\"},\n            {'7', \"qprs\"},\n            {'8', \"tuv\"},\n            {'9', \"wxyz\"}\n        };\n\n        backtrack(0, digits, \"\", res, digitToChar);\n        return res;\n    }\n\nprivate:\n    void backtrack(int i, const string& digits, string curStr, vector<string>& res,\n                   const unordered_map<char, string>& digitToChar) {\n        if (curStr.length() == digits.length()) {\n            res.push_back(curStr);\n            return;\n        }\n\n        for (char c : digitToChar.at(digits[i])) {\n            backtrack(i + 1, digits, curStr + c, res, digitToChar);\n        }\n    }\n};\n","java":"class Solution {\n    \n    public List<String> letterCombinations(String digits) {\n        List<String> res = new ArrayList<>();\n        if (digits.isEmpty()) {\n            return  res;\n        }\n        Map<Character, String> digitToChar = new HashMap<>();\n        digitToChar.put('2', \"abc\");\n        digitToChar.put('3', \"def\");\n        digitToChar.put('4', \"ghi\");\n        digitToChar.put('5', \"jkl\");\n        digitToChar.put('6', \"mno\");\n        digitToChar.put('7', \"qprs\");\n        digitToChar.put('8', \"tuv\");\n        digitToChar.put('9', \"wxyz\");\n\n        backtrack(0, digits, \"\", res, digitToChar);\n        return res;\n    }\n\n    private void backtrack(int i, String digits, String curStr, List<String> res, Map<Character, String> digitToChar) {\n        if (curStr.length() == digits.length()) {\n            res.add(curStr);\n            return;\n        }\n        for (char c : digitToChar.get(digits.charAt(i)).toCharArray()) {\n            backtrack(i + 1, digits, curStr + c, res, digitToChar);\n        }\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<string> LetterCombinations(string digits) {\n        List<string> res = new List<string>();\n        if (string.IsNullOrEmpty(digits)) {\n            return res;\n        }\n\n        Dictionary<char, string> digitToChar = new Dictionary<char, string> {\n            {'2', \"abc\"},\n            {'3', \"def\"},\n            {'4', \"ghi\"},\n            {'5', \"jkl\"},\n            {'6', \"mno\"},\n            {'7', \"qprs\"},\n            {'8', \"tuv\"},\n            {'9', \"wxyz\"}\n        };\n\n        Backtrack(0, digits, \"\", res, digitToChar);\n        return res;\n    }\n\n    private void Backtrack(int i, string digits, string curStr, List<string> res, Dictionary<char, string> digitToChar) {\n        if (curStr.Length == digits.Length) {\n            res.Add(curStr);\n            return;\n        }\n\n        foreach (char c in digitToChar[digits[i]]) {\n            Backtrack(i + 1, digits, curStr + c, res, digitToChar);\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def letterCombinations(self, digits: str) -> List[str]:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} digits\n     * @return {string[]}\n     */\n    letterCombinations(digits) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<string> letterCombinations(string digits) {\n        \n    }\n};\n","java":"class Solution {\n    public List<String> letterCombinations(String digits) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<string> LetterCombinations(string digits) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/0snEunUacZY"},{"id":"n-queens","name":"N-Queens","description":"The **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard so that no two queens can attack each other.\n\nA **queen** in a chessboard can attack horizontally, vertically, and diagonally.\n\nGiven an integer `n`, return all distinct solutions to the **n-queens puzzle**.\n\nEach solution contains a unique board layout where the queen pieces are placed. `'Q'` indicates a queen and `'.'` indicates an empty space.\n\nYou may return the answer in **any order**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/cdf2b34d-7905-4388-db0b-9a120ebf4a00/public)\n\n```java\nInput: n = 4\n\nOutput: [[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]\n```\n\nExplanation: There are two different solutions to the 4-queens puzzle.\n\n**Example 2:**\n\n```java\nInput: n = 1\n\nOutput: [[\"Q\"]]\n```\n\n**Constraints:**\n* `1 <= n <= 8`\n","difficulty":"Hard","concepts":["Tree Maze"],"solutions":{"python":"class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        col = set()\n        posDiag = set()\n        negDiag = set()\n\n        res = []\n        board = [[\".\"] * n for i in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                copy = [\"\".join(row) for row in board]\n                res.append(copy)\n                return\n\n            for c in range(n):\n                if c in col or (r + c) in posDiag or (r - c) in negDiag:\n                    continue\n\n                col.add(c)\n                posDiag.add(r + c)\n                negDiag.add(r - c)\n                board[r][c] = \"Q\"\n\n                backtrack(r + 1)\n\n                col.remove(c)\n                posDiag.remove(r + c)\n                negDiag.remove(r - c)\n                board[r][c] = \".\"\n\n        backtrack(0)\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {string[][]}\n     */\n    solveNQueens(n) {\n        const col = new Set();\n        const posDiag = new Set();\n        const negDiag = new Set();\n\n        const res = [];\n        const board = Array.from({ length: n }, () => Array(n).fill('.'));\n\n        /**\n         * @param {number} r\n         * @return {void}\n         */\n        function backtrack(r) {\n            if (r === n) {\n                res.push(board.map(row => row.join('')));\n                return;\n            }\n\n            for (let c = 0; c < n; c++) {\n                if (col.has(c) || posDiag.has(r + c) || negDiag.has(r - c)) {\n                    continue;\n                }\n\n                col.add(c);\n                posDiag.add(r + c);\n                negDiag.add(r - c);\n                board[r][c] = 'Q';\n\n                backtrack(r + 1);\n\n                col.delete(c);\n                posDiag.delete(r + c);\n                negDiag.delete(r - c);\n                board[r][c] = '.';\n            }\n        }\n\n        backtrack(0);\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        unordered_set<int> col;\n        unordered_set<int> posDiag;\n        unordered_set<int> negDiag;\n\n        vector<vector<string>> res;\n        vector<string> board(n, string(n, '.'));\n\n        backtrack(0, n, col, posDiag, negDiag, board, res);\n        return res;\n    }\n\nprivate:\n    void backtrack(int r, int n, unordered_set<int>& col, unordered_set<int>& posDiag,\n                   unordered_set<int>& negDiag, vector<string>& board,\n                   vector<vector<string>>& res) {\n        if (r == n) {\n            res.push_back(board);\n            return;\n        }\n\n        for (int c = 0; c < n; c++) {\n            if (col.count(c) || posDiag.count(r + c) || negDiag.count(r - c)) {\n                continue;\n            }\n\n            col.insert(c);\n            posDiag.insert(r + c);\n            negDiag.insert(r - c);\n            board[r][c] = 'Q';\n\n            backtrack(r + 1, n, col, posDiag, negDiag, board, res);\n\n            col.erase(c);\n            posDiag.erase(r + c);\n            negDiag.erase(r - c);\n            board[r][c] = '.';\n        }\n    }\n};\n","java":"class Solution {\n    \n    public List<List<String>> solveNQueens(int n) {\n        Set<Integer> col = new HashSet<>();\n        Set<Integer> posDiag = new HashSet<>();\n        Set<Integer> negDiag = new HashSet<>();\n\n        List<List<String>> res = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (char[] row : board) {\n            Arrays.fill(row, '.');\n        }\n\n        backtrack(0, n, col, posDiag, negDiag, board, res);\n        return res;\n    }\n\n    private void backtrack(int r, int n, Set<Integer> col, Set<Integer> posDiag, Set<Integer> negDiag,\n                           char[][] board, List<List<String>> res) {\n        if (r == n) {\n            List<String> copy = new ArrayList<>();\n            for (char[] row : board) {\n                copy.add(new String(row));\n            }\n            res.add(copy);\n            return;\n        }\n\n        for (int c = 0; c < n; c++) {\n            if (col.contains(c) || posDiag.contains(r + c) || negDiag.contains(r - c)) {\n                continue;\n            }\n\n            col.add(c);\n            posDiag.add(r + c);\n            negDiag.add(r - c);\n            board[r][c] = 'Q';\n\n            backtrack(r + 1, n, col, posDiag, negDiag, board, res);\n\n            col.remove(c);\n            posDiag.remove(r + c);\n            negDiag.remove(r - c);\n            board[r][c] = '.';\n        }\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<List<string>> SolveNQueens(int n) {\n        HashSet<int> col = new HashSet<int>();\n        HashSet<int> posDiag = new HashSet<int>();\n        HashSet<int> negDiag = new HashSet<int>();\n\n        List<List<string>> res = new List<List<string>>();\n        char[][] board = new char[n][];\n        for (int i = 0; i < n; i++) {\n            board[i] = new char[n];\n            Array.Fill(board[i], '.');\n        }\n\n        Backtrack(0, n, col, posDiag, negDiag, board, res);\n        return res;\n    }\n\n    private void Backtrack(int r, int n, HashSet<int> col, HashSet<int> posDiag, HashSet<int> negDiag,\n                           char[][] board, List<List<string>> res) {\n        if (r == n) {\n            List<string> copy = new List<string>();\n            foreach (char[] row in board) {\n                copy.Add(new string(row));\n            }\n            res.Add(copy);\n            return;\n        }\n\n        for (int c = 0; c < n; c++) {\n            if (col.Contains(c) || posDiag.Contains(r + c) || negDiag.Contains(r - c)) {\n                continue;\n            }\n\n            col.Add(c);\n            posDiag.Add(r + c);\n            negDiag.Add(r - c);\n            board[r][c] = 'Q';\n\n            Backtrack(r + 1, n, col, posDiag, negDiag, board, res);\n\n            col.Remove(c);\n            posDiag.Remove(r + c);\n            negDiag.Remove(r - c);\n            board[r][c] = '.';\n        }\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {string[][]}\n     */\n    solveNQueens(n) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<vector<string>> solveNQueens(int n) {\n        \n    }\n};\n","java":"class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<List<string>> SolveNQueens(int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Ph95IHmRp5M"},{"id":"max-area-of-island","name":"Max Area of Island","description":"You are given a matrix `grid` where `grid[i]` is either a `0` (representing water) or `1` (representing land).\n    \nAn island is defined as a group of `1`'s connected horizontally or vertically. You may assume all four edges of the grid are surrounded by water.\n\nThe **area** of an island is defined as the number of cells within the island.\n\nReturn the maximum **area** of an island in `grid`. If no island exists, return `0`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/8eeb491c-c8ff-4ed6-78ed-ce4cf87d7200/public)\n\n```java\nInput: grid = [\n  [0,1,1,0,1],\n  [1,0,1,0,1],\n  [0,1,1,0,1],\n  [0,1,0,0,1]\n]\n\nOutput: 6\n```\nExplanation: `1`'s cannot be connected diagonally, so the maximum area of the island is `6`.\n\n**Constraints:**\n* `1 <= grid.length, grid[i].length <= 50`\n","difficulty":"Medium","concepts":["Matrix DFS","Matrix BFS"],"solutions":{"python":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ROWS, COLS = len(grid), len(grid[0])\n        visit = set()\n\n        def dfs(r, c):\n            if (\n                r < 0\n                or r == ROWS\n                or c < 0\n                or c == COLS\n                or grid[r][c] == 0\n                or (r, c) in visit\n            ):\n                return 0\n            visit.add((r, c))\n            return 1 + dfs(r + 1, c) + dfs(r - 1, c) + dfs(r, c + 1) + dfs(r, c - 1)\n\n        area = 0\n        for r in range(ROWS):\n            for c in range(COLS):\n                area = max(area, dfs(r, c))\n        return area\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     * @return {number}\n     */\n    maxAreaOfIsland(grid) {\n        const ROWS = grid.length;\n        const COLS = grid[0].length;\n        const visit = new Set();\n\n        /**\n         * @param {number} r\n         * @param {number} c\n         * @return {number}\n         */\n        function dfs(r, c) {\n            if (\n                r < 0 ||\n                r === ROWS ||\n                c < 0 ||\n                c === COLS ||\n                grid[r][c] === 0 ||\n                visit.has(`${r},${c}`)\n            ) {\n                return 0;\n            }\n            visit.add(`${r},${c}`);\n            return (\n                1 +\n                dfs(r + 1, c) +\n                dfs(r - 1, c) +\n                dfs(r, c + 1) +\n                dfs(r, c - 1)\n            );\n        }\n\n        let area = 0;\n        for (let r = 0; r < ROWS; r++) {\n            for (let c = 0; c < COLS; c++) {\n                area = Math.max(area, dfs(r, c));\n            }\n        }\n        return area;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        int ROWS = grid.size();\n        int COLS = grid[0].size();\n        unordered_set<string> visit;\n\n        int area = 0;\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (grid[r][c] == 1 && visit.count(to_string(r) + \",\" + to_string(c)) == 0) {\n                    area = max(area, Dfs(grid, r, c, visit));\n                }\n            }\n        }\n        return area;\n    }\n\n    int Dfs(vector<vector<int>>& grid, int r, int c, unordered_set<string>& visit) {\n        if (r < 0 || r == grid.size() || c < 0 || c == grid[0].size() || grid[r][c] == 0 || visit.count(to_string(r) + \",\" + to_string(c))) {\n            return 0;\n        }\n        visit.insert(to_string(r) + \",\" + to_string(c));\n        return 1 + Dfs(grid, r + 1, c, visit) + Dfs(grid, r - 1, c, visit) + Dfs(grid, r, c + 1, visit) + Dfs(grid, r, c - 1, visit);\n    }\n};\n","java":"class Solution {\n    \n    public int maxAreaOfIsland(int[][] grid) {\n        int ROWS = grid.length;\n        int COLS = grid[0].length;\n        Set<String> visit = new HashSet<>();\n\n        int area = 0;\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                area = Math.max(area, dfs(grid, visit, r, c));\n            }\n        }\n        return area;\n    }\n\n    private int dfs(int[][] grid, Set<String> visit, int r, int c) {\n        int ROWS = grid.length;\n        int COLS = grid[0].length;\n\n        if (r < 0 || r == ROWS || c < 0 || c == COLS || grid[r][c] == 0 || visit.contains(r + \",\" + c)) {\n            return 0;\n        }\n        visit.add(r + \",\" + c);\n        return 1 + dfs(grid, visit, r + 1, c) + dfs(grid, visit, r - 1, c) + dfs(grid, visit, r, c + 1) + dfs(grid, visit, r, c - 1);\n    }\n}\n","csharp":"public class Solution {\n    \n    public int MaxAreaOfIsland(int[][] grid) {\n        int ROWS = grid.Length;\n        int COLS = grid[0].Length;\n        HashSet<string> visit = new HashSet<string>();\n\n        int area = 0;\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (grid[r][c] == 1 && !visit.Contains(r + \",\" + c)) {\n                    area = Math.Max(area, Dfs(grid, r, c, visit));\n                }\n            }\n        }\n        return area;\n    }\n\n    private int Dfs(int[][] grid, int r, int c, HashSet<string> visit) {\n        if (r < 0 || r == grid.Length || c < 0 || c == grid[0].Length || grid[r][c] == 0 || visit.Contains(r + \",\" + c)) {\n            return 0;\n        }\n        visit.Add(r + \",\" + c);\n        return 1 + Dfs(grid, r + 1, c, visit) + Dfs(grid, r - 1, c, visit) + Dfs(grid, r, c + 1, visit) + Dfs(grid, r, c - 1, visit);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     * @return {number}\n     */\n    maxAreaOfIsland(grid) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxAreaOfIsland(vector<vector<int>>& grid) {\n        \n    }\n};\n","java":"class Solution {\n    public int maxAreaOfIsland(int[][] grid) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxAreaOfIsland(int[][] grid) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/iJGr1OtmH0c"},{"id":"surrounded-regions","name":"Surrounded Regions","description":"You are given a 2-D matrix `board` containing `'X'` and `'O'` characters.\n\nIf a continous, four-directionally connected group of `'O'`s is surrounded by `'X'`s, it is considered to be **surrounded**. \n\nChange all **surrounded** regions of `'O'`s to `'X'`s and do so **in-place** by modifying the input board.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9e6916bf-0e25-4e15-9619-cbc42d2d8f00/public)\n\n```java\nInput: board = [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"O\",\"O\",\"X\"],\n  [\"X\",\"O\",\"O\",\"X\"],\n  [\"X\",\"X\",\"X\",\"O\"]\n]\n\nOutput: [\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"X\"],\n  [\"X\",\"X\",\"X\",\"O\"]\n]\n```\n\nExplanation: Note that regions that are on the border are not considered surrounded regions.\n\n**Constraints:**\n* `1 <= board.length, board[i].length <= 200`\n* `board[i][j]` is `'X'` or `'O'`.\n","difficulty":"Medium","concepts":["Matrix DFS"],"solutions":{"python":"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ROWS, COLS = len(board), len(board[0])\n\n        def capture(r, c):\n            if r < 0 or c < 0 or r == ROWS or c == COLS or board[r][c] != \"O\":\n                return\n            board[r][c] = \"T\"\n            capture(r + 1, c)\n            capture(r - 1, c)\n            capture(r, c + 1)\n            capture(r, c - 1)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\" and (r in [0, ROWS - 1] or c in [0, COLS - 1]):\n                    capture(r, c)\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"O\":\n                    board[r][c] = \"X\"\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                if board[r][c] == \"T\":\n                    board[r][c] = \"O\"\n","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @return {void} Do not return anything, modify board in-place instead.\n     */\n    solve(board) {\n        const ROWS = board.length;\n        if (ROWS === 0) return;\n        const COLS = board[0].length;\n\n        for (let r = 0; r < ROWS; r++) {\n            for (let c = 0; c < COLS; c++) {\n                if (\n                    board[r][c] === 'O' &&\n                    (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1)\n                ) {\n                    this.capture(board, r, c);\n                }\n            }\n        }\n\n        for (let r = 0; r < ROWS; r++) {\n            for (let c = 0; c < COLS; c++) {\n                if (board[r][c] === 'O') {\n                    board[r][c] = 'X';\n                }\n            }\n        }\n\n        for (let r = 0; r < ROWS; r++) {\n            for (let c = 0; c < COLS; c++) {\n                if (board[r][c] === 'T') {\n                    board[r][c] = 'O';\n                }\n            }\n        }\n    }\n\n    /**\n     * @param {character[][]} board\n     * @param {number} r\n     * @param {number} c\n     * @return {void}\n     */\n    capture(board, r, c) {\n        const ROWS = board.length;\n        const COLS = board[0].length;\n\n        if (r < 0 || c < 0 || r === ROWS || c === COLS || board[r][c] !== 'O') {\n            return;\n        }\n        board[r][c] = 'T';\n        this.capture(board, r + 1, c);\n        this.capture(board, r - 1, c);\n        this.capture(board, r, c + 1);\n        this.capture(board, r, c - 1);\n    }\n}\n","cpp":"class Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        int ROWS = board.size();\n        if (ROWS == 0) return;\n        int COLS = board[0].size();\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'O' && (r == 0 || c == 0 || r == ROWS - 1 || c == COLS - 1)) {\n                    capture(board, r, c);\n                }\n            }\n        }\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'O') {\n                    board[r][c] = 'X';\n                }\n            }\n        }\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'T') {\n                    board[r][c] = 'O';\n                }\n            }\n        }\n    }\n\nprivate:\n    void capture(vector<vector<char>>& board, int r, int c) {\n        int ROWS = board.size();\n        int COLS = board[0].size();\n\n        if (r < 0 || c < 0 || r == ROWS || c == COLS || board[r][c] != 'O') {\n            return;\n        }\n        board[r][c] = 'T';\n        capture(board, r + 1, c);\n        capture(board, r - 1, c);\n        capture(board, r, c + 1);\n        capture(board, r, c - 1);\n    }\n};\n","java":"class Solution {\n    \n    public void solve(char[][] board) {\n        int ROWS = board.length;\n        if (ROWS == 0) return;\n        int COLS = board[0].length;\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'O' && (r == 0 || c == 0 || r == ROWS - 1 || c == COLS - 1)) {\n                    capture(board, r, c);\n                }\n            }\n        }\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'O') {\n                    board[r][c] = 'X';\n                }\n            }\n        }\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'T') {\n                    board[r][c] = 'O';\n                }\n            }\n        }\n    }\n\n    private void capture(char[][] board, int r, int c) {\n        int ROWS = board.length;\n        int COLS = board[0].length;\n\n        if (r < 0 || c < 0 || r == ROWS || c == COLS || board[r][c] != 'O') {\n            return;\n        }\n        board[r][c] = 'T';\n        capture(board, r + 1, c);\n        capture(board, r - 1, c);\n        capture(board, r, c + 1);\n        capture(board, r, c - 1);\n    }\n}\n","csharp":"public class Solution {\n    \n    public void Solve(char[][] board) {\n        int ROWS = board.Length;\n        if (ROWS == 0) return;\n        int COLS = board[0].Length;\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'O' && (r == 0 || c == 0 || r == ROWS - 1 || c == COLS - 1)) {\n                    Capture(board, r, c);\n                }\n            }\n        }\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'O') {\n                    board[r][c] = 'X';\n                }\n            }\n        }\n\n        for (int r = 0; r < ROWS; r++) {\n            for (int c = 0; c < COLS; c++) {\n                if (board[r][c] == 'T') {\n                    board[r][c] = 'O';\n                }\n            }\n        }\n    }\n\n    private void Capture(char[][] board, int r, int c) {\n        int ROWS = board.Length;\n        int COLS = board[0].Length;\n\n        if (r < 0 || c < 0 || r == ROWS || c == COLS || board[r][c] != 'O') {\n            return;\n        }\n        board[r][c] = 'T';\n        Capture(board, r + 1, c);\n        Capture(board, r - 1, c);\n        Capture(board, r, c + 1);\n        Capture(board, r, c - 1);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def solve(self, board: List[List[str]]) -> None:\n        ","javascript":"class Solution {\n    /**\n     * @param {character[][]} board\n     * @return {void} Do not return anything, modify board in-place instead.\n     */\n    solve(board) {}\n}\n","cpp":"class Solution {\npublic:\n    void solve(vector<vector<char>>& board) {\n        \n    }\n};\n","java":"class Solution {\n    public void solve(char[][] board) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public void Solve(char[][] board) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/9z2BunfoZ5Y"},{"id":"rotting-fruit","name":"Rotting Fruit","description":"You are given a 2-D matrix `grid`. Each cell can have one of three possible values:\n* `0` representing an empty cell\n* `1` representing a fresh fruit\n* `2` representing a rotten fruit\n\nEvery second, if a fresh fruit is horizontally or vertically adjacent to a rotten fruit, then the fresh fruit also becomes rotten.\n\nReturn the minimum number of seconds that must elapse until there are zero fresh fruits remaining. If this state is impossible within the grid, return `-1`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5daa219c-ae90-4027-41c3-6ea4d9158300/public)\n\n```java\nInput: grid = [[1,1,0],[0,1,1],[0,1,2]]\n\nOutput: 4\n```\n\n**Example 2:**\n\n```java\nInput: grid = [[1,0,1],[0,2,0],[1,0,1]]\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= grid.length, grid[i].length <= 10`\n","difficulty":"Medium","concepts":["Matrix BFS"],"solutions":{"python":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        q = collections.deque()\n        fresh = 0\n        time = 0\n\n        for r in range(len(grid)):\n            for c in range(len(grid[0])):\n                if grid[r][c] == 1:\n                    fresh += 1\n                if grid[r][c] == 2:\n                    q.append((r, c))\n\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n        while fresh > 0 and q:\n            length = len(q)\n            for i in range(length):\n                r, c = q.popleft()\n\n                for dr, dc in directions:\n                    row, col = r + dr, c + dc\n                    if (\n                        row in range(len(grid))\n                        and col in range(len(grid[0]))\n                        and grid[row][col] == 1\n                    ):\n                        grid[row][col] = 2\n                        q.append((row, col))\n                        fresh -= 1\n            time += 1\n        return time if fresh == 0 else -1\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     * @return {number}\n     */\n    orangesRotting(grid) {\n        const q = [];\n        let fresh = 0;\n        let time = 0;\n\n        for (let r = 0; r < grid.length; r++) {\n            for (let c = 0; c < grid[0].length; c++) {\n                if (grid[r][c] === 1) {\n                    fresh++;\n                }\n                if (grid[r][c] === 2) {\n                    q.push([r, c]);\n                }\n            }\n        }\n\n        const directions = [\n            [0, 1],\n            [0, -1],\n            [1, 0],\n            [-1, 0],\n        ];\n        while (fresh > 0 && q.length > 0) {\n            const length = q.length;\n            for (let i = 0; i < length; i++) {\n                const [currR, currC] = q.shift();\n\n                for (const [dr, dc] of directions) {\n                    const row = currR + dr;\n                    const col = currC + dc;\n                    if (\n                        row >= 0 &&\n                        row < grid.length &&\n                        col >= 0 &&\n                        col < grid[0].length &&\n                        grid[row][col] === 1\n                    ) {\n                        grid[row][col] = 2;\n                        q.push([row, col]);\n                        fresh--;\n                    }\n                }\n            }\n            time++;\n        }\n        return fresh === 0 ? time : -1;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        queue<pair<int, int>> q;\n        int fresh = 0;\n        int time = 0;\n\n        for (int r = 0; r < grid.size(); r++) {\n            for (int c = 0; c < grid[0].size(); c++) {\n                if (grid[r][c] == 1) {\n                    fresh++;\n                }\n                if (grid[r][c] == 2) {\n                    q.push({r, c});\n                }\n            }\n        }\n\n        vector<pair<int, int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while (fresh > 0 && !q.empty()) {\n            int length = q.size();\n            for (int i = 0; i < length; i++) {\n                auto curr = q.front();\n                q.pop();\n                int r = curr.first;\n                int c = curr.second;\n\n                for (const auto& dir : directions) {\n                    int row = r + dir.first;\n                    int col = c + dir.second;\n                    if (row >= 0 && row < grid.size() && col >= 0 && col < grid[0].size()\n                            && grid[row][col] == 1) {\n                        grid[row][col] = 2;\n                        q.push({row, col});\n                        fresh--;\n                    }\n                }\n            }\n            time++;\n        }\n        return fresh == 0 ? time : -1;\n    }\n};\n","java":"class Solution {\n    public int orangesRotting(int[][] grid) {\n        Queue<int[]> q = new ArrayDeque<>();\n        int fresh = 0;\n        int time = 0;\n\n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                if (grid[r][c] == 1) {\n                    fresh++;\n                }\n                if (grid[r][c] == 2) {\n                    q.offer(new int[]{r, c});\n                }\n            }\n        }\n\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n        while (fresh > 0 && !q.isEmpty()) {\n            int length = q.size();\n            for (int i = 0; i < length; i++) {\n                int[] curr = q.poll();\n                int r = curr[0];\n                int c = curr[1];\n\n                for (int[] dir : directions) {\n                    int row = r + dir[0];\n                    int col = c + dir[1];\n                    if (row >= 0 && row < grid.length && col >= 0 && col < grid[0].length\n                            && grid[row][col] == 1) {\n                        grid[row][col] = 2;\n                        q.offer(new int[]{row, col});\n                        fresh--;\n                    }\n                }\n            }\n            time++;\n        }\n        return fresh == 0 ? time : -1;\n    }\n}\n","csharp":"public class Solution {\n    public int OrangesRotting(int[][] grid) {\n        Queue<int[]> q = new Queue<int[]>();\n        int fresh = 0;\n        int time = 0;\n\n        for (int r = 0; r < grid.Length; r++) {\n            for (int c = 0; c < grid[0].Length; c++) {\n                if (grid[r][c] == 1) {\n                    fresh++;\n                }\n                if (grid[r][c] == 2) {\n                    q.Enqueue(new int[] { r, c });\n                }\n            }\n        }\n\n        int[][] directions = { new int[] { 0, 1 }, new int[] { 0, -1 }, new int[] { 1, 0 }, new int[] { -1, 0 } };\n        while (fresh > 0 && q.Count > 0) {\n            int length = q.Count;\n            for (int i = 0; i < length; i++) {\n                int[] curr = q.Dequeue();\n                int r = curr[0];\n                int c = curr[1];\n\n                foreach (int[] dir in directions) {\n                    int row = r + dir[0];\n                    int col = c + dir[1];\n                    if (row >= 0 && row < grid.Length && col >= 0 && col < grid[0].Length\n                            && grid[row][col] == 1) {\n                        grid[row][col] = 2;\n                        q.Enqueue(new int[] { row, col });\n                        fresh--;\n                    }\n                }\n            }\n            time++;\n        }\n        return fresh == 0 ? time : -1;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     * @return {number}\n     */\n    orangesRotting(grid) {}\n}\n","cpp":"class Solution {\npublic:\n    int orangesRotting(vector<vector<int>>& grid) {\n        \n    }\n};\n","java":"class Solution {\n    public int orangesRotting(int[][] grid) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int OrangesRotting(int[][] grid) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/y704fEOx0s0"},{"id":"course-schedule-ii","name":"Course Schedule II","description":"You are given an array `prerequisites` where `prerequisites[i] = [a, b]` indicates that you **must** take course `b` first if you want to take course `a`.\n\n* For example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nThere are a total of `numCourses` courses you are required to take, labeled from `0` to `numCourses - 1`. \n\nReturn a valid ordering of courses you can take to finish all courses. If there are many valid answers, return **any** of them. If it's not possible to finish all courses, return an **empty array**.\n\n**Example 1:**\n\n```java\nInput: numCourses = 3, prerequisites = [[1,0]]\n\nOutput: [0,1,2]\n```\n\nExplanation: We must ensure that course 0 is taken before course 1.\n\n**Example 2:**\n\n```java\nInput: numCourses = 3, prerequisites = [[0,1],[1,2],[2,0]]\n\nOutput: []\n```\n\nExplanation: It's impossible to finish all courses.\n\n**Constraints:**\n* `1 <= numCourses <= 1000`\n* `0 <= prerequisites.length <= 1000`\n* All `prerequisite` pairs are **unique**.\n","difficulty":"Medium","concepts":["Adjacency List"],"solutions":{"python":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        prereq = {c: [] for c in range(numCourses)}\n        for crs, pre in prerequisites:\n            prereq[crs].append(pre)\n\n        output = []\n        visit, cycle = set(), set()\n\n        def dfs(crs):\n            if crs in cycle:\n                return False\n            if crs in visit:\n                return True\n\n            cycle.add(crs)\n            for pre in prereq[crs]:\n                if dfs(pre) == False:\n                    return False\n            cycle.remove(crs)\n            visit.add(crs)\n            output.append(crs)\n            return True\n\n        for c in range(numCourses):\n            if dfs(c) == False:\n                return []\n        return output\n","javascript":"class Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {number[]}\n     */\n    findOrder(numCourses, prerequisites) {\n        const prereq = new Map();\n        for (const [course, pre] of prerequisites) {\n            if (!prereq.has(course)) {\n                prereq.set(course, []);\n            }\n            prereq.get(course).push(pre);\n        }\n\n        const output = [];\n        const visit = new Set();\n        const cycle = new Set();\n\n        for (let c = 0; c < numCourses; c++) {\n            if (!this.dfs(c, prereq, visit, cycle, output)) {\n                return [];\n            }\n        }\n\n        return output;\n    }\n\n    /**\n     * @param {number} course\n     * @param {Map} prereq\n     * @param {Set} visit\n     * @param {Set} cycle\n     * @param {number[]} output\n     * @return {boolean}\n     */\n    dfs(course, prereq, visit, cycle, output) {\n        if (cycle.has(course)) {\n            return false;\n        }\n        if (visit.has(course)) {\n            return true;\n        }\n\n        cycle.add(course);\n        for (const pre of prereq.get(course) || []) {\n            if (!this.dfs(pre, prereq, visit, cycle, output)) {\n                return false;\n            }\n        }\n        cycle.delete(course);\n        visit.add(course);\n        output.push(course);\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        unordered_map<int, vector<int>> prereq;\n        for (const auto& pair : prerequisites) {\n            prereq[pair[0]].push_back(pair[1]);\n        }\n\n        vector<int> output;\n        unordered_set<int> visit;\n        unordered_set<int> cycle;\n\n        for (int course = 0; course < numCourses; course++) {\n            if (!dfs(course, prereq, visit, cycle, output)) {\n                return {};\n            }\n        }\n\n        return output;\n    }\n\nprivate:\n    bool dfs(int course, const unordered_map<int, vector<int>>& prereq,\n             unordered_set<int>& visit, unordered_set<int>& cycle, vector<int>& output) {\n        if (cycle.count(course)) {\n            return false;\n        }\n        if (visit.count(course)) {\n            return true;\n        }\n\n        cycle.insert(course);\n        if (prereq.count(course)) {\n            for (int pre : prereq.at(course)) {\n                if (!dfs(pre, prereq, visit, cycle, output)) {\n                    return false;\n                }\n            }\n        }\n        cycle.erase(course);\n        visit.insert(course);\n        output.push_back(course);\n        return true;\n    }\n};\n","java":"class Solution {\n    \n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        Map<Integer, List<Integer>> prereq = new HashMap<>();\n        for (int[] pair : prerequisites) {\n            prereq.computeIfAbsent(pair[0], k -> new ArrayList<>()).add(pair[1]);\n        }\n\n        List<Integer> output = new ArrayList<>();\n        Set<Integer> visit = new HashSet<>();\n        Set<Integer> cycle = new HashSet<>();\n\n        for (int course = 0; course < numCourses; course++) {\n            if (!dfs(course, prereq, visit, cycle, output)) {\n                return new int[0];\n            }\n        }\n\n        int[] result = new int[numCourses];\n        for (int i = 0; i < numCourses; i++) {\n            result[i] = output.get(i);\n        }\n        return result;\n    }\n\n    private boolean dfs(int course, Map<Integer, List<Integer>> prereq,\n                        Set<Integer> visit, Set<Integer> cycle, List<Integer> output) {\n        if (cycle.contains(course)) {\n            return false;\n        }\n        if (visit.contains(course)) {\n            return true;\n        }\n\n        cycle.add(course);\n        for (int pre : prereq.getOrDefault(course, Collections.emptyList())) {\n            if (!dfs(pre, prereq, visit, cycle, output)) {\n                return false;\n            }\n        }\n        cycle.remove(course);\n        visit.add(course);\n        output.add(course);\n        return true;\n    }\n}\n","csharp":"public class Solution {\n    \n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\n        Dictionary<int, List<int>> prereq = new Dictionary<int, List<int>>();\n        foreach (var pair in prerequisites) {\n            if (!prereq.ContainsKey(pair[0])) {\n                prereq[pair[0]] = new List<int>();\n            }\n            prereq[pair[0]].Add(pair[1]);\n        }\n\n        List<int> output = new List<int>();\n        HashSet<int> visit = new HashSet<int>();\n        HashSet<int> cycle = new HashSet<int>();\n\n        for (int course = 0; course < numCourses; course++) {\n            if (!Dfs(course, prereq, visit, cycle, output)) {\n                return new int[0];\n            }\n        }\n\n        return output.ToArray();\n    }\n\n    private bool Dfs(int course, Dictionary<int, List<int>> prereq,\n                     HashSet<int> visit, HashSet<int> cycle, List<int> output) {\n        if (cycle.Contains(course)) {\n            return false;\n        }\n        if (visit.Contains(course)) {\n            return true;\n        }\n\n        cycle.Add(course);\n        if (prereq.ContainsKey(course)) {\n            foreach (int pre in prereq[course]) {\n                if (!Dfs(pre, prereq, visit, cycle, output)) {\n                    return false;\n                }\n            }\n        }\n        cycle.Remove(course);\n        visit.Add(course);\n        output.Add(course);\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} numCourses\n     * @param {number[][]} prerequisites\n     * @return {number[]}\n     */\n    findOrder(numCourses, prerequisites) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] FindOrder(int numCourses, int[][] prerequisites) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Akt3glAwyfY"},{"id":"redundant-connection","name":"Redundant Connection","description":"You are given a connected **undirected graph** with `n` nodes labeled from `1` to `n`. Initially, it contained no cycles and consisted of `n-1` edges.\n\nWe have now added one additional edge to the graph. The edge has two **different** vertices chosen from `1` to `n`, and was not an edge that previously existed in the graph.\n\nThe graph is represented as an array `edges` of length `n` where `edges[i] = [ai, bi]` represents an edge between nodes `ai` and `bi` in the graph.\n\nReturn an edge that can be removed so that the graph is still a connected non-cyclical graph. If there are multiple answers, return the edge that appears last in the input `edges`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/1a966522-e4d9-4215-18a1-4df7d26c3700/public)\n\n```java\nInput: edges = [[1,2],[1,3],[3,4],[2,4]]\n\nOutput: [2,4]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/5cf17b17-8758-4f0a-8829-99cea143b100/public)\n\n```java\nInput: edges = [[1,2],[1,3],[1,4],[3,4],[4,5]]\n\nOutput: [3,4]\n```\n\n**Constraints:**\n* `n == edges.length`\n* `3 <= n <= 100`\n* `1 <= edges[i][0] < edges[i][1] <= edges.length`\n* There are no repeated edges and no self-loops in the input.\n","difficulty":"Medium","concepts":["Union-Find"],"solutions":{"python":"class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        par = [i for i in range(len(edges) + 1)]\n        rank = [1] * (len(edges) + 1)\n\n        def find(n):\n            p = par[n]\n            while p != par[p]:\n                par[p] = par[par[p]]\n                p = par[p]\n            return p\n\n        def union(n1, n2):\n            p1, p2 = find(n1), find(n2)\n\n            if p1 == p2:\n                return False\n            if rank[p1] > rank[p2]:\n                par[p2] = p1\n                rank[p1] += rank[p2]\n            else:\n                par[p1] = p2\n                rank[p2] += rank[p1]\n            return True\n\n        for n1, n2 in edges:\n            if not union(n1, n2):\n                return [n1, n2]\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} edges\n     * @return {number[]}\n     */\n    findRedundantConnection(edges) {\n        const par = new Array(edges.length + 1).fill(0).map((_, i) => i);\n        const rank = new Array(edges.length + 1).fill(1);\n\n        /**\n         * @param {number} n\n         * @return {number}\n         */\n        function find(n) {\n            let p = par[n];\n            while (p !== par[p]) {\n                par[p] = par[par[p]];\n                p = par[p];\n            }\n            return p;\n        }\n\n        /**\n         * @param {number} n1\n         * @param {number} n2\n         * @return {boolean}\n         */\n        function union(n1, n2) {\n            const p1 = find(n1);\n            const p2 = find(n2);\n\n            if (p1 === p2) {\n                return false;\n            }\n            if (rank[p1] > rank[p2]) {\n                par[p2] = p1;\n                rank[p1] += rank[p2];\n            } else {\n                par[p1] = p2;\n                rank[p2] += rank[p1];\n            }\n            return true;\n        }\n\n        for (const [n1, n2] of edges) {\n            if (!union(n1, n2)) {\n                return [n1, n2];\n            }\n        }\n        return [];\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        int n = edges.size();\n        vector<int> par(n + 1), rank(n + 1, 1);\n        for (int i = 0; i <= n; ++i)\n            par[i] = i;\n\n        for (const auto& edge : edges) {\n            if (!Union(par, rank, edge[0], edge[1]))\n                return vector<int>{ edge[0], edge[1] };\n        }\n        return {};\n    }\n\nprivate:\n    int Find(vector<int>& par, int n) {\n        int p = par[n];\n        while (p != par[p]) {\n            par[p] = par[par[p]];\n            p = par[p];\n        }\n        return p;\n    }\n\n    bool Union(vector<int>& par, vector<int>& rank, int n1, int n2) {\n        int p1 = Find(par, n1);\n        int p2 = Find(par, n2);\n\n        if (p1 == p2)\n            return false;\n        if (rank[p1] > rank[p2]) {\n            par[p2] = p1;\n            rank[p1] += rank[p2];\n        } else {\n            par[p1] = p2;\n            rank[p2] += rank[p1];\n        }\n        return true;\n    }\n};\n","java":"class Solution {\n    \n    public int[] findRedundantConnection(int[][] edges) {\n        int[] par = new int[edges.length + 1];\n        int[] rank = new int[edges.length + 1];\n        for (int i = 0; i < par.length; i++) {\n            par[i] = i;\n            rank[i] = 1;\n        }\n\n        for (int[] edge : edges) {\n            if (!union(par, rank, edge[0], edge[1]))\n                return new int[]{edge[0], edge[1]};\n        }\n        return new int[0];\n    }\n\n    private int find(int[] par, int n) {\n        int p = par[n];\n        while (p != par[p]) {\n            par[p] = par[par[p]];\n            p = par[p];\n        }\n        return p;\n    }\n\n    private boolean union(int[] par, int[] rank, int n1, int n2) {\n        int p1 = find(par, n1);\n        int p2 = find(par, n2);\n\n        if (p1 == p2)\n            return false;\n        if (rank[p1] > rank[p2]) {\n            par[p2] = p1;\n            rank[p1] += rank[p2];\n        } else {\n            par[p1] = p2;\n            rank[p2] += rank[p1];\n        }\n        return true;\n    }\n}\n","csharp":"public class Solution {\n    \n    public int[] FindRedundantConnection(int[][] edges) {\n        int[] par = new int[edges.Length + 1];\n        int[] rank = new int[edges.Length + 1];\n        for (int i = 0; i < par.Length; i++) {\n            par[i] = i;\n            rank[i] = 1;\n        }\n\n        foreach (var edge in edges) {\n            if (!Union(par, rank, edge[0], edge[1]))\n                return new int[]{ edge[0], edge[1] };\n        }\n        return new int[0];\n    }\n\n    private int Find(int[] par, int n) {\n        int p = par[n];\n        while (p != par[p]) {\n            par[p] = par[par[p]];\n            p = par[p];\n        }\n        return p;\n    }\n\n    private bool Union(int[] par, int[] rank, int n1, int n2) {\n        int p1 = Find(par, n1);\n        int p2 = Find(par, n2);\n\n        if (p1 == p2)\n            return false;\n        if (rank[p1] > rank[p2]) {\n            par[p2] = p1;\n            rank[p1] += rank[p2];\n        } else {\n            par[p1] = p2;\n            rank[p2] += rank[p1];\n        }\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} edges\n     * @return {number[]}\n     */\n    findRedundantConnection(edges) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> findRedundantConnection(vector<vector<int>>& edges) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] findRedundantConnection(int[][] edges) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] FindRedundantConnection(int[][] edges) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/FXWRE67PLL0"},{"id":"word-ladder","name":"Word Ladder","description":"You are given two words, `beginWord` and `endWord`, and also a list of words `wordList`. All of the given words are of the same length, consisting of lowercase English letters, and are all distinct.\n\nYour goal is to transform `beginWord` into `endWord` by following the rules:\n    \n* You may transform `beginWord` to any word within `wordList`, provided that at exactly one position the words have a different character, and the rest of the positions have the same characters.\n* You may repeat the previous step with the new word that you obtain, and you may do this as many times as needed.\n\nReturn the **minimum number of words within the transformation sequence** needed to obtain the `endWord`, or `0` if no such sequence exists.\n\n**Example 1:**\n\n```java\nInput: beginWord = \"cat\", endWord = \"sag\", wordList = [\"bat\",\"bag\",\"sag\",\"dag\",\"dot\"]\n\nOutput: 4\n```\n\nExplanation: The transformation sequence is `\"cat\" -> \"bat\" -> \"bag\" -> \"sag\"`.\n\n**Example 2:**\n\n```java\nInput: beginWord = \"cat\", endWord = \"sag\", wordList = [\"bat\",\"bag\",\"sat\",\"dag\",\"dot\"]\n\nOutput: 0\n```\n\nExplanation: There is no possible transformation sequence from `\"cat\"` to `\"sag\"` since the word `\"sag\"` is not in the wordList.\n\n**Constraints:**\n* `1 <= beginWord.length <= 10`\n* `1 <= wordList.length <= 100`\n","difficulty":"Hard","concepts":["Adjacency List"],"solutions":{"python":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n\n        nei = collections.defaultdict(list)\n        wordList.append(beginWord)\n        for word in wordList:\n            for j in range(len(word)):\n                pattern = word[:j] + \"*\" + word[j + 1 :]\n                nei[pattern].append(word)\n\n        visit = set([beginWord])\n        q = deque([beginWord])\n        res = 1\n        while q:\n            for i in range(len(q)):\n                word = q.popleft()\n                if word == endWord:\n                    return res\n                for j in range(len(word)):\n                    pattern = word[:j] + \"*\" + word[j + 1 :]\n                    for neiWord in nei[pattern]:\n                        if neiWord not in visit:\n                            visit.add(neiWord)\n                            q.append(neiWord)\n            res += 1\n        return 0\n","javascript":"class Solution {\n    /**\n     * @param {string} beginWord\n     * @param {string} endWord\n     * @param {string[]} wordList\n     * @return {number}\n     */\n    ladderLength(beginWord, endWord, wordList) {\n        if (!wordList.includes(endWord)) {\n            return 0;\n        }\n\n        const nei = {};\n        wordList.push(beginWord);\n        for (const word of wordList) {\n            for (let j = 0; j < word.length; ++j) {\n                const pattern =\n                    word.substring(0, j) + '*' + word.substring(j + 1);\n                if (!nei[pattern]) {\n                    nei[pattern] = [];\n                }\n                nei[pattern].push(word);\n            }\n        }\n\n        const visit = new Set([beginWord]);\n        const q = [beginWord];\n        let res = 1;\n        while (q.length > 0) {\n            const size = q.length;\n            for (let i = 0; i < size; ++i) {\n                const word = q.shift();\n                if (word === endWord) {\n                    return res;\n                }\n                for (let j = 0; j < word.length; ++j) {\n                    const pattern =\n                        word.substring(0, j) + '*' + word.substring(j + 1);\n                    for (const neiWord of nei[pattern]) {\n                        if (!visit.has(neiWord)) {\n                            visit.add(neiWord);\n                            q.push(neiWord);\n                        }\n                    }\n                }\n            }\n            ++res;\n        }\n        return 0;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        if (endWord.empty() || find(wordList.begin(), wordList.end(), endWord) == wordList.end()) {\n            return 0;\n        }\n\n        unordered_map<string, vector<string>> nei;\n        wordList.push_back(beginWord);\n        for (const string& word : wordList) {\n            for (int j = 0; j < word.size(); ++j) {\n                string pattern = word.substr(0, j) + \"*\" + word.substr(j + 1);\n                nei[pattern].push_back(word);\n            }\n        }\n\n        unordered_set<string> visit{beginWord};\n        queue<string> q;\n        q.push(beginWord);\n        int res = 1;\n        while (!q.empty()) {\n            int size = q.size();\n            for (int i = 0; i < size; ++i) {\n                string word = q.front();\n                q.pop();\n                if (word == endWord) {\n                    return res;\n                }\n                for (int j = 0; j < word.size(); ++j) {\n                    string pattern = word.substr(0, j) + \"*\" + word.substr(j + 1);\n                    for (const string& neiWord : nei[pattern]) {\n                        if (visit.find(neiWord) == visit.end()) {\n                            visit.insert(neiWord);\n                            q.push(neiWord);\n                        }\n                    }\n                }\n            }\n            ++res;\n        }\n        return 0;\n    }\n};\n","java":"class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        if (!wordList.contains(endWord)) {\n            return 0;\n        }\n\n        Map<String, List<String>> nei = new HashMap<>();\n        wordList.add(beginWord);\n        for (String word : wordList) {\n            for (int j = 0; j < word.length(); j++) {\n                String pattern = word.substring(0, j) + \"*\" + word.substring(j + 1);\n                nei.computeIfAbsent(pattern, k -> new ArrayList<>()).add(word);\n            }\n        }\n\n        Set<String> visit = new HashSet<>();\n        Queue<String> q = new LinkedList<>();\n        q.offer(beginWord);\n        int res = 1;\n        while (!q.isEmpty()) {\n            int size = q.size();\n            for (int i = 0; i < size; i++) {\n                String word = q.poll();\n                if (word.equals(endWord)) {\n                    return res;\n                }\n                for (int j = 0; j < word.length(); j++) {\n                    String pattern = word.substring(0, j) + \"*\" + word.substring(j + 1);\n                    for (String neiWord : nei.getOrDefault(pattern, Collections.emptyList())) {\n                        if (!visit.contains(neiWord)) {\n                            visit.add(neiWord);\n                            q.offer(neiWord);\n                        }\n                    }\n                }\n            }\n            res++;\n        }\n        return 0;\n    }\n}\n","csharp":"public class Solution {\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\n        if (!wordList.Contains(endWord)) {\n            return 0;\n        }\n\n        Dictionary<string, List<string>> nei = new Dictionary<string, List<string>>();\n        wordList.Add(beginWord);\n        foreach (string word in wordList) {\n            for (int j = 0; j < word.Length; j++) {\n                string pattern = word.Substring(0, j) + \"*\" + word.Substring(j + 1);\n                if (!nei.ContainsKey(pattern)) {\n                    nei[pattern] = new List<string>();\n                }\n                nei[pattern].Add(word);\n            }\n        }\n\n        HashSet<string> visit = new HashSet<string>();\n        Queue<string> q = new Queue<string>();\n        q.Enqueue(beginWord);\n        int res = 1;\n        while (q.Count > 0) {\n            int size = q.Count;\n            for (int i = 0; i < size; i++) {\n                string word = q.Dequeue();\n                if (word == endWord) {\n                    return res;\n                }\n                for (int j = 0; j < word.Length; j++) {\n                    string pattern = word.Substring(0, j) + \"*\" + word.Substring(j + 1);\n                    if (nei.ContainsKey(pattern)) {\n                        foreach (string neiWord in nei[pattern]) {\n                            if (!visit.Contains(neiWord)) {\n                                visit.Add(neiWord);\n                                q.Enqueue(neiWord);\n                            }\n                        }\n                    }\n                }\n            }\n            res++;\n        }\n        return 0;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} beginWord\n     * @param {string} endWord\n     * @param {string[]} wordList\n     * @return {number}\n     */\n    ladderLength(beginWord, endWord, wordList) {}\n}\n","cpp":"class Solution {\npublic:\n    int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n        \n    }\n};\n","java":"class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LadderLength(string beginWord, string endWord, IList<string> wordList) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/h9iTnkgv05E"},{"id":"reconstruct-flight-path","name":"Reconstruct Flight Path","description":"You are given a list of flight tickets `tickets` where `tickets[i] = [from_i, to_i]` represent the source airport and the destination airport. \n\nEach `from_i` and `to_i` consists of three uppercase English letters.\n\nReconstruct the itinerary in order and return it.\n\nAll of the tickets belong to someone who originally departed from `\"JFK\"`. Your objective is to reconstruct the flight path that this person took, assuming each ticket was used exactly once.\n\nIf there are multiple valid flight paths, return the lexicographically smallest one.\n* For example, the itinerary `[\"JFK\", \"SEA\"]` has a smaller lexical order than `[\"JFK\", \"SFO\"]`.\n\nYou may assume all the tickets form at least one valid flight path.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e5ea2ea5-da22-4c22-a5c1-5840dab7fb00/public)\n\n```java\nInput: tickets = [[\"BUF\",\"HOU\"],[\"HOU\",\"SEA\"],[\"JFK\",\"BUF\"]]\n\nOutput: [\"JFK\",\"BUF\",\"HOU\",\"SEA\"]\n```\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/9bfece1f-1fec-4618-4f95-31b2abcd3100/public)\n\n```java\nInput: tickets = [[\"HOU\",\"JFK\"],[\"SEA\",\"JFK\"],[\"JFK\",\"SEA\"],[\"JFK\",\"HOU\"]]\n\nOutput: [\"JFK\",\"HOU\",\"JFK\",\"SEA\",\"JFK\"]\n```\n\nExplanation: Another possible reconstruction is `[\"JFK\",\"SEA\",\"JFK\",\"HOU\",\"JFK\"]` but it is lexicographically larger.\n\n**Constraints:**\n* `1 <= tickets.length <= 300`\n* `from_i != to_i`\n","difficulty":"Hard","concepts":["Adjacency List"],"solutions":{"python":"class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        adj = {src: [] for src, dst in tickets}\n        res = []\n\n        for src, dst in tickets:\n            adj[src].append(dst)\n\n        for key in adj:\n            adj[key].sort()\n\n        def dfs(adj, result, src):\n            if src in adj:\n                destinations = adj[src][:]\n                while destinations:\n                    dest = destinations[0]\n                    adj[src].pop(0)\n                    dfs(adj, res, dest)\n                    destinations = adj[src][:]\n            res.append(src)\n\n        dfs(adj, res, \"JFK\")\n        res.reverse()\n\n        if len(res) != len(tickets) + 1:\n            return []\n\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {string[][]} tickets\n     * @return {string[]}\n     */\n    findItinerary(tickets) {\n        const adj = {};\n        const res = [];\n\n        for (const [src, dst] of tickets) {\n            if (!(src in adj)) {\n                adj[src] = [];\n            }\n            adj[src].push(dst);\n        }\n\n        for (const key in adj) {\n            adj[key].sort();\n        }\n\n        /**\n         * @param {Map} adj\n         * @param {string[]} result\n         * @param {string} src\n         * @return {void}\n         */\n        function dfs(adj, result, src) {\n            if (src in adj) {\n                let destinations = [...adj[src]];\n                while (destinations.length > 0) {\n                    const dest = destinations.shift();\n                    adj[src].shift();\n                    dfs(adj, res, dest);\n                    destinations = [...adj[src]];\n                }\n            }\n            res.push(src);\n        }\n\n        dfs(adj, res, 'JFK');\n        res.reverse();\n\n        if (res.length !== tickets.length + 1) {\n            return [];\n        }\n\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        map<string, vector<string>> adj;\n        vector<string> res;\n\n        for (const auto& ticket : tickets) {\n            const string& src = ticket[0];\n            const string& dst = ticket[1];\n            adj[src].push_back(dst);\n        }\n\n        for (auto& entry : adj) {\n            sort(entry.second.begin(), entry.second.end());\n        }\n\n        DFS(adj, res, \"JFK\");\n        reverse(res.begin(), res.end());\n\n        if (res.size() != tickets.size() + 1) {\n            return vector<string>();\n        }\n\n        return res;\n    }\n\nprivate:\n    void DFS(map<string, vector<string>>& adj, vector<string>& result, const string& src) {\n        if (adj.find(src) != adj.end()) {\n            vector<string> destinations = adj[src];\n            while (!destinations.empty()) {\n                string dest = destinations[0];\n                adj[src].erase(adj[src].begin());\n                DFS(adj, result, dest);\n                destinations = adj[src];\n            }\n        }\n        result.push_back(src);\n    }\n};\n","java":"class Solution {\n    \n    public List<String> findItinerary(List<List<String>> tickets) {\n        Map<String, List<String>> adj = new HashMap<>();\n        List<String> res = new ArrayList<>();\n\n        for (List<String> ticket : tickets) {\n            String src = ticket.get(0);\n            String dst = ticket.get(1);\n            adj.putIfAbsent(src, new ArrayList<>());\n            adj.get(src).add(dst);\n        }\n\n        for (String key : adj.keySet()) {\n            Collections.sort(adj.get(key));\n        }\n\n        dfs(adj, res, \"JFK\");\n        Collections.reverse(res);\n\n        if (res.size() != tickets.size() + 1) {\n            return new ArrayList<>();\n        }\n\n        return res;\n    }\n\n    private void dfs(Map<String, List<String>> adj, List<String> result, String src) {\n        if (adj.containsKey(src)) {\n            List<String> destinations = new ArrayList<>(adj.get(src));\n            while (!destinations.isEmpty()) {\n                String dest = destinations.get(0);\n                adj.get(src).remove(0);\n                dfs(adj, result, dest);\n                destinations = new ArrayList<>(adj.get(src));\n            }\n        }\n        result.add(src);\n    }\n}\n","csharp":"public class Solution {\n    \n    public List<string> FindItinerary(List<List<string>> tickets) {\n        var adj = new Dictionary<string, List<string>>();\n        var res = new List<string>();\n\n        foreach (var ticket in tickets) {\n            var src = ticket[0];\n            var dst = ticket[1];\n            if (!adj.ContainsKey(src))\n                adj[src] = new List<string>();\n            adj[src].Add(dst);\n        }\n\n        foreach (var key in adj.Keys)\n            adj[key].Sort();\n\n        DFS(adj, res, \"JFK\");\n        res.Reverse();\n\n        if (res.Count != tickets.Count + 1)\n            return new List<string>();\n\n        return res;\n    }\n\n    private void DFS(Dictionary<string, List<string>> adj, List<string> result, string src) {\n        if (adj.ContainsKey(src)) {\n            var destinations = new List<string>(adj[src]);\n            while (destinations.Any()) {\n                var dest = destinations[0];\n                adj[src].RemoveAt(0);\n                DFS(adj, result, dest);\n                destinations = new List<string>(adj[src]);\n            }\n        }\n        result.Add(src);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findItinerary(self, tickets: List[List[str]]) -> List[str]:\n        ","javascript":"class Solution {\n    /**\n     * @param {string[][]} tickets\n     * @return {string[]}\n     */\n    findItinerary(tickets) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<string> findItinerary(vector<vector<string>>& tickets) {\n        \n    }\n};\n","java":"class Solution {\n    public List<String> findItinerary(List<List<String>> tickets) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public List<string> FindItinerary(List<List<string>> tickets) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/ZyB_gQ8vqGA"},{"id":"min-cost-to-connect-points","name":"Min Cost to Connect Points","description":"You are given a 2-D integer array `points`, where `points[i] = [xi, yi]`. Each `points[i]` represents a distinct point on a 2-D plane.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between the two points, i.e. `|xi - xj| + |yi - yj|`.\n\nReturn the minimum cost to connect all points together, such that there exists exactly one path between each pair of points.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e0cd5270-73b5-42d4-3c3f-5451f795ca00/public)\n\n```java\nInput: points = [[0,0],[2,2],[3,3],[2,4],[4,2]]\n\nOutput: 10\n```\n\n**Constraints:**\n* `1 <= points.length <= 1000`\n* `-1000 <= xi, yi <= 1000`\n","difficulty":"Medium","concepts":["Adjacency List","Prim's","Kruskal's"],"solutions":{"python":"class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        N = len(points)\n        adj = {i: [] for i in range(N)}\n        for i in range(N):\n            x1, y1 = points[i]\n            for j in range(i + 1, N):\n                x2, y2 = points[j]\n                dist = abs(x1 - x2) + abs(y1 - y2)\n                adj[i].append([dist, j])\n                adj[j].append([dist, i])\n\n        res = 0\n        visit = set()\n        minH = [[0, 0]]\n        while len(visit) < N:\n            cost, i = heapq.heappop(minH)\n            if i in visit:\n                continue\n            res += cost\n            visit.add(i)\n            for neiCost, nei in adj[i]:\n                if nei not in visit:\n                    heapq.heappush(minH, [neiCost, nei])\n        return res\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[][]} points\n     * @return {number}\n     */\n    minCostConnectPoints(points) {\n        const N = points.length;\n        const adj = new Map();\n        for (let i = 0; i < N; i++) {\n            adj.set(i, []);\n        }\n\n        for (let i = 0; i < N; i++) {\n            const [x1, y1] = points[i];\n            for (let j = i + 1; j < N; j++) {\n                const [x2, y2] = points[j];\n                const dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n                adj.get(i).push([dist, j]);\n                adj.get(j).push([dist, i]);\n            }\n        }\n\n        let res = 0;\n        const visit = new Set();\n        const minHeap = new MinPriorityQueue(entry => entry[0]);\n        minHeap.enqueue([0, 0]);\n\n        while (visit.size < N) {\n            const [cost, i] = minHeap.dequeue();\n            if (visit.has(i)) continue;\n            res += cost;\n            visit.add(i);\n            for (const [neiCost, nei] of adj.get(i)) {\n                if (!visit.has(nei)) {\n                    minHeap.enqueue([neiCost, nei]);\n                }\n            }\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        int N = points.size();\n        unordered_map<int, vector<pair<int, int>>> adj;\n        for (int i = 0; i < N; i++) {\n            int x1 = points[i][0];\n            int y1 = points[i][1];\n            for (int j = i + 1; j < N; j++) {\n                int x2 = points[j][0];\n                int y2 = points[j][1];\n                int dist = abs(x1 - x2) + abs(y1 - y2);\n                adj[i].push_back({dist, j});\n                adj[j].push_back({dist, i});\n            }\n        }\n\n        int res = 0;\n        unordered_set<int> visit;\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minH;\n        minH.push({0, 0});\n        while (visit.size() < N) {\n            auto curr = minH.top();\n            minH.pop();\n            int cost = curr.first;\n            int i = curr.second;\n            if (visit.count(i)) {\n                continue;\n            }\n            res += cost;\n            visit.insert(i);\n            for (const auto& nei : adj[i]) {\n                int neiCost = nei.first;\n                int neiIndex = nei.second;\n                if (!visit.count(neiIndex)) {\n                    minH.push({neiCost, neiIndex});\n                }\n            }\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        int N = points.length;\n        Map<Integer, List<int[]>> adj = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            int x1 = points[i][0];\n            int y1 = points[i][1];\n            for (int j = i + 1; j < N; j++) {\n                int x2 = points[j][0];\n                int y2 = points[j][1];\n                int dist = Math.abs(x1 - x2) + Math.abs(y1 - y2);\n                adj.computeIfAbsent(i, k -> new ArrayList<>()).add(new int[]{dist, j});\n                adj.computeIfAbsent(j, k -> new ArrayList<>()).add(new int[]{dist, i});\n            }\n        }\n\n        int res = 0;\n        Set<Integer> visit = new HashSet<>();\n        PriorityQueue<int[]> minH = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        minH.offer(new int[]{0, 0});\n        while (visit.size() < N) {\n            int[] curr = minH.poll();\n            int cost = curr[0];\n            int i = curr[1];\n            if (visit.contains(i)) {\n                continue;\n            }\n            res += cost;\n            visit.add(i);\n            for (int[] nei : adj.getOrDefault(i, Collections.emptyList())) {\n                int neiCost = nei[0];\n                int neiIndex = nei[1];\n                if (!visit.contains(neiIndex)) {\n                    minH.offer(new int[]{neiCost, neiIndex});\n                }\n            }\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int MinCostConnectPoints(int[][] points) {\n        int N = points.Length;\n        var adj = new Dictionary<int, List<int[]>>();\n        for (int i = 0; i < N; i++) {\n            int x1 = points[i][0];\n            int y1 = points[i][1];\n            for (int j = i + 1; j < N; j++) {\n                int x2 = points[j][0];\n                int y2 = points[j][1];\n                int dist = Math.Abs(x1 - x2) + Math.Abs(y1 - y2);\n                if (!adj.ContainsKey(i))\n                    adj[i] = new List<int[]>();\n                adj[i].Add(new int[] { j, dist });\n\n                if (!adj.ContainsKey(j))\n                    adj[j] = new List<int[]>();\n                adj[j].Add(new int[] { i, dist });\n            }\n        }\n\n        int res = 0;\n        var visit = new HashSet<int>();\n        var pq = new PriorityQueue<int, int>(); // The first parameter is the index of the point, the second is the cost.\n        pq.Enqueue(0, 0); // Start with point 0 and cost 0\n\n        while (visit.Count < N && pq.Count > 0) {\n            if (pq.TryPeek(out int i, out int cost)) {\n                pq.Dequeue();\n\n                if (visit.Contains(i)) {\n                    continue;\n                }\n\n                res += cost;\n                visit.Add(i);\n\n                if (adj.ContainsKey(i)) {\n                    foreach (var edge in adj[i]) {\n                        var nei = edge[0];\n                        var neiCost = edge[1];\n                        if (!visit.Contains(nei)) {\n                            pq.Enqueue(nei, neiCost);\n                        }\n                    }\n                }\n            }\n        }\n        return visit.Count == N ? res : -1;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} points\n     * @return {number}\n     */\n    minCostConnectPoints(points) {}\n}\n","cpp":"class Solution {\npublic:\n    int minCostConnectPoints(vector<vector<int>>& points) {\n        \n    }\n};\n","java":"class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MinCostConnectPoints(int[][] points) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/f7JOBJIC-NA"},{"id":"network-delay-time","name":"Network Delay Time","description":"You are given a network of `n` directed nodes, labeled from `1` to `n`. You are also given `times`, a list of directed edges where `times[i] = (ui, vi, ti)`. \n    \n* `ui` is the source node (an integer from `1` to `n`)\n* `vi` is the target node (an integer from `1` to `n`)\n* `ti` is the time it takes for a signal to travel from the source to the target node (an integer greater than or equal to `0`).\n\nYou are also given an integer `k`, representing the node that we will send a signal from.\n\nReturn the **minimum** time it takes for all of the `n` nodes to receive the signal. If it is impossible for all the nodes to receive the signal, return `-1` instead.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/ba9b9be8-b888-45d6-627a-e719d1ac4e00/public)\n\n```java\nInput: times = [[1,2,1],[2,3,1],[1,4,4],[3,4,1]], n = 4, k = 1\n\nOutput: 3\n```\n\n**Example 2:**\n\n```java\nInput: times = [[1,2,1],[2,3,1]], n = 3, k = 2\n\nOutput: -1\n```\n\n**Constraints:**\n* `1 <= k <= n <= 100`\n* `1 <= times.length <= 1000`\n","difficulty":"Medium","concepts":["Adjacency List","Dijkstra's"],"solutions":{"python":"class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        edges = collections.defaultdict(list)\n        for u, v, w in times:\n            edges[u].append((v, w))\n\n        minHeap = [(0, k)]\n        visit = set()\n        t = 0\n        while minHeap:\n            w1, n1 = heapq.heappop(minHeap)\n            if n1 in visit:\n                continue\n            visit.add(n1)\n            t = w1\n\n            for n2, w2 in edges[n1]:\n                if n2 not in visit:\n                    heapq.heappush(minHeap, (w1 + w2, n2))\n        return t if len(visit) == n else -1\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[][]} times\n     * @param {number} n\n     * @param {number} k\n     * @return {number}\n     */\n    networkDelayTime(times, n, k) {\n        const edges = new Map();\n        for (let i = 1; i <= n; i++) {\n            edges.set(i, []);\n        }\n        for (const [u, v, w] of times) {\n            edges.get(u).push([v, w]);\n        }\n\n        const minHeap = new MinPriorityQueue(entry => entry[0]);\n        minHeap.enqueue([0, k]);\n\n        const visit = new Set();\n        let t = 0;\n\n        while (!minHeap.isEmpty()) {\n            const [w1, n1] = minHeap.dequeue();\n            if (visit.has(n1)) continue;\n            visit.add(n1);\n            t = w1;\n\n            for (const [n2, w2] of edges.get(n1)) {\n                if (!visit.has(n2)) {\n                    minHeap.enqueue([w1 + w2, n2]);\n                }\n            }\n        }\n\n        return visit.size === n ? t : -1;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        unordered_map<int, vector<pair<int, int>>> edges;\n        for (const auto& time : times) {\n            edges[time[0]].emplace_back(time[1], time[2]);\n        }\n\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> minHeap;\n        minHeap.push({0, k});\n\n        set<int> visited;\n        int t = 0;\n        while (!minHeap.empty()) {\n            auto curr = minHeap.top();\n            minHeap.pop();\n            int w1 = curr.first, n1 = curr.second;\n            if (visited.count(n1)) {\n                continue;\n            }\n            visited.insert(n1);\n            t = w1;\n\n            if (edges.count(n1)) {\n                for (const auto& next : edges[n1]) {\n                    int n2 = next.first, w2 = next.second;\n                    if (!visited.count(n2)) {\n                        minHeap.push({w1 + w2, n2});\n                    }\n                }\n            }\n        }\n\n        return visited.size() == n ? t : -1;\n    }\n};\n","java":"class Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        Map<Integer, List<int[]>> edges = new HashMap<>();\n        for (int[] time : times) {\n            edges.computeIfAbsent(time[0], key -> new ArrayList<>()).add(new int[]{time[1], time[2]});\n        }\n\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        minHeap.offer(new int[]{0, k});\n\n        Set<Integer> visited = new HashSet<>();\n        int t = 0;\n        while (!minHeap.isEmpty()) {\n            int[] curr = minHeap.poll();\n            int w1 = curr[0], n1 = curr[1];\n            if (visited.contains(n1)) {\n                continue;\n            }\n            visited.add(n1);\n            t = w1;\n\n            if (edges.containsKey(n1)) {\n                for (int[] next : edges.get(n1)) {\n                    int n2 = next[0], w2 = next[1];\n                    if (!visited.contains(n2)) {\n                        minHeap.offer(new int[]{w1 + w2, n2});\n                    }\n                }\n            }\n        }\n\n        return visited.size() == n ? t : -1;\n    }\n}\n","csharp":"public class Solution {\n    public int NetworkDelayTime(int[][] times, int n, int k) {\n        var edges = new Dictionary<int, List<int[]>>();\n        foreach (var time in times) {\n            if (!edges.ContainsKey(time[0])) {\n                edges[time[0]] = new List<int[]>();\n            }\n            edges[time[0]].Add(new int[] { time[1], time[2] });\n        }\n\n        var pq = new PriorityQueue<int, int>();\n        pq.Enqueue(k, 0);\n\n        var dist = new Dictionary<int, int>();\n        for (int i = 1; i <= n; i++) {\n            dist[i] = int.MaxValue;\n        }\n        dist[k] = 0;\n\n        while (pq.Count > 0) {\n            // Correctly using TryDequeue to get node and its distance\n            if (pq.TryDequeue(out int node, out int minDist)) {\n                if (minDist > dist[node]) {\n                    continue;\n                }\n\n                if (edges.ContainsKey(node)) {\n                    foreach (var edge in edges[node]) {\n                        var next = edge[0];\n                        var weight = edge[1];\n                        var newDist = minDist + weight;\n                        if (newDist < dist[next]) {\n                            dist[next] = newDist;\n                            pq.Enqueue(next, newDist);\n                        }\n                    }\n                }\n            }\n        }\n\n        int result = 0;\n        for (int i = 1; i <= n; i++) {\n            if (dist[i] == int.MaxValue) return -1;\n            result = Math.Max(result, dist[i]);\n        }\n\n        return result;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} times\n     * @param {number} n\n     * @param {number} k\n     * @return {number}\n     */\n    networkDelayTime(times, n, k) {}\n}\n","cpp":"class Solution {\npublic:\n    int networkDelayTime(vector<vector<int>>& times, int n, int k) {\n        \n    }\n};\n","java":"class Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int NetworkDelayTime(int[][] times, int n, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/EaphyqKU4PQ"},{"id":"swim-in-rising-water","name":"Swim in Rising Water","description":"You are given a square 2-D matrix of distinct integers `grid` where each integer `grid[i][j]` represents the elevation at position `(i, j)`.\n\nRain starts to fall at time = `0`, which causes the water level to rise. At time `t`, the water level across the entire grid is `t`.\n\nYou may swim either horizontally or vertically in the grid between two adjacent squares if the original elevation of both squares is less than or equal to the water level at time `t`.\n\nStarting from the top left square `(0, 0)`, return the minimum amount of time it will take until it is possible to reach the bottom right square `(n - 1, n - 1)`.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/11a45dd8-625f-4be6-9fbb-a3b6ffcc1100/public)\n\n```java\nInput: grid = [[0,1],[2,3]]\n\nOutput: 3\n```\n\nExplanation: For a path to exist to the bottom right square `grid[1][1]` the water elevation must be at least `3`. At time `t = 3`, the water level is `3`.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e585e59c-a1f9-4d10-538d-9e52bcdb6200/public)\n\n```java\nInput: grid = [\n  [0,1,2,10],\n  [9,14,4,13],\n  [12,3,8,15],\n  [11,5,7,6]]\n]\n\nOutput: 8\n```\n\nExplanation: The water level must be at least `8` to reach the bottom right square. The path is `[0, 1, 2, 4, 8, 7, 6]`.\n\n**Constraints:**\n* `grid.length == grid[i].length`\n* `1 <= grid.length <= 50`\n* `0 <= grid[i][j] < n^2`\n","difficulty":"Hard","concepts":["Adjacency List","Dijkstra's"],"solutions":{"python":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        N = len(grid)\n        visit = set()\n        minH = [[grid[0][0], 0, 0]]  # (time/max-height, r, c)\n        directions = [[0, 1], [0, -1], [1, 0], [-1, 0]]\n\n        visit.add((0, 0))\n        while minH:\n            t, r, c = heapq.heappop(minH)\n            if r == N - 1 and c == N - 1:\n                return t\n            for dr, dc in directions:\n                neiR, neiC = r + dr, c + dc\n                if (\n                    neiR < 0\n                    or neiC < 0\n                    or neiR == N\n                    or neiC == N\n                    or (neiR, neiC) in visit\n                ):\n                    continue\n                visit.add((neiR, neiC))\n                heapq.heappush(minH, [max(t, grid[neiR][neiC]), neiR, neiC])\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[][]} grid\n     * @return {number}\n     */\n    swimInWater(grid) {\n        const N = grid.length;\n        const visit = new Set();\n        const minPQ = new MinPriorityQueue(entry => entry[0]);\n        const directions = [\n            [0, 1],\n            [0, -1],\n            [1, 0],\n            [-1, 0],\n        ];\n\n        minPQ.enqueue([grid[0][0], 0, 0]);\n        visit.add('0,0');\n\n        while (!minPQ.isEmpty()) {\n            const [t, r, c] = minPQ.dequeue();\n            if (r === N - 1 && c === N - 1) {\n                return t;\n            }\n            for (const [dr, dc] of directions) {\n                const neiR = r + dr;\n                const neiC = c + dc;\n                if (\n                    neiR < 0 ||\n                    neiC < 0 ||\n                    neiR >= N ||\n                    neiC >= N ||\n                    visit.has(`${neiR},${neiC}`)\n                ) {\n                    continue;\n                }\n                visit.add(`${neiR},${neiC}`);\n                minPQ.enqueue([Math.max(t, grid[neiR][neiC]), neiR, neiC]);\n            }\n        }\n    }\n}\n","cpp":"class Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        int N = grid.size();\n        set<pair<int, int>> visit;\n        priority_queue<vector<int>, vector<vector<int>>, greater<>> minHeap;\n        vector<vector<int>> directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        minHeap.push({grid[0][0], 0, 0});\n        visit.insert({0, 0});\n\n        while (!minHeap.empty()) {\n            auto curr = minHeap.top();\n            minHeap.pop();\n            int t = curr[0], r = curr[1], c = curr[2];\n            if (r == N - 1 && c == N - 1) {\n                return t;\n            }\n            for (const auto& dir : directions) {\n                int neiR = r + dir[0], neiC = c + dir[1];\n                if (neiR < 0 || neiC < 0 || neiR == N || neiC == N || visit.count({neiR, neiC})) {\n                    continue;\n                }\n                visit.insert({neiR, neiC});\n                minHeap.push({max(t, grid[neiR][neiC]), neiR, neiC});\n            }\n        }\n\n        return -1;\n    }\n};\n","java":"class Solution {\n    public int swimInWater(int[][] grid) {\n        int N = grid.length;\n        boolean[][] visit = new boolean[N][N]; // 2D array to track visited cells\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n        minHeap.offer(new int[]{grid[0][0], 0, 0});\n        visit[0][0] = true; // Mark the starting point as visited\n\n        while (!minHeap.isEmpty()) {\n            int[] curr = minHeap.poll();\n            int t = curr[0], r = curr[1], c = curr[2];\n            if (r == N - 1 && c == N - 1) {\n                return t; // Reached the bottom-right corner\n            }\n            for (int[] dir : directions) {\n                int neiR = r + dir[0], neiC = c + dir[1];\n                if (neiR >= 0 && neiC >= 0 && neiR < N && neiC < N && !visit[neiR][neiC]) {\n                    visit[neiR][neiC] = true; // Mark the cell as visited\n                    minHeap.offer(new int[]{Math.max(t, grid[neiR][neiC]), neiR, neiC});\n                }\n            }\n        }\n        return -1; // No valid path found\n    }\n}\n","csharp":"public class Solution {\n    public int SwimInWater(int[][] grid) {\n        int N = grid.Length;\n        var visit = new HashSet<(int, int)>();\n        var minHeap = new PriorityQueue<(int t, int r, int c), int>();\n        int[][] directions = { new int[]{0, 1}, new int[]{0, -1}, new int[]{1, 0}, new int[]{-1, 0} };\n\n        minHeap.Enqueue((grid[0][0], 0, 0), grid[0][0]);\n        visit.Add((0, 0));\n\n        while (minHeap.Count > 0) {\n            var curr = minHeap.Dequeue();\n            int t = curr.t, r = curr.r, c = curr.c;\n            if (r == N - 1 && c == N - 1) {\n                return t;\n            }\n            foreach (var dir in directions) {\n                int neiR = r + dir[0], neiC = c + dir[1];\n                if (neiR < 0 || neiC < 0 || neiR >= N || neiC >= N || visit.Contains((neiR, neiC))) {\n                    continue;\n                }\n                visit.Add((neiR, neiC));\n                minHeap.Enqueue((Math.Max(t, grid[neiR][neiC]), neiR, neiC), Math.Max(t, grid[neiR][neiC]));\n            }\n        }\n\n        return -1;  // This line only executes if no path is found, which should not happen in a valid grid.\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def swimInWater(self, grid: List[List[int]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} grid\n     * @return {number}\n     */\n    swimInWater(grid) {}\n}\n","cpp":"class Solution {\npublic:\n    int swimInWater(vector<vector<int>>& grid) {\n        \n    }\n};\n","java":"class Solution {\n    public int swimInWater(int[][] grid) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int SwimInWater(int[][] grid) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/amvrKlMLuGY"},{"id":"cheapest-flight-path","name":"Cheapest Flight Path","description":"There are `n` airports, labeled from `0` to `n - 1`, which are connected by some flights. You are given an array `flights` where `flights[i] = [from_i, to_i, price_i]` represents a one-way flight from airport `from_i` to airport `to_i` with cost `price_i`. You may assume there are no duplicate flights and no flights from an airport to itself.\n\nYou are also given three integers `src`, `dst`, and `k` where:\n\n* `src` is the starting airport\n* `dst` is the destination airport\n* `src != dst`\n* `k` is the maximum number of stops you can make (not including `src` and `dst`)\n\nReturn **the cheapest price** from `src` to `dst` with at most `k` stops, or return `-1` if it is impossible.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/e272e71f-c38b-4db8-3c4e-1158418d2a00/public)\n\n```java\nInput: n = 4, flights = [[0,1,200],[1,2,100],[1,3,300],[2,3,100]], src = 0, dst = 3, k = 1\n\nOutput: 500\n```\n\nExplanation:\nThe optimal path with at most 1 stop from airport 0 to 3 is shown in red, with total cost `200 + 300 = 500`.\nNote that the path `[0 -> 1 -> 2 -> 3]` costs only 400, and thus is cheaper, but it requires 2 stops, which is more than k.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/93e910ee-378d-4ac8-93e0-471df7ccf600/public)\n\n```java\nInput: n = 3, flights = [[1,0,100],[1,2,200],[0,2,100]], src = 1, dst = 2, k = 1\n\nOutput: 200\n```\n\nExplanation:\nThe optimal path with at most 1 stop from airport 1 to 2 is shown in red and has cost `200`.\n\n**Constraints:**\n* `1 <= n <= 100`\n* `fromi != toi`\n* `1 <= pricei <= 1000`\n* `0 <= src, dst, k < n`\n","difficulty":"Medium","concepts":["Adjacency List"],"solutions":{"python":"class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        prices = [float(\"inf\")] * n\n        prices[src] = 0\n\n        for i in range(k + 1):\n            tmpPrices = prices.copy()\n\n            for s, d, p in flights:  # s=source, d=dest, p=price\n                if prices[s] == float(\"inf\"):\n                    continue\n                if prices[s] + p < tmpPrices[d]:\n                    tmpPrices[d] = prices[s] + p\n            prices = tmpPrices\n        return -1 if prices[dst] == float(\"inf\") else prices[dst]\n","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @param {number[][]} flights\n     * @param {number} src\n     * @param {number} dst\n     * @param {number} k\n     * @return {number}\n     */\n    findCheapestPrice(n, flights, src, dst, k) {\n        let prices = new Array(n).fill(Number.MAX_SAFE_INTEGER);\n        prices[src] = 0;\n\n        for (let i = 0; i <= k; i++) {\n            const tmpPrices = [...prices];\n\n            for (const flight of flights) {\n                const s = flight[0];\n                const d = flight[1];\n                const p = flight[2];\n\n                if (prices[s] === Number.MAX_SAFE_INTEGER) continue;\n\n                if (prices[s] + p < tmpPrices[d]) tmpPrices[d] = prices[s] + p;\n            }\n\n            prices = tmpPrices;\n        }\n\n        return prices[dst] === Number.MAX_SAFE_INTEGER ? -1 : prices[dst];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        vector<int> prices(n, INT_MAX);\n        prices[src] = 0;\n\n        for (int i = 0; i <= k; i++) {\n            vector<int> tmpPrices = prices;\n\n            for (const auto& flight : flights) {\n                int s = flight[0];\n                int d = flight[1];\n                int p = flight[2];\n\n                if (prices[s] == INT_MAX)\n                    continue;\n\n                if (prices[s] + p < tmpPrices[d])\n                    tmpPrices[d] = prices[s] + p;\n            }\n\n            prices = tmpPrices;\n        }\n\n        return prices[dst] == INT_MAX ? -1 : prices[dst];\n    }\n};\n","java":"class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        int[] prices = new int[n];\n        Arrays.fill(prices, Integer.MAX_VALUE);\n        prices[src] = 0;\n\n        for (int i = 0; i <= k; i++) {\n            int[] tmpPrices = Arrays.copyOf(prices, n);\n\n            for (int[] flight : flights) {\n                int s = flight[0];\n                int d = flight[1];\n                int p = flight[2];\n\n                if (prices[s] == Integer.MAX_VALUE) {\n                    continue;\n                }\n\n                if (prices[s] + p < tmpPrices[d]) {\n                    tmpPrices[d] = prices[s] + p;\n                }\n            }\n\n            prices = tmpPrices;\n        }\n\n        return prices[dst] == Integer.MAX_VALUE ? -1 : prices[dst];\n    }\n}\n","csharp":"public class Solution {\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        int[] prices = new int[n];\n        Array.Fill(prices, int.MaxValue);\n        prices[src] = 0;\n\n        for (int i = 0; i <= k; i++) {\n            int[] tmpPrices = (int[])prices.Clone();\n\n            foreach (var flight in flights) {\n                int s = flight[0];\n                int d = flight[1];\n                int p = flight[2];\n\n                if (prices[s] == int.MaxValue)\n                    continue;\n\n                if (prices[s] + p < tmpPrices[d])\n                    tmpPrices[d] = prices[s] + p;\n            }\n\n            prices = tmpPrices;\n        }\n\n        return prices[dst] == int.MaxValue ? -1 : prices[dst];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @param {number[][]} flights\n     * @param {number} src\n     * @param {number} dst\n     * @param {number} k\n     * @return {number}\n     */\n    findCheapestPrice(n, flights, src, dst, k) {}\n}\n","cpp":"class Solution {\npublic:\n    int findCheapestPrice(int n, vector<vector<int>>& flights, int src, int dst, int k) {\n        \n    }\n};\n","java":"class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n\n    }\n}\n","csharp":"public class Solution {\n    public int FindCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/5eIK3zUdYmE"},{"id":"min-cost-climbing-stairs","name":"Min Cost Climbing Stairs","description":"You are given an array of integers `cost` where `cost[i]` is the cost of taking a step from the `ith` floor of a staircase. After paying the cost, you can step to either the `(i + 1)th` floor or the `(i + 2)th` floor.\n\nYou may choose to start at the index `0` or the index `1` floor.\n\nReturn the minimum cost to reach the top of the staircase, i.e. just past the last index in `cost`.\n\n**Example 1:**\n\n```java\nInput: cost = [1,2,3]\n\nOutput: 2\n```\n\nExplanation: We can start at index = `1` and pay the cost of `cost[1] = 2` and take two steps to reach the top. The total cost is `2`.\n\n**Example 2:**\n\n```java\nInput: cost = [1,2,1,2,1,1,1]\n\nOutput: 4\n```\n\nExplanation: Start at index = `0`.\n* Pay the cost of `cost[0] = 1` and take two steps to reach index = `2`.\n* Pay the cost of `cost[2] = 1` and take two steps to reach index = `4`.\n* Pay the cost of `cost[4] = 1` and take two steps to reach index = `6`.\n* Pay the cost of `cost[6] = 1` and take one step to reach the top.\n* The total cost is `4`.\n\n**Constraints:**\n* `2 <= cost.length <= 100`\n* `0 <= cost[i] <= 100`\n","difficulty":"Easy","concepts":["Fibonacci Sequence","Tree Maze","1-Dimension DP"],"solutions":{"python":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        for i in range(len(cost) - 3, -1, -1):\n            cost[i] += min(cost[i + 1], cost[i + 2])\n\n        return min(cost[0], cost[1])\n","javascript":"class Solution {\n    /**\n     * @param {number[]} cost\n     * @return {number}\n     */\n    minCostClimbingStairs(cost) {\n        for (let i = cost.length - 3; i >= 0; i--) {\n            cost[i] += Math.min(cost[i + 1], cost[i + 2]);\n        }\n        return Math.min(cost[0], cost[1]);\n    }\n}\n","cpp":"class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        for (int i = cost.size() - 3; i >= 0; i--) {\n            cost[i] += min(cost[i + 1], cost[i + 2]);\n        }\n        return min(cost[0], cost[1]);\n    }\n};\n","java":"class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        for (int i = cost.length - 3; i >= 0; i--) {\n            cost[i] += Math.min(cost[i + 1], cost[i + 2]);\n        }\n        return Math.min(cost[0], cost[1]);\n    }\n}\n","csharp":"public class Solution {\n    public int MinCostClimbingStairs(int[] cost) {\n        for (int i = cost.Length - 3; i >= 0; i--) {\n            cost[i] += Math.Min(cost[i + 1], cost[i + 2]);\n        }\n        return Math.Min(cost[0], cost[1]);\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} cost\n     * @return {number}\n     */\n    minCostClimbingStairs(cost) {}\n}\n","cpp":"class Solution {\npublic:\n    int minCostClimbingStairs(vector<int>& cost) {\n        \n    }\n};\n","java":"class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MinCostClimbingStairs(int[] cost) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/ktmzAZWkEZ0"},{"id":"partition-equal-subset-sum","name":"Partition Equal Subset Sum","description":"You are given an array of positive integers `nums`.\n    \nReturn `true` if you can partition the array into two subsets, `subset1` and `subset2` where `sum(subset1) == sum(subset2)`. Otherwise, return `false`.\n\n**Example 1:**\n\n```java\nInput: nums = [1,2,3,4]\n\nOutput: true\n```\n\nExplanation: The array can be partitioned as `[1, 4]` and `[2, 3]`.\n\n**Example 2:**\n\n```java\nInput: nums = [1,2,3,4,5]\n\nOutput: false\n```\n\n**Constraints:**\n* `1 <= nums.length <= 100`\n* `1 <= nums[i] <= 50`\n","difficulty":"Medium","concepts":["Tree Maze","1-Dimension DP","0 / 1 Knapsack"],"solutions":{"python":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        if sum(nums) % 2:\n            return False\n\n        dp = set()\n        dp.add(0)\n        target = sum(nums) // 2\n\n        for i in range(len(nums) - 1, -1, -1):\n            nextDP = set()\n            for t in dp:\n                if (t + nums[i]) == target:\n                    return True\n                nextDP.add(t + nums[i])\n                nextDP.add(t)\n            dp = nextDP\n        return False\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {boolean}\n     */\n    canPartition(nums) {\n        const sum = nums.reduce((acc, num) => acc + num, 0);\n        if (sum % 2 !== 0) {\n            return false;\n        }\n\n        let dp = new Set();\n        dp.add(0);\n        const target = sum / 2;\n\n        for (let i = nums.length - 1; i >= 0; i--) {\n            const nextDP = new Set();\n            for (const t of dp) {\n                if (t + nums[i] === target) {\n                    return true;\n                }\n                nextDP.add(t + nums[i]);\n                nextDP.add(t);\n            }\n            dp = nextDP;\n        }\n        return false;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n        if (sum % 2 != 0) {\n            return false;\n        }\n\n        unordered_set<int> dp;\n        dp.insert(0);\n        int target = sum / 2;\n\n        for (int i = nums.size() - 1; i >= 0; i--) {\n            unordered_set<int> nextDP;\n            for (int t : dp) {\n                if (t + nums[i] == target) {\n                    return true;\n                }\n                nextDP.insert(t + nums[i]);\n                nextDP.insert(t);\n            }\n            dp = nextDP;\n        }\n        return false;\n    }\n};\n","java":"class Solution {\n    public boolean canPartition(int[] nums) {\n        if (Arrays.stream(nums).sum() % 2 != 0) {\n            return false;\n        }\n\n        Set<Integer> dp = new HashSet<>();\n        dp.add(0);\n        int target = Arrays.stream(nums).sum() / 2;\n\n        for (int i = nums.length - 1; i >= 0; i--) {\n            Set<Integer> nextDP = new HashSet<>();\n            for (int t : dp) {\n                if (t + nums[i] == target) {\n                    return true;\n                }\n                nextDP.add(t + nums[i]);\n                nextDP.add(t);\n            }\n            dp = nextDP;\n        }\n        return false;\n    }\n}\n","csharp":"public class Solution {\n    public bool CanPartition(int[] nums) {\n        if (nums.Sum() % 2 != 0) {\n            return false;\n        }\n\n        HashSet<int> dp = new HashSet<int>();\n        dp.Add(0);\n        int target = nums.Sum() / 2;\n\n        for (int i = nums.Length - 1; i >= 0; i--) {\n            HashSet<int> nextDP = new HashSet<int>();\n            foreach (int t in dp) {\n                if (t + nums[i] == target) {\n                    return true;\n                }\n                nextDP.Add(t + nums[i]);\n                nextDP.Add(t);\n            }\n            dp = nextDP;\n        }\n        return false;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {boolean}\n     */\n    canPartition(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    bool canPartition(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean canPartition(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool CanPartition(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/IsvocB5BJhw"},{"id":"buy-and-sell-crypto-with-cooldown","name":"Buy and Sell Crypto with Cooldown","description":"You are given an integer array `prices` where `prices[i]` is the price of NeetCoin on the `ith` day.\n\nYou may buy and sell one NeetCoin multiple times with the following restrictions:\n* After you sell your NeetCoin, you cannot buy another one on the next day (i.e., there is a cooldown period of one day).\n* You may only own at most one NeetCoin at a time.\n\nYou may complete as many transactions as you like.\n\nReturn the **maximum profit** you can achieve. \n\n**Example 1:**\n\n```java\nInput: prices = [1,3,4,0,4]\n\nOutput: 6\n```\n\nExplanation: Buy on day 0 (price = 1) and sell on day 1 (price = 3), profit = 3-1 = 2. Then buy on day 3 (price = 0) and sell on day 4 (price = 4), profit = 4-0 = 4. Total profit is 2 + 4 = 6.\n\n**Example 2:**\n\n```java\nInput: prices = [1]\n\nOutput: 0\n```\n\n**Constraints:**\n* `1 <= prices.length <= 5000`\n* `0 <= prices[i] <= 1000`\n","difficulty":"Medium","concepts":["Tree Maze","2-Dimension DP"],"solutions":{"python":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        dp = {}  # key=(i, buying) val=max_profit\n\n        def dfs(i, buying):\n            if i >= len(prices):\n                return 0\n            if (i, buying) in dp:\n                return dp[(i, buying)]\n\n            cooldown = dfs(i + 1, buying)\n            if buying:\n                buy = dfs(i + 1, not buying) - prices[i]\n                dp[(i, buying)] = max(buy, cooldown)\n            else:\n                sell = dfs(i + 2, not buying) + prices[i]\n                dp[(i, buying)] = max(sell, cooldown)\n            return dp[(i, buying)]\n\n        return dfs(0, True)\n","javascript":"class Solution {\n    /**\n     * @param {number[]} prices\n     * @return {number}\n     */\n    maxProfit(prices) {\n        const dp = new Map();\n        return this.dfs(0, true, prices, dp);\n    }\n\n    /**\n     * @param {number} i\n     * @param {boolean} buying\n     * @param {number[]} prices\n     * @param {Map} dp\n     * @return {number}\n     */\n    dfs(i, buying, prices, dp) {\n        if (i >= prices.length) {\n            return 0;\n        }\n        const key = `${i}-${buying}`;\n        if (dp.has(key)) {\n            return dp.get(key);\n        }\n\n        const cooldown = this.dfs(i + 1, buying, prices, dp);\n        if (buying) {\n            const buy = this.dfs(i + 1, !buying, prices, dp) - prices[i];\n            dp.set(key, Math.max(buy, cooldown));\n        } else {\n            const sell = this.dfs(i + 2, !buying, prices, dp) + prices[i];\n            dp.set(key, Math.max(sell, cooldown));\n        }\n        return dp.get(key);\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        unordered_map<long, int> dp; // Use long for the combined key\n        return dfs(0, true, prices, dp);\n    }\n\n    int dfs(int i, bool buying, vector<int>& prices, unordered_map<long, int>& dp) {\n        if (i >= prices.size()) {\n            return 0;\n        }\n        \n        // Combine 'i' and 'buying' into a single long key\n        long key = static_cast<long>(i) << 1 | static_cast<long>(buying);\n        if (dp.find(key) != dp.end()) {\n            return dp[key];\n        }\n\n        int cooldown = dfs(i + 1, buying, prices, dp);\n        if (buying) {\n            int buy = dfs(i + 1, !buying, prices, dp) - prices[i];\n            dp[key] = max(buy, cooldown);\n        } else {\n            int sell = dfs(i + 2, !buying, prices, dp) + prices[i];\n            dp[key] = max(sell, cooldown);\n        }\n        return dp[key];\n    }\n};\n","java":"class Solution {\n    \n  public int maxProfit(int[] prices) {\n      Map<String, Integer> dp = new HashMap<>();\n      return dfs(0, true, prices, dp);\n  }\n\n  private int dfs(int i, boolean buying, int[] prices, Map<String, Integer> dp) {\n      if (i >= prices.length) {\n          return 0;\n      }\n      String key = i + \",\" + buying; // Encode 'i' and 'buying' into a String key\n      if (dp.containsKey(key)) {\n          return dp.get(key);\n      }\n\n      int cooldown = dfs(i + 1, buying, prices, dp);\n      if (buying) {\n          int buy = dfs(i + 1, !buying, prices, dp) - prices[i];\n          dp.put(key, Math.max(buy, cooldown));\n      } else {\n          int sell = dfs(i + 2, !buying, prices, dp) + prices[i];\n          dp.put(key, Math.max(sell, cooldown));\n      }\n      return dp.get(key);\n  }\n}\n","csharp":"public class Solution {\n    \n    public int MaxProfit(int[] prices) {\n        Dictionary<Tuple<int, bool>, int> dp = new Dictionary<Tuple<int, bool>, int>();\n        return Dfs(0, true, prices, dp);\n    }\n\n    private int Dfs(int i, bool buying, int[] prices, Dictionary<Tuple<int, bool>, int> dp) {\n        if (i >= prices.Length) {\n            return 0;\n        }\n        var key = Tuple.Create(i, buying);\n        if (dp.ContainsKey(key)) {\n            return dp[key];\n        }\n\n        int cooldown = Dfs(i + 1, buying, prices, dp);\n        if (buying) {\n            int buy = Dfs(i + 1, !buying, prices, dp) - prices[i];\n            dp[key] = Math.Max(buy, cooldown);\n        } else {\n            int sell = Dfs(i + 2, !buying, prices, dp) + prices[i];\n            dp[key] = Math.Max(sell, cooldown);\n        }\n        return dp[key];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} prices\n     * @return {number}\n     */\n    maxProfit(prices) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxProfit(vector<int>& prices) {\n        \n    }\n};\n","java":"class Solution {\n    public int maxProfit(int[] prices) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxProfit(int[] prices) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/I7j0F7AHpb8"},{"id":"coin-change-ii","name":"Coin Change II","description":"You are given an integer array `coins` representing coins of different denominations (e.g. 1 dollar, 5 dollars, etc) and an integer `amount` representing a target amount of money.\n\nReturn the number of distinct combinations that total up to `amount`. If it's impossible to make up the amount, return `0`.\n\nYou may assume that you have an unlimited number of each coin and that each value in `coins` is unique.\n\n**Example 1:**\n\n```java\nInput: amount = 4, coins = [1,2,3]\n\nOutput: 4\n```\n\nExplanation:\n* 1+1+1+1 = 4\n* 1+1+2 = 4\n* 2+2 = 4\n* 1+3 = 4\n\n**Example 2:**\n\n```java\nInput: amount = 7, coins = [2,4]\n\nOutput: 0\n```\n\n\n**Constraints:**\n* `1 <= coins.length <= 100`\n* `1 <= coins[i] <= 1000`\n* `0 <= amount <= 1000`\n","difficulty":"Medium","concepts":["Tree Maze","2-Dimension DP","Unbounded Knapsack"],"solutions":{"python":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for i in range(len(coins) - 1, -1, -1):\n            nextDP = [0] * (amount + 1)\n            nextDP[0] = 1\n\n            for a in range(1, amount + 1):\n                nextDP[a] = dp[a]\n                if a - coins[i] >= 0:\n                    nextDP[a] += nextDP[a - coins[i]]\n            dp = nextDP\n        return dp[amount]\n","javascript":"class Solution {\n    /**\n     * @param {number} amount\n     * @param {number[]} coins\n     * @return {number}\n     */\n    change(amount, coins) {\n        let dp = new Array(amount + 1).fill(0);\n        dp[0] = 1;\n        for (let i = coins.length - 1; i >= 0; i--) {\n            const nextDP = new Array(amount + 1).fill(0);\n            nextDP[0] = 1;\n\n            for (let a = 1; a <= amount; a++) {\n                nextDP[a] = dp[a];\n                if (a - coins[i] >= 0) {\n                    nextDP[a] += nextDP[a - coins[i]];\n                }\n            }\n            dp = nextDP;\n        }\n        return dp[amount];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        vector<int> dp(amount + 1, 0);\n        dp[0] = 1;\n        for (int i = coins.size() - 1; i >= 0; i--) {\n            vector<int> nextDP(amount + 1, 0);\n            nextDP[0] = 1;\n\n            for (int a = 1; a <= amount; a++) {\n                nextDP[a] = dp[a];\n                if (a - coins[i] >= 0) {\n                    nextDP[a] += nextDP[a - coins[i]];\n                }\n            }\n            dp = nextDP;\n        }\n        return dp[amount];\n    }\n};\n","java":"class Solution {\n    public int change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int i = coins.length - 1; i >= 0; i--) {\n            int[] nextDP = new int[amount + 1];\n            nextDP[0] = 1;\n\n            for (int a = 1; a <= amount; a++) {\n                nextDP[a] = dp[a];\n                if (a - coins[i] >= 0) {\n                    nextDP[a] += nextDP[a - coins[i]];\n                }\n            }\n            dp = nextDP;\n        }\n        return dp[amount];\n    }\n}\n","csharp":"public class Solution {\n    public int Change(int amount, int[] coins) {\n        int[] dp = new int[amount + 1];\n        dp[0] = 1;\n        for (int i = coins.Length - 1; i >= 0; i--) {\n            int[] nextDP = new int[amount + 1];\n            nextDP[0] = 1;\n\n            for (int a = 1; a <= amount; a++) {\n                nextDP[a] = dp[a];\n                if (a - coins[i] >= 0) {\n                    nextDP[a] += nextDP[a - coins[i]];\n                }\n            }\n            dp = nextDP;\n        }\n        return dp[amount];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} amount\n     * @param {number[]} coins\n     * @return {number}\n     */\n    change(amount, coins) {}\n}\n","cpp":"class Solution {\npublic:\n    int change(int amount, vector<int>& coins) {\n        \n    }\n};\n","java":"class Solution {\n    public int change(int amount, int[] coins) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Change(int amount, int[] coins) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/Mjy4hd2xgrs"},{"id":"target-sum","name":"Target Sum","description":"You are given an array of integers `nums` and an integer `target`.\n\nFor each number in the array, you can choose to either add or subtract it to a total sum. \n\n* For example, if `nums = [1, 2]`, one possible sum would be `\"+1-2=-1\"`.\n\nIf `nums=[1,1]`, there are **two different ways** to sum the input numbers to get a sum of `0`: `\"+1-1\"` and `\"-1+1\"`.\n\nReturn the number of **different ways** that you can build the expression such that the total sum equals `target`.\n\n**Example 1:**\n\n```java\nInput: nums = [2,2,2], target = 2\n\nOutput: 3\n```\nExplanation: There are 3 different ways to sum the input numbers to get a sum of 2.\n`+2 +2 -2 = 2`\n`+2 -2 +2 = 2`\n`-2 +2 +2 = 2`\n\n**Constraints:**\n* `1 <= nums.length <= 20`\n* `0 <= nums[i] <= 1000`\n* `-1000 <= target <= 1000`\n","difficulty":"Medium","concepts":["Tree Maze","2-Dimension DP","0 / 1 Knapsack"],"solutions":{"python":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        dp = {}  # (index, total) -> # of ways\n\n        def backtrack(i, total):\n            if i == len(nums):\n                return 1 if total == target else 0\n            if (i, total) in dp:\n                return dp[(i, total)]\n\n            dp[(i, total)] = backtrack(i + 1, total + nums[i]) + backtrack(\n                i + 1, total - nums[i]\n            )\n            return dp[(i, total)]\n\n        return backtrack(0, 0)\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number}\n     */\n    findTargetSumWays(nums, target) {\n        const dp = new Map();\n        return this.backtrack(0, 0, nums, target, dp);\n    }\n\n    /**\n     * @param {number} i\n     * @param {number} total\n     * @param {number[]} nums\n     * @param {number} target\n     * @param {Map} dp\n     * @return {number}\n     */\n    backtrack(i, total, nums, target, dp) {\n        if (i === nums.length) {\n            return total === target ? 1 : 0;\n        }\n        const key = `${i}-${total}`;\n        if (dp.has(key)) {\n            return dp.get(key);\n        }\n\n        const ways =\n            this.backtrack(i + 1, total + nums[i], nums, target, dp) +\n            this.backtrack(i + 1, total - nums[i], nums, target, dp);\n        dp.set(key, ways);\n        return ways;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        unordered_map<long, int> dp; // Changed to long for key\n        return backtrack(0, 0, nums, target, dp);\n    }\n\n    int backtrack(int i, int total, vector<int>& nums, int target, unordered_map<long, int>& dp) {\n        if (i == nums.size()) {\n            return total == target ? 1 : 0;\n        }\n        long key = static_cast<long>(i) << 32 | (total & 0xffffffffL); // Combine i and total into a single key\n        if (dp.find(key) != dp.end()) {\n            return dp[key];\n        }\n\n        int ways = backtrack(i + 1, total + nums[i], nums, target, dp) \n                + backtrack(i + 1, total - nums[i], nums, target, dp);\n        dp[key] = ways;\n        return ways;\n    }\n};\n","java":"class Solution {\n\n    public int findTargetSumWays(int[] nums, int target) {\n        Map<String, Integer> dp = new HashMap<>();\n        return backtrack(0, 0, nums, target, dp);\n    }\n\n    private int backtrack(int i, int total, int[] nums, int target, Map<String, Integer> dp) {\n        if (i == nums.length) {\n            return total == target ? 1 : 0;\n        }\n        String key = i + \",\" + total; // Use a composite key of \"i,total\"\n        if (dp.containsKey(key)) {\n            return dp.get(key);\n        }\n\n        int ways = backtrack(i + 1, total + nums[i], nums, target, dp)\n                + backtrack(i + 1, total - nums[i], nums, target, dp);\n        dp.put(key, ways);\n        return ways;\n    }\n}\n","csharp":"public class Solution {\n    \n    public int FindTargetSumWays(int[] nums, int target) {\n        Dictionary<Tuple<int, int>, int> dp = new Dictionary<Tuple<int, int>, int>();\n        return Backtrack(0, 0, nums, target, dp);\n    }\n\n    private int Backtrack(int i, int total, int[] nums, int target, Dictionary<Tuple<int, int>, int> dp) {\n        if (i == nums.Length) {\n            return total == target ? 1 : 0;\n        }\n        var key = Tuple.Create(i, total);\n        if (dp.ContainsKey(key)) {\n            return dp[key];\n        }\n\n        int ways = Backtrack(i + 1, total + nums[i], nums, target, dp)\n                + Backtrack(i + 1, total - nums[i], nums, target, dp);\n        dp[key] = ways;\n        return ways;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @param {number} target\n     * @return {number}\n     */\n    findTargetSumWays(nums, target) {}\n}\n","cpp":"class Solution {\npublic:\n    int findTargetSumWays(vector<int>& nums, int target) {\n        \n    }\n};\n","java":"class Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int FindTargetSumWays(int[] nums, int target) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/g0npyaQtAQM"},{"id":"interleaving-string","name":"Interleaving String","description":"You are given three strings `s1`, `s2`, and `s3`. Return `true` if `s3` is formed by **interleaving** `s1` and `s2` together or `false` otherwise.\n\n**Interleaving** two strings `s` and `t` is done by dividing `s` and `t` into `n` and `m` substrings respectively, where the following conditions are met\n\n* `|n - m| <= 1`, i.e. the difference between the number of substrings of `s` and `t` is at most `1`.\n* `s = s1 + s2 + ... + sn`\n* `t = t1 + t2 + ... + tm`\n* **Interleaving** `s` and `t` is  `s1 + t1 + s2 + t2 + ...` or `t1 + s1 + t2 + s2 + ...`\n\nYou may assume that `s1`, `s2` and `s3` consist of lowercase English letters.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/fc30feb8-d898-4b9f-3667-4e2c98a1a900/public)\n\n```java\nInput: s1 = \"aaaa\", s2 = \"bbbb\", s3 = \"aabbbbaa\"\n\nOutput: true\n```\n\nExplanation: We can split `s1` into `[\"aa\", \"aa\"]`, `s2` can remain as `\"bbbb\"` and `s3` is formed by interleaving `[\"aa\", \"aa\"]` and `\"bbbb\"`.\n\n**Example 2:**\n\n```java\nInput: s1 = \"\", s2 = \"\", s3 = \"\"\n\nOutput: true\n```\n\n**Example 3:**\n\n```java\nInput: s1 = \"abc\", s2 = \"xyz\", s3 = \"abxzcy\"\n\nOutput: false\n```\n\nExplanation: We can't split `s3` into `[\"ab\", \"xz\", \"cy\"]` as the order of characters is not maintained.\n\n\n**Constraints:**\n* `0 <= s1.length, s2.length <= 50`\n* `0 <= s3.length <= 100`\n","difficulty":"Medium","concepts":["Tree Maze","2-Dimension DP"],"solutions":{"python":"class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n\n        dp = [[False] * (len(s2) + 1) for i in range(len(s1) + 1)]\n        dp[len(s1)][len(s2)] = True\n\n        for i in range(len(s1), -1, -1):\n            for j in range(len(s2), -1, -1):\n                if i < len(s1) and s1[i] == s3[i + j] and dp[i + 1][j]:\n                    dp[i][j] = True\n                if j < len(s2) and s2[j] == s3[i + j] and dp[i][j + 1]:\n                    dp[i][j] = True\n        return dp[0][0]\n","javascript":"class Solution {\n    /**\n     * @param {string} s1\n     * @param {string} s2\n     * @param {string} s3\n     * @return {boolean}\n     */\n    isInterleave(s1, s2, s3) {\n        if (s1.length + s2.length !== s3.length) {\n            return false;\n        }\n\n        const dp = Array.from({ length: s1.length + 1 }, () =>\n            Array(s2.length + 1).fill(false),\n        );\n        dp[s1.length][s2.length] = true;\n\n        for (let i = s1.length; i >= 0; i--) {\n            for (let j = s2.length; j >= 0; j--) {\n                if (i < s1.length && s1[i] === s3[i + j] && dp[i + 1][j]) {\n                    dp[i][j] = true;\n                }\n                if (j < s2.length && s2[j] === s3[i + j] && dp[i][j + 1]) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        if (s1.length() + s2.length() != s3.length()) {\n            return false;\n        }\n\n        vector<vector<bool>> dp(s1.length() + 1, vector<bool>(s2.length() + 1, false));\n        dp[s1.length()][s2.length()] = true;\n\n        for (int i = s1.length(); i >= 0; i--) {\n            for (int j = s2.length(); j >= 0; j--) {\n                if (i < s1.length() && s1[i] == s3[i + j] && dp[i + 1][j]) {\n                    dp[i][j] = true;\n                }\n                if (j < s2.length() && s2[j] == s3[i + j] && dp[i][j + 1]) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n        return dp[0][0];\n    }\n};\n","java":"public class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        if (s1.length() + s2.length() != s3.length()) {\n            return false;\n        }\n\n        boolean[][] dp = new boolean[s1.length() + 1][s2.length() + 1];\n        dp[s1.length()][s2.length()] = true;\n\n        for (int i = s1.length(); i >= 0; i--) {\n            for (int j = s2.length(); j >= 0; j--) {\n                if (i < s1.length() && s1.charAt(i) == s3.charAt(i + j) && dp[i + 1][j]) {\n                    dp[i][j] = true;\n                }\n                if (j < s2.length() && s2.charAt(j) == s3.charAt(i + j) && dp[i][j + 1]) {\n                    dp[i][j] = true;\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n","csharp":"public class Solution {\n    public bool IsInterleave(string s1, string s2, string s3) {\n        if (s1.Length + s2.Length != s3.Length) {\n            return false;\n        }\n\n        bool[,] dp = new bool[s1.Length + 1, s2.Length + 1];\n        dp[s1.Length, s2.Length] = true;\n\n        for (int i = s1.Length; i >= 0; i--) {\n            for (int j = s2.Length; j >= 0; j--) {\n                if (i < s1.Length && s1[i] == s3[i + j] && dp[i + 1, j]) {\n                    dp[i, j] = true;\n                }\n                if (j < s2.Length && s2[j] == s3[i + j] && dp[i, j + 1]) {\n                    dp[i, j] = true;\n                }\n            }\n        }\n        return dp[0, 0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s1\n     * @param {string} s2\n     * @param {string} s3\n     * @return {boolean}\n     */\n    isInterleave(s1, s2, s3) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isInterleave(string s1, string s2, string s3) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsInterleave(string s1, string s2, string s3) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/3Rw3p9LrgvE"},{"id":"longest-increasing-path-in-matrix","name":"Longest Increasing Path in Matrix","description":"You are given a 2-D grid of integers `matrix`, where each integer is greater than or equal to `0`. \n    \nReturn the length of the longest strictly increasing path within `matrix`.\n\nFrom each cell within the path, you can move either horizontally or vertically. You **may not** move **diagonally**.\n\n**Example 1:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/c302dea2-1695-4edb-e1b3-91e96d9bb700/public)\n\n```java\nInput: matrix = [[5,5,3],[2,3,6],[1,1,1]]\n\nOutput: 4\n```\n\nExplanation: The longest increasing path is `[1, 2, 3, 6]` or `[1, 2, 3, 5]`.\n\n**Example 2:**\n\n![](https://imagedelivery.net/CLfkmk9Wzy8_9HRyug4EVA/72004ec9-6f68-464c-93c1-0ba0b384c700/public)\n\n```java\nInput: matrix = [[1,2,3],[2,1,4],[7,6,5]]\n\nOutput: 7\n```\n\nExplanation: The longest increasing path is `[1, 2, 3, 4, 5, 6, 7]`.\n\n**Constraints:**\n* `1 <= matrix.length, matrix[i].length <= 100`\n","difficulty":"Hard","concepts":["Tree Maze","Matrix DFS","2-Dimension DP"],"solutions":{"python":"class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ROWS, COLS = len(matrix), len(matrix[0])\n        dp = {}  # (r, c) -> LIP\n\n        def dfs(r, c, prevVal):\n            if r < 0 or r == ROWS or c < 0 or c == COLS or matrix[r][c] <= prevVal:\n                return 0\n            if (r, c) in dp:\n                return dp[(r, c)]\n\n            res = 1\n            res = max(res, 1 + dfs(r + 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r - 1, c, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c + 1, matrix[r][c]))\n            res = max(res, 1 + dfs(r, c - 1, matrix[r][c]))\n            dp[(r, c)] = res\n            return res\n\n        for r in range(ROWS):\n            for c in range(COLS):\n                dfs(r, c, -1)\n        return max(dp.values())\n","javascript":"class Solution {\n    /**\n     * @param {number[][]} matrix\n     * @return {number}\n     */\n    longestIncreasingPath(matrix) {\n        if (matrix.length === 0) {\n            return 0;\n        }\n        const rows = matrix.length;\n        const cols = matrix[0].length;\n\n        let maxDist = 0;\n        const memo = Array.from({ length: rows }, () => Array(cols).fill(0));\n\n        const dirs = [\n            [0, 1],\n            [1, 0],\n            [0, -1],\n            [-1, 0],\n        ];\n\n        /**\n         * @param {number} r\n         * @param {number} c\n         * @param {number} prevVal\n         * @return {number}\n         */\n        function dfs(r, c, prevVal) {\n            if (\n                r < 0 ||\n                r === rows ||\n                c < 0 ||\n                c === cols ||\n                matrix[r][c] <= prevVal\n            ) {\n                return 0;\n            }\n            if (memo[r][c] !== 0) {\n                return memo[r][c];\n            }\n\n            let res = 1;\n            for (const dir of dirs) {\n                const newRow = r + dir[0];\n                const newCol = c + dir[1];\n                if (\n                    newRow >= 0 &&\n                    newRow < rows &&\n                    newCol >= 0 &&\n                    newCol < cols &&\n                    matrix[newRow][newCol] > matrix[r][c]\n                ) {\n                    res = Math.max(res, 1 + dfs(newRow, newCol, matrix[r][c]));\n                }\n            }\n            memo[r][c] = res;\n            return res;\n        }\n\n        for (let i = 0; i < rows; ++i) {\n            for (let j = 0; j < cols; ++j) {\n                maxDist = Math.max(maxDist, dfs(i, j, -1));\n            }\n        }\n        return maxDist;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        if (matrix.empty()) {\n            return 0;\n        }\n        int rows = matrix.size();\n        int cols = matrix[0].size();\n\n        int maxDist = 0;\n        vector<vector<int>> memo(rows, vector<int>(cols, 0));\n\n        vector<vector<int>> dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                maxDist = max(maxDist, dfs(matrix, i, j, memo, dirs));\n            }\n        }\n        return maxDist;\n    }\n\n    int dfs(vector<vector<int>>& matrix, int r, int c, vector<vector<int>>& memo, vector<vector<int>>& dirs) {\n        if (memo[r][c] != 0) {\n            return memo[r][c];\n        }\n\n        int res = 1;\n        for (const auto& dir : dirs) {\n            int newRow = r + dir[0];\n            int newCol = c + dir[1];\n            if (newRow >= 0 && newRow < matrix.size() && newCol >= 0 && newCol < matrix[0].size()\n                && matrix[newRow][newCol] > matrix[r][c]) {\n                res = max(res, 1 + dfs(matrix, newRow, newCol, memo, dirs));\n            }\n        }\n        memo[r][c] = res;\n        return res;\n    }\n};\n","java":"class Solution {\n    \n    public int longestIncreasingPath(int[][] matrix) {\n        if (matrix.length == 0) {\n            return 0;\n        }\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        int maxDist = 0;\n        int[][] memo = new int[rows][cols];\n\n        int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                maxDist = Math.max(maxDist, dfs(matrix, i, j, memo, dirs));\n            }\n        }\n        return maxDist;\n    }\n\n    private int dfs(int[][] matrix, int r, int c, int[][] memo, int[][] dirs) {\n        if (memo[r][c] != 0) {\n            return memo[r][c];\n        }\n\n        int res = 1;\n        for (int[] dir : dirs) {\n            int newRow = r + dir[0];\n            int newCol = c + dir[1];\n            if (newRow >= 0 && newRow < matrix.length && newCol >= 0 && newCol < matrix[0].length\n                    && matrix[newRow][newCol] > matrix[r][c]) {\n                res = Math.max(res, 1 + dfs(matrix, newRow, newCol, memo, dirs));\n            }\n        }\n        memo[r][c] = res;\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    \n    public int LongestIncreasingPath(int[][] matrix) {\n        if (matrix.Length == 0) {\n            return 0;\n        }\n        int rows = matrix.Length;\n        int cols = matrix[0].Length;\n\n        int maxDist = 0;\n        int[,] memo = new int[rows, cols];\n\n        int[,] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                maxDist = Math.Max(maxDist, Dfs(matrix, i, j, memo, dirs));\n            }\n        }\n        return maxDist;\n    }\n\n    private int Dfs(int[][] matrix, int r, int c, int[,] memo, int[,] dirs) {\n        if (memo[r, c] != 0) {\n            return memo[r, c];\n        }\n\n        int res = 1;\n        for (int i = 0; i < dirs.GetLength(0); ++i) {\n            int newRow = r + dirs[i, 0];\n            int newCol = c + dirs[i, 1];\n            if (newRow >= 0 && newRow < matrix.Length && newCol >= 0 && newCol < matrix[0].Length\n                && matrix[newRow][newCol] > matrix[r][c]) {\n                res = Math.Max(res, 1 + Dfs(matrix, newRow, newCol, memo, dirs));\n            }\n        }\n        memo[r, c] = res;\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def longestIncreasingPath(self, matrix: List[List[int]]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} matrix\n     * @return {number}\n     */\n    longestIncreasingPath(matrix) {}\n}\n","cpp":"class Solution {\npublic:\n    int longestIncreasingPath(vector<vector<int>>& matrix) {\n        \n    }\n};\n","java":"class Solution {\n    public int longestIncreasingPath(int[][] matrix) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int LongestIncreasingPath(int[][] matrix) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/wCc_nd-GiEc"},{"id":"count-subsequences","name":"Count Subsequences","description":"You are given two strings `s` and `t`, both consisting of english letters.\n    \nReturn the number of distinct **subsequences** of `s` which are equal to `t`.\n\n**Example 1:**\n\n```java\nInput: s = \"caaat\", t = \"cat\"\n\nOutput: 3\n```\n\nExplanation: Rhere are 3 ways you can generate `\"cat\"` from `s`.\n* (c)aa(at)\n* (c)a(a)a(t)\n* (ca)aa(t)\n\n**Example 2:**\n\n```java\nInput: s = \"xxyxy\", t = \"xy\"\n\nOutput: 5\n```\n\nExplanation: There are 5 ways you can generate `\"xy\"` from `s`.\n* (x)x(y)xy\n* (x)xyx(y)\n* x(x)(y)xy\n* x(x)yx(y)\n* xxy(x)(y)\n\n\n**Constraints:**\n* `1 <= s.length, t.length <= 1000`\n* `s` and `t` consist of English letters.\n","difficulty":"Hard","concepts":["Tree Maze","2-Dimension DP","LCS"],"solutions":{"python":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        cache = {}\n\n        for i in range(len(s) + 1):\n            cache[(i, len(t))] = 1\n        for j in range(len(t)):\n            cache[(len(s), j)] = 0\n\n        for i in range(len(s) - 1, -1, -1):\n            for j in range(len(t) - 1, -1, -1):\n                if s[i] == t[j]:\n                    cache[(i, j)] = cache[(i + 1, j + 1)] + cache[(i + 1, j)]\n                else:\n                    cache[(i, j)] = cache[(i + 1, j)]\n        return cache[(0, 0)]\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} t\n     * @return {number}\n     */\n    numDistinct(s, t) {\n        const cache = new Array(s.length + 1)\n            .fill(0)\n            .map(() => new Array(t.length + 1).fill(0));\n\n        for (let i = 0; i <= s.length; i++) {\n            cache[i][t.length] = 1;\n        }\n        for (let j = t.length - 1; j >= 0; j--) {\n            cache[s.length][j] = 0;\n        }\n\n        for (let i = s.length - 1; i >= 0; i--) {\n            for (let j = t.length - 1; j >= 0; j--) {\n                if (s[i] === t[j]) {\n                    cache[i][j] = cache[i + 1][j + 1] + cache[i + 1][j];\n                } else {\n                    cache[i][j] = cache[i + 1][j];\n                }\n            }\n        }\n        return cache[0][0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        const int MOD = 1e9 + 7;\n        vector<vector<int>> cache(s.length() + 1, vector<int>(t.length() + 1, 0));\n\n        for (int i = 0; i <= s.length(); i++) {\n            cache[i][t.length()] = 1;\n        }\n        for (int j = t.length() - 1; j >= 0; j--) {\n            cache[s.length()][j] = 0;\n        }\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = t.length() - 1; j >= 0; j--) {\n                if (s[i] == t[j]) {\n                    cache[i][j] = (cache[i + 1][j + 1] + cache[i + 1][j]) % MOD;\n                } else {\n                    cache[i][j] = cache[i + 1][j];\n                }\n            }\n        }\n        return cache[0][0];\n    }\n};\n","java":"class Solution {\n    public int numDistinct(String s, String t) {\n        int[][] cache = new int[s.length() + 1][t.length() + 1];\n        \n        for (int i = 0; i <= s.length(); i++) {\n            cache[i][t.length()] = 1;\n        }\n        for (int j = t.length() - 1; j >= 0; j--) {\n            cache[s.length()][j] = 0;\n        }\n        \n        for (int i = s.length() - 1; i >= 0; i--) {\n            for (int j = t.length() - 1; j >= 0; j--) {\n                if (s.charAt(i) == t.charAt(j)) {\n                    cache[i][j] = cache[i + 1][j + 1] + cache[i + 1][j];\n                } else {\n                    cache[i][j] = cache[i + 1][j];\n                }\n            }\n        }\n        return cache[0][0];\n    }\n}\n","csharp":"public class Solution {\n    public int NumDistinct(string s, string t) {\n        int[,] cache = new int[s.Length + 1, t.Length + 1];\n        \n        for (int i = 0; i <= s.Length; i++) {\n            cache[i, t.Length] = 1;\n        }\n        for (int j = t.Length - 1; j >= 0; j--) {\n            cache[s.Length, j] = 0;\n        }\n        \n        for (int i = s.Length - 1; i >= 0; i--) {\n            for (int j = t.Length - 1; j >= 0; j--) {\n                if (s[i] == t[j]) {\n                    cache[i, j] = cache[i + 1, j + 1] + cache[i + 1, j];\n                } else {\n                    cache[i, j] = cache[i + 1, j];\n                }\n            }\n        }\n        return cache[0, 0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def numDistinct(self, s: str, t: str) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} t\n     * @return {number}\n     */\n    numDistinct(s, t) {}\n}\n","cpp":"class Solution {\npublic:\n    int numDistinct(string s, string t) {\n        \n    }\n};\n","java":"class Solution {\n    public int numDistinct(String s, String t) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int NumDistinct(string s, string t) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/-RDzMJ33nx8"},{"id":"edit-distance","name":"Edit Distance","description":"You are given two strings `word1` and `word2`, each consisting of lowercase English letters.\n\nYou are allowed to perform three operations on `word1` an unlimited number of times:\n\n* Insert a character at any position\n* Delete a character at any position\n* Replace a character at any position\n\nReturn the minimum number of operations to make `word1` equal `word2`.\n\n**Example 1:**\n\n```java\nInput: word1 = \"monkeys\", word2 = \"money\"\n\nOutput: 2\n```\n\nExplanation: \n`monkeys` -> `monkey` (remove `s`)\n`monkey` -> `monkey`  (remove `k`)\n\n**Example 2:**\n\n```java\nInput: word1 = \"neatcdee\", word2 = \"neetcode\"\n\nOutput: 3\n```\n\nExplanation: \n`neatcdee` -> `neetcdee`  (replace `a` with `e`)\n`neetcdee` -> `neetcde`   (remove last `e`)\n`neetcde`  -> `neetcode`  (insert `o`)\n\n**Constraints:**\n* `0 <= word1.length, word2.length <= 100`\n* `word1` and `word2` consist of lowercase English letters.\n","difficulty":"Medium","concepts":["Tree Maze","2-Dimension DP","LCS"],"solutions":{"python":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        dp = [[float(\"inf\")] * (len(word2) + 1) for i in range(len(word1) + 1)]\n\n        for j in range(len(word2) + 1):\n            dp[len(word1)][j] = len(word2) - j\n        for i in range(len(word1) + 1):\n            dp[i][len(word2)] = len(word1) - i\n\n        for i in range(len(word1) - 1, -1, -1):\n            for j in range(len(word2) - 1, -1, -1):\n                if word1[i] == word2[j]:\n                    dp[i][j] = dp[i + 1][j + 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j + 1], dp[i + 1][j + 1])\n        return dp[0][0]\n","javascript":"class Solution {\n    /**\n     * @param {string} word1\n     * @param {string} word2\n     * @return {number}\n     */\n    minDistance(word1, word2) {\n        const dp = new Array(word1.length + 1)\n            .fill(0)\n            .map(() => new Array(word2.length + 1).fill(0));\n\n        for (let j = 0; j <= word2.length; j++) {\n            dp[word1.length][j] = word2.length - j;\n        }\n        for (let i = 0; i <= word1.length; i++) {\n            dp[i][word2.length] = word1.length - i;\n        }\n\n        for (let i = word1.length - 1; i >= 0; i--) {\n            for (let j = word2.length - 1; j >= 0; j--) {\n                if (word1[i] === word2[j]) {\n                    dp[i][j] = dp[i + 1][j + 1];\n                } else {\n                    dp[i][j] =\n                        1 +\n                        Math.min(\n                            dp[i + 1][j],\n                            Math.min(dp[i][j + 1], dp[i + 1][j + 1]),\n                        );\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        vector<vector<int>> dp(word1.length() + 1, vector<int>(word2.length() + 1, 0));\n\n        for (int j = 0; j <= word2.length(); j++) {\n            dp[word1.length()][j] = word2.length() - j;\n        }\n        for (int i = 0; i <= word1.length(); i++) {\n            dp[i][word2.length()] = word1.length() - i;\n        }\n\n        for (int i = word1.length() - 1; i >= 0; i--) {\n            for (int j = word2.length() - 1; j >= 0; j--) {\n                if (word1[i] == word2[j]) {\n                    dp[i][j] = dp[i + 1][j + 1];\n                } else {\n                    dp[i][j] = 1 + min(dp[i + 1][j], min(dp[i][j + 1], dp[i + 1][j + 1]));\n                }\n            }\n        }\n        return dp[0][0];\n    }\n};\n","java":"class Solution {\n    public int minDistance(String word1, String word2) {\n        int[][] dp = new int[word1.length() + 1][word2.length() + 1];\n\n        for (int j = 0; j <= word2.length(); j++) {\n            dp[word1.length()][j] = word2.length() - j;\n        }\n        for (int i = 0; i <= word1.length(); i++) {\n            dp[i][word2.length()] = word1.length() - i;\n        }\n\n        for (int i = word1.length() - 1; i >= 0; i--) {\n            for (int j = word2.length() - 1; j >= 0; j--) {\n                if (word1.charAt(i) == word2.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j + 1];\n                } else {\n                    dp[i][j] = 1 + Math.min(dp[i + 1][j], Math.min(dp[i][j + 1], dp[i + 1][j + 1]));\n                }\n            }\n        }\n        return dp[0][0];\n    }\n}\n","csharp":"public class Solution {\n    public int MinDistance(string word1, string word2) {\n        int[,] dp = new int[word1.Length + 1, word2.Length + 1];\n\n        for (int j = 0; j <= word2.Length; j++) {\n            dp[word1.Length, j] = word2.Length - j;\n        }\n        for (int i = 0; i <= word1.Length; i++) {\n            dp[i, word2.Length] = word1.Length - i;\n        }\n\n        for (int i = word1.Length - 1; i >= 0; i--) {\n            for (int j = word2.Length - 1; j >= 0; j--) {\n                if (word1[i] == word2[j]) {\n                    dp[i, j] = dp[i + 1, j + 1];\n                } else {\n                    dp[i, j] = 1 + Math.Min(dp[i + 1, j], Math.Min(dp[i, j + 1], dp[i + 1, j + 1]));\n                }\n            }\n        }\n        return dp[0, 0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} word1\n     * @param {string} word2\n     * @return {number}\n     */\n    minDistance(word1, word2) {}\n}\n","cpp":"class Solution {\npublic:\n    int minDistance(string word1, string word2) {\n        \n    }\n};\n","java":"class Solution {\n    public int minDistance(String word1, String word2) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MinDistance(string word1, string word2) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/XYi2-LPrwm4"},{"id":"burst-balloons","name":"Burst Balloons","description":"You are given an array of integers `nums` of size `n`. The `ith` element represents a balloon with an integer value of `nums[i]`. You must burst all of the balloons.\n\nIf you burst the `ith` balloon, you will receive `nums[i - 1] * nums[i] * nums[i + 1]` coins. If `i - 1` or `i + 1` goes out of bounds of the array, then assume the out of bounds value is 1.\n\nReturn the maximum number of coins you can receive by bursting all of the balloons.\n\n**Example 1:**\n\n```java\nInput: nums = [4,2,3,7]\n\nOutput: 167\n\nExplanation:\nnums = [4,2,3,7] --> [4,3,7] --> [4,7] --> [7] --> []\ncoins =  4*2*3    +   4*3*7   +  1*4*7  + 1*7*1 = 143\n```\n\n**Constraints:**\n* `n == nums.length`\n* `1 <= n <= 300`\n* `0 <= nums[i] <= 100`\n","difficulty":"Hard","concepts":["Tree Maze","2-Dimension DP"],"solutions":{"python":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        cache = {}\n        nums = [1] + nums + [1]\n\n        for offset in range(2, len(nums)):\n            for left in range(len(nums) - offset):\n                right = left + offset\n                for pivot in range(left + 1, right):\n                    coins = nums[left] * nums[pivot] * nums[right]\n                    coins += cache.get((left, pivot), 0) + cache.get((pivot, right), 0)\n                    cache[(left, right)] = max(coins, cache.get((left, right), 0))\n        return cache.get((0, len(nums) - 1), 0)\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    maxCoins(nums) {\n        const cache = new Map();\n        const newNums = [1, ...nums, 1];\n\n        for (let offset = 2; offset < newNums.length; offset++) {\n            for (let left = 0; left < newNums.length - offset; left++) {\n                const right = left + offset;\n                for (let pivot = left + 1; pivot < right; pivot++) {\n                    let coins = newNums[left] * newNums[pivot] * newNums[right];\n                    coins += cache.get(`${left}-${pivot}`) || 0;\n                    coins += cache.get(`${pivot}-${right}`) || 0;\n                    cache.set(\n                        `${left}-${right}`,\n                        Math.max(coins, cache.get(`${left}-${right}`) || 0),\n                    );\n                }\n            }\n        }\n\n        return cache.get('0-' + (newNums.length - 1)) || 0;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int maxCoins(std::vector<int>& nums) {\n        std::unordered_map<long, int> cache; // Using long for key to combine two integers uniquely\n        nums.insert(nums.begin(), 1);\n        nums.push_back(1);\n        \n        auto getKey = [](int left, int right) -> long {\n            return static_cast<long>(left) << 32 | static_cast<long>(right);\n        };\n        \n        for (int offset = 2; offset < nums.size(); ++offset) {\n            for (int left = 0; left < nums.size() - offset; ++left) {\n                int right = left + offset;\n                for (int pivot = left + 1; pivot < right; ++pivot) {\n                    int coins = nums[left] * nums[pivot] * nums[right];\n                    coins += cache[getKey(left, pivot)] + cache[getKey(pivot, right)];\n                    long key = getKey(left, right);\n                    cache[key] = std::max(coins, cache[key]);\n                }\n            }\n        }\n        return cache[getKey(0, nums.size() - 1)];\n    }\n};\n","java":"class Solution {\n    public int maxCoins(int[] nums) {\n        int[][] cache = new int[nums.length + 2][nums.length + 2];\n        int[] newNums = new int[nums.length + 2];\n        newNums[0] = newNums[nums.length + 1] = 1;\n        for (int i = 0; i < nums.length; i++) {\n            newNums[i + 1] = nums[i];\n        }\n\n        for (int offset = 2; offset < newNums.length; offset++) {\n            for (int left = 0; left < newNums.length - offset; left++) {\n                int right = left + offset;\n                for (int pivot = left + 1; pivot < right; pivot++) {\n                    int coins = newNums[left] * newNums[pivot] * newNums[right];\n                    coins += cache[left][pivot] + cache[pivot][right];\n                    cache[left][right] = Math.max(coins, cache[left][right]);\n                }\n            }\n        }\n        return cache[0][newNums.length - 1];\n    }\n}\n","csharp":"public class Solution {\n    public int MaxCoins(int[] nums) {\n        int[,] cache = new int[nums.Length + 2, nums.Length + 2];\n        int[] newNums = new int[nums.Length + 2];\n        newNums[0] = newNums[nums.Length + 1] = 1;\n        for (int i = 0; i < nums.Length; i++) {\n            newNums[i + 1] = nums[i];\n        }\n\n        for (int offset = 2; offset < newNums.Length; offset++) {\n            for (int left = 0; left < newNums.Length - offset; left++) {\n                int right = left + offset;\n                for (int pivot = left + 1; pivot < right; pivot++) {\n                    int coins = newNums[left] * newNums[pivot] * newNums[right];\n                    coins += cache[left, pivot] + cache[pivot, right];\n                    cache[left, right] = Math.Max(coins, cache[left, right]);\n                }\n            }\n        }\n        return cache[0, newNums.Length - 1];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    maxCoins(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int maxCoins(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int maxCoins(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int MaxCoins(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/VFskby7lUbw"},{"id":"regular-expression-matching","name":"Regular Expression Matching","description":"You are given an input string `s` consisting of lowercase english letters, and a pattern `p` consisting of lowercase english letters, as well as `'.'`, and `'*'` characters.\n    \nReturn `true` if the pattern matches the **entire** input string, otherwise return `false`.\n\n* `'.'` Matches any single character\n* `'*'` Matches zero or more of the preceding element.\n\n**Example 1:**\n\n```java\nInput: s = \"aa\", p = \".b\"\n\nOutput: false\n```\n\nExplanation: Regardless of which character we choose for the `'.'` in the pattern, we cannot match the second character in the input string.\n\n**Example 2:**\n\n```java\nInput: s = \"nnn\", p = \"n*\"\n\nOutput: true\n```\n\nExplanation: `'*'` means zero or more of the preceding element, `'n'`. We choose `'n'` to repeat three times.\n\n**Example 3:**\n\n```java\nInput: s = \"xyz\", p = \".*z\"\n\nOutput: true\n```\n\nExplanation: The pattern `\".*\"` means zero or more of any character, so we choose `\"..\"` to match `\"xy\"` and `\"z\"` to match `\"z\"`.\n\n**Constraints:**\n* `1 <= s.length <= 20`\n* `1 <= p.length <= 20`\n* Each appearance of `'*'`, will be preceded by a valid character or `'.'`.\n","difficulty":"Hard","concepts":["Tree Maze","2-Dimension DP"],"solutions":{"python":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        cache = [[False] * (len(p) + 1) for i in range(len(s) + 1)]\n        cache[len(s)][len(p)] = True\n\n        for i in range(len(s), -1, -1):\n            for j in range(len(p) - 1, -1, -1):\n                match = i < len(s) and (s[i] == p[j] or p[j] == \".\")\n\n                if (j + 1) < len(p) and p[j + 1] == \"*\":\n                    cache[i][j] = cache[i][j + 2]\n                    if match:\n                        cache[i][j] = cache[i + 1][j] or cache[i][j]\n                elif match:\n                    cache[i][j] = cache[i + 1][j + 1]\n\n        return cache[0][0]\n","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} p\n     * @return {boolean}\n     */\n    isMatch(s, p) {\n        const cache = new Array(s.length + 1)\n            .fill(false)\n            .map(() => new Array(p.length + 1).fill(false));\n        cache[s.length][p.length] = true;\n\n        for (let i = s.length; i >= 0; i--) {\n            for (let j = p.length - 1; j >= 0; j--) {\n                const match = i < s.length && (s[i] === p[j] || p[j] === '.');\n\n                if (j + 1 < p.length && p[j + 1] === '*') {\n                    cache[i][j] = cache[i][j + 2];\n                    if (match) {\n                        cache[i][j] = cache[i + 1][j] || cache[i][j];\n                    }\n                } else if (match) {\n                    cache[i][j] = cache[i + 1][j + 1];\n                }\n            }\n        }\n\n        return cache[0][0];\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        vector<vector<bool>> cache(s.length() + 1, vector<bool>(p.length() + 1, false));\n        cache[s.length()][p.length()] = true;\n\n        for (int i = s.length(); i >= 0; i--) {\n            for (int j = p.length() - 1; j >= 0; j--) {\n                bool match = i < s.length() && (s[i] == p[j] || p[j] == '.');\n\n                if ((j + 1) < p.length() && p[j + 1] == '*') {\n                    cache[i][j] = cache[i][j + 2];\n                    if (match) {\n                        cache[i][j] = cache[i + 1][j] || cache[i][j];\n                    }\n                } else if (match) {\n                    cache[i][j] = cache[i + 1][j + 1];\n                }\n            }\n        }\n\n        return cache[0][0];\n    }\n};\n","java":"class Solution {\n    public boolean isMatch(String s, String p) {\n        boolean[][] cache = new boolean[s.length() + 1][p.length() + 1];\n        cache[s.length()][p.length()] = true;\n\n        for (int i = s.length(); i >= 0; i--) {\n            for (int j = p.length() - 1; j >= 0; j--) {\n                boolean match = i < s.length() && (s.charAt(i) == p.charAt(j) || p.charAt(j) == '.');\n\n                if ((j + 1) < p.length() && p.charAt(j + 1) == '*') {\n                    cache[i][j] = cache[i][j + 2];\n                    if (match) {\n                        cache[i][j] = cache[i + 1][j] || cache[i][j];\n                    }\n                } else if (match) {\n                    cache[i][j] = cache[i + 1][j + 1];\n                }\n            }\n        }\n\n        return cache[0][0];\n    }\n}\n","csharp":"public class Solution {\n    public bool IsMatch(string s, string p) {\n        bool[,] cache = new bool[s.Length + 1, p.Length + 1];\n        cache[s.Length, p.Length] = true;\n\n        for (int i = s.Length; i >= 0; i--) {\n            for (int j = p.Length - 1; j >= 0; j--) {\n                bool match = i < s.Length && (s[i] == p[j] || p[j] == '.');\n\n                if ((j + 1) < p.Length && p[j + 1] == '*') {\n                    cache[i, j] = cache[i, j + 2];\n                    if (match) {\n                        cache[i, j] = cache[i + 1, j] || cache[i, j];\n                    }\n                } else if (match) {\n                    cache[i, j] = cache[i + 1, j + 1];\n                }\n            }\n        }\n\n        return cache[0, 0];\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {string} s\n     * @param {string} p\n     * @return {boolean}\n     */\n    isMatch(s, p) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isMatch(string s, string p) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isMatch(String s, String p) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsMatch(string s, string p) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/HAA8mgxlov8"},{"id":"hand-of-straights","name":"Hand of Straights","description":"You are given an integer array `hand` where `hand[i]` is the value written on the `ith` card and an integer `groupSize`.\n    \nYou want to rearrange the cards into groups so that each group is of size `groupSize`, and card values are consecutively increasing by `1`.\n\nReturn `true` if it's possible to rearrange the cards in this way, otherwise, return `false`.\n\n**Example 1:**\n\n```java\nInput: hand = [1,2,4,2,3,5,3,4], groupSize = 4\n\nOutput: true\n```\n\nExplanation: The cards can be rearranged as `[1,2,3,4]` and `[2,3,4,5]`.\n\n**Example 2:**\n\n```java\nInput: hand = [1,2,3,3,4,5,6,7], groupSize = 4\n\nOutput: false\n```\n\nExplanation: The closest we can get is `[1,2,3,4]` and `[3,5,6,7]`, but the cards in the second group are not consecutive.\n\n**Constraints:**\n* `1 <= hand.length <= 1000`\n* `0 <= hand[i] <= 1000`\n* `1 <= groupSize <= hand.length`\n","difficulty":"Medium","concepts":["Heap Properties","Push and Pop","Heapify"],"solutions":{"python":"class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        if len(hand) % groupSize:\n            return False\n\n        count = {}\n        for n in hand:\n            count[n] = 1 + count.get(n, 0)\n\n        minH = list(count.keys())\n        heapq.heapify(minH)\n        while minH:\n            first = minH[0]\n            for i in range(first, first + groupSize):\n                if i not in count:\n                    return False\n                count[i] -= 1\n                if count[i] == 0:\n                    if i != minH[0]:\n                        return False\n                    heapq.heappop(minH)\n        return True\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[]} hand\n     * @param {number} groupSize\n     * @return {boolean}\n     */\n    isNStraightHand(hand, groupSize) {\n        if (hand.length % groupSize !== 0) {\n            return false;\n        }\n\n        const count = {};\n        for (const n of hand) {\n            count[n] = (count[n] || 0) + 1;\n        }\n\n        const minPQ = new MinPriorityQueue();\n        for (const key in count) {\n            minPQ.enqueue(Number(key));\n        }\n\n        while (!minPQ.isEmpty()) {\n            const first = minPQ.front();\n            for (let i = first; i < first + groupSize; i++) {\n                if (!(i in count) || count[i] === 0) {\n                    return false;\n                }\n                count[i] -= 1;\n                if (count[i] === 0) {\n                    if (i !== minPQ.front()) {\n                        return false;\n                    }\n                    minPQ.dequeue();\n                }\n            }\n        }\n        return true;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isNStraightHand(vector<int>& hand, int groupSize) {\n        if (hand.size() % groupSize != 0)\n            return false;\n\n        unordered_map<int, int> count;\n        for (int n : hand)\n            count[n] = 1 + count[n];\n\n        priority_queue<int, vector<int>, greater<int>> minH;\n        for (auto& pair : count)\n            minH.push(pair.first);\n\n        while (!minH.empty()) {\n            int first = minH.top();\n            for (int i = first; i < first + groupSize; i++) {\n                if (count.find(i) == count.end())\n                    return false;\n                count[i] -= 1;\n                if (count[i] == 0) {\n                    if (i != minH.top())\n                        return false;\n                    minH.pop();\n                }\n            }\n        }\n        return true;\n    }\n};\n","java":"class Solution {\n    public boolean isNStraightHand(int[] hand, int groupSize) {\n        if (hand.length % groupSize != 0)\n            return false;\n\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int n : hand)\n            count.put(n, 1 + count.getOrDefault(n, 0));\n\n        PriorityQueue<Integer> minH = new PriorityQueue<>(count.keySet());\n        while (!minH.isEmpty()) {\n            int first = minH.peek();\n            for (int i = first; i < first + groupSize; i++) {\n                if (!count.containsKey(i))\n                    return false;\n                count.put(i, count.get(i) - 1);\n                if (count.get(i) == 0) {\n                    if (i != minH.peek())\n                        return false;\n                    minH.poll();\n                }\n            }\n        }\n        return true;\n    }\n}\n","csharp":"public class Solution {\n    public bool IsNStraightHand(int[] hand, int groupSize) {\n        if (hand.Length % groupSize != 0)\n            return false;\n\n        var count = new Dictionary<int, int>();\n        foreach (int num in hand) {\n            if (count.ContainsKey(num))\n                count[num]++;\n            else\n                count[num] = 1;\n        }\n\n        var minH = new PriorityQueue<int, int>();\n        foreach (var num in count.Keys)\n            minH.Enqueue(num, num);\n\n        while (minH.Count > 0) {\n            int first = minH.Peek();\n            for (int i = first; i < first + groupSize; i++) {\n                if (!count.ContainsKey(i) || count[i] == 0)\n                    return false;\n                \n                count[i]--;\n                if (count[i] == 0) {\n                    if (i != minH.Peek())\n                        return false;\n                    minH.Dequeue();\n                }\n            }\n        }\n        return true;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isNStraightHand(self, hand: List[int], groupSize: int) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} hand\n     * @param {number} groupSize\n     * @return {boolean}\n     */\n    isNStraightHand(hand, groupSize) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isNStraightHand(vector<int>& hand, int groupSize) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isNStraightHand(int[] hand, int groupSize) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsNStraightHand(int[] hand, int groupSize) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/amnrMCVd2YI"},{"id":"minimum-interval-including-query","name":"Minimum Interval to Include Each Query","description":"You are given a 2D integer array `intervals`, where `intervals[i] = [left_i, right_i]` represents the `ith` interval starting at `left_i` and ending at `right_i` **(inclusive)**. \n\nYou are also given an integer array of query points `queries`. The result of `query[j]` is the **length of the shortest interval** `i` such that `left_i <= queries[j] <= right_i`. If no such interval exists, the result of this query is `-1`.\n\nReturn an array `output` where `output[j]` is the result of `query[j]`.\n\nNote: The length of an interval is calculated as `right_i - left_i + 1`.\n\n**Example 1:**\n\n```java\nInput: intervals = [[1,3],[2,3],[3,7],[6,6]], queries = [2,3,1,7,6,8]\n\nOutput: [2,2,3,5,1,-1]\n```\n\nExplanation:\n- Query = 2: The interval `[2,3]` is the smallest one containing 2, it's length is 2.\n- Query = 3: The interval `[2,3]` is the smallest one containing 3, it's length is 2.\n- Query = 1: The interval `[1,3]` is the smallest one containing 1, it's length is 3.\n- Query = 7: The interval `[3,7]` is the smallest one containing 7, it's length is 5.\n- Query = 6: The interval `[6,6]` is the smallest one containing 6, it's length is 1.\n- Query = 8: There is no interval containing 8.\n\n\n**Constraints:**\n* `1 <= intervals.length <= 1000`\n* `1 <= queries.length <= 1000`\n* `1 <= left_i <= right_i <= 10000`\n* `1 <= queries[j] <= 10000`\n","difficulty":"Hard","concepts":["Heap Properties","Push and Pop"],"solutions":{"python":"class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        intervals.sort()\n        minHeap = []\n        res = {}\n        i = 0\n        for q in sorted(queries):\n            while i < len(intervals) and intervals[i][0] <= q:\n                l, r = intervals[i]\n                heapq.heappush(minHeap, (r - l + 1, r))\n                i += 1\n\n            while minHeap and minHeap[0][1] < q:\n                heapq.heappop(minHeap)\n            res[q] = minHeap[0][0] if minHeap else -1\n        return [res[q] for q in queries]\n","javascript":"/**\n * const { MinPriorityQueue } = require('@datastructures-js/priority-queue');\n */\n\nclass Solution {\n    /**\n     * @param {number[][]} intervals\n     * @param {number[]} queries\n     * @return {number[]}\n     */\n    minInterval(intervals, queries) {\n        intervals.sort((a, b) => a[0] - b[0]);\n        const minHeap = new MinPriorityQueue(entry => entry[0]);\n        const res = {};\n        let i = 0;\n\n        const sortedQueries = [...queries].sort((a, b) => a - b);\n\n        for (const q of sortedQueries) {\n            while (i < intervals.length && intervals[i][0] <= q) {\n                const [l, r] = intervals[i];\n                minHeap.enqueue([r - l + 1, r]);\n                i += 1;\n            }\n\n            while (!minHeap.isEmpty() && minHeap.front()[1] < q) {\n                minHeap.dequeue();\n            }\n\n            res[q] = !minHeap.isEmpty() ? minHeap.front()[0] : -1;\n        }\n\n        return queries.map(q => res[q]);\n    }\n}\n","cpp":"class Solution {\npublic:\n    std::vector<int> minInterval(std::vector<std::vector<int>>& intervals, std::vector<int>& queries) {\n        // Sort intervals based on the start value\n        std::sort(intervals.begin(), intervals.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\n            return a[0] < b[0];\n        });\n\n        // Prepare to handle queries\n        std::vector<int> sortedQueries = queries;\n        std::sort(sortedQueries.begin(), sortedQueries.end());\n        std::map<int, int> res;\n\n        // Priority queue to store intervals, sorted by their size then end point\n        auto cmp = [](const std::vector<int>& a, const std::vector<int>& b) {\n            return a[0] > b[0] || (a[0] == b[0] && a[1] > b[1]);\n        };\n        std::priority_queue<std::vector<int>, std::vector<std::vector<int>>, decltype(cmp)> minHeap(cmp);\n\n        int i = 0;\n        for (int q : sortedQueries) {\n            while (i < intervals.size() && intervals[i][0] <= q) {\n                int l = intervals[i][0];\n                int r = intervals[i][1];\n                minHeap.push({r - l + 1, r});\n                i++;\n            }\n\n            while (!minHeap.empty() && minHeap.top()[1] < q) {\n                minHeap.pop();\n            }\n\n            res[q] = minHeap.empty() ? -1 : minHeap.top()[0];\n        }\n\n        // Build the result vector from the map\n        std::vector<int> result(queries.size());\n        for (int j = 0; j < queries.size(); j++) {\n            result[j] = res[queries[j]];\n        }\n        return result;\n    }\n};\n","java":"class Solution {\n    public int[] minInterval(int[][] intervals, int[] queries) {\n        Arrays.sort(intervals, Comparator.comparingInt(a -> a[0]));\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> Integer.compare(a[0], b[0]));\n        Map<Integer, Integer> res = new HashMap<>();\n        int i = 0;\n        for (int q : Arrays.stream(queries).sorted().toArray()) {\n            while (i < intervals.length && intervals[i][0] <= q) {\n                int l = intervals[i][0];\n                int r = intervals[i][1];\n                minHeap.offer(new int[]{r - l + 1, r});\n                i++;\n            }\n\n            while (!minHeap.isEmpty() && minHeap.peek()[1] < q) {\n                minHeap.poll();\n            }\n            res.put(q, minHeap.isEmpty() ? -1 : minHeap.peek()[0]);\n        }\n        int[] result = new int[queries.length];\n        for (int j = 0; j < queries.length; j++) {\n            result[j] = res.get(queries[j]);\n        }\n        return result;\n    }\n}\n","csharp":"public class Solution {\n    public int[] MinInterval(int[][] intervals, int[] queries) {\n        // Sort the intervals based on the start point\n        Array.Sort(intervals, (a, b) => a[0].CompareTo(b[0]));\n\n        // Initialize the priority queue to keep track of the intervals by their size\n        var minHeap = new PriorityQueue<(int Size, int End), int>();\n        var res = new Dictionary<int, int>();\n        int i = 0;\n\n        // Sort the queries to process in order\n        int[] sortedQueries = queries.OrderBy(q => q).ToArray();\n        foreach (int q in sortedQueries) {\n            // Add new intervals that can cover this query\n            while (i < intervals.Length && intervals[i][0] <= q) {\n                int l = intervals[i][0];\n                int r = intervals[i][1];\n                minHeap.Enqueue((r - l + 1, r), r - l + 1);\n                i++;\n            }\n\n            // Remove intervals that can no longer cover any query point >= q\n            while (minHeap.Count > 0 && minHeap.Peek().End < q) {\n                minHeap.Dequeue();\n            }\n\n            // Store the result for this query\n            res[q] = minHeap.Count == 0 ? -1 : minHeap.Peek().Size;\n        }\n\n        // Prepare the result in the same order as the original queries\n        int[] result = new int[queries.Length];\n        for (int j = 0; j < queries.Length; j++) {\n            result[j] = res[queries[j]];\n        }\n\n        return result;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def minInterval(self, intervals: List[List[int]], queries: List[int]) -> List[int]:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[][]} intervals\n     * @param {number[]} queries\n     * @return {number[]}\n     */\n    minInterval(intervals, queries) {}\n}\n","cpp":"class Solution {\npublic:\n    vector<int> minInterval(vector<vector<int>>& intervals, vector<int>& queries) {\n        \n    }\n};\n","java":"class Solution {\n    public int[] minInterval(int[][] intervals, int[] queries) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int[] MinInterval(int[][] intervals, int[] queries) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/5hQ5WWW5awQ"},{"id":"non-cyclical-number","name":"Non-Cyclical Number","description":"A **non-cyclical number** is an integer defined by the following algorithm:\n\n* Given a positive integer, replace it with the sum of the squares of its digits.\n* Repeat the above step until the number equals `1`, or it **loops infinitely in a cycle** which does not include `1`.\n* If it stops at `1`, then the number is a **non-cyclical number**.\n\nGiven a positive integer `n`, return `true` if it is a **non-cyclical number**, otherwise return `false`.\n\n**Example 1:**\n\n```java\nInput: n = 100\n\nOutput: true\n```\n\nExplanation: 1^2 + 0^2 + 0^2 = 1\n\n**Example 2:**\n\n```java\nInput: n = 101\n\nOutput: false\n```\n\nExplanation:\n1^2 + 0^2 + 1^2 = 2\n2^2 = 4\n4^2 = 16\n1^2 + 6^2 = 37\n3^2 + 7^2 = 58\n5^2 + 8^2 = 89\n8^2 + 9^2 = 145\n1^2 + 4^2 + 5^2 = 42\n4^2 + 2^2 = 20\n2^2 + 0^2 = 4 (This number has already been seen)\n\n**Constraints:**\n* `1 <= n <= 1000`\n","difficulty":"Easy","concepts":["Fast and Slow Pointers"],"solutions":{"python":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        slow, fast = n, self.sumSquareDigits(n)\n\n        while slow != fast:\n            fast = self.sumSquareDigits(fast)\n            fast = self.sumSquareDigits(fast)\n            slow = self.sumSquareDigits(slow)\n\n        return True if fast == 1 else False\n\n    def sumSquareDigits(self, n):\n        output = 0\n        while n:\n            output += (n % 10) ** 2\n            n = n // 10\n        return output\n","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {boolean}\n     */\n    isHappy(n) {\n        let slow = n;\n        let fast = this.sumSquareDigits(n);\n\n        while (slow !== fast) {\n            fast = this.sumSquareDigits(fast);\n            fast = this.sumSquareDigits(fast);\n            slow = this.sumSquareDigits(slow);\n        }\n\n        return fast === 1;\n    }\n\n    /**\n     * @param {number} n\n     * @return {number}\n     */\n    sumSquareDigits(n) {\n        let output = 0;\n        while (n !== 0) {\n            output += (n % 10) ** 2;\n            n = Math.floor(n / 10);\n        }\n        return output;\n    }\n}\n","cpp":"class Solution {\npublic:\n    bool isHappy(int n) {\n        int slow = n, fast = sumSquareDigits(n);\n\n        while (slow != fast) {\n            fast = sumSquareDigits(fast);\n            fast = sumSquareDigits(fast);\n            slow = sumSquareDigits(slow);\n        }\n\n        return fast == 1;\n    }\n\nprivate:\n    int sumSquareDigits(int n) {\n        int output = 0;\n        while (n != 0) {\n            output += (n % 10) * (n % 10);\n            n /= 10;\n        }\n        return output;\n    }\n};\n","java":"class Solution {\n    \n    public boolean isHappy(int n) {\n        int slow = n, fast = sumSquareDigits(n);\n\n        while (slow != fast) {\n            fast = sumSquareDigits(fast);\n            fast = sumSquareDigits(fast);\n            slow = sumSquareDigits(slow);\n        }\n\n        return fast == 1;\n    }\n\n    private int sumSquareDigits(int n) {\n        int output = 0;\n        while (n != 0) {\n            output += (n % 10) * (n % 10);\n            n /= 10;\n        }\n        return output;\n    }\n}\n","csharp":"public class Solution {\n    \n    public bool IsHappy(int n) {\n        int slow = n, fast = SumSquareDigits(n);\n\n        while (slow != fast) {\n            fast = SumSquareDigits(fast);\n            fast = SumSquareDigits(fast);\n            slow = SumSquareDigits(slow);\n        }\n\n        return fast == 1;\n    }\n\n    private int SumSquareDigits(int n) {\n        int output = 0;\n        while (n != 0) {\n            output += (n % 10) * (n % 10);\n            n /= 10;\n        }\n        return output;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def isHappy(self, n: int) -> bool:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} n\n     * @return {boolean}\n     */\n    isHappy(n) {}\n}\n","cpp":"class Solution {\npublic:\n    bool isHappy(int n) {\n        \n    }\n};\n","java":"class Solution {\n    public boolean isHappy(int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public bool IsHappy(int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/ljz85bxOYJ0"},{"id":"pow-x-n","name":"Pow(x, n)","description":"`Pow(x, n)` is a mathematical function to calculate the value of `x` raised to the power of `n` (i.e., `x^n`).\n    \nGiven a floating-point value `x` and an integer value `n`, implement the `myPow(x, n)` function, which calculates `x` raised to the power `n`.\n\nYou may **not** use any built-in library functions.\n\n**Example 1:**\n\n```java\nInput: x = 2.00000, n = 5\n\nOutput: 32.00000\n```\n\n**Example 2:**\n\n```java\nInput: x = 1.10000, n = 10\n\nOutput: 2.59374\n```\n\n**Example 3:**\n\n```java\nInput: x = 2.00000, n = -3\n\nOutput: 0.12500\n```\n\n**Constraints:**\n* `-100.0 < x < 100.0`\n* `-1000 <= n <= 1000`\n* `n` is an integer.\n* If `x = 0`, then `n` will be positive.\n","difficulty":"Medium","concepts":["Factorial"],"solutions":{"python":"class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        def helper(x, n):\n            if x == 0:\n                return 0\n            if n == 0:\n                return 1\n\n            res = helper(x * x, n // 2)\n            return x * res if n % 2 else res\n\n        res = helper(x, abs(n))\n        return res if n >= 0 else 1 / res\n","javascript":"class Solution {\n    /**\n     * @param {number} x\n     * @param {number} n\n     * @return {number}\n     */\n    myPow(x, n) {\n        /**\n         * @param {number} x\n         * @param {number} n\n         * @return {number}\n         */\n        function helper(x, n) {\n            if (x === 0) {\n                return 0;\n            }\n            if (n === 0) {\n                return 1;\n            }\n\n            const res = helper(x * x, Math.floor(n / 2));\n            return n % 2 === 0 ? res : x * res;\n        }\n\n        const res = helper(x, Math.abs(n));\n        return n >= 0 ? res : 1 / res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    double myPow(double x, int n) {\n        if (x == 0) {\n            return 0;\n        }\n        if (n == 0) {\n            return 1;\n        }\n\n        double res = helper(x, abs(static_cast<long>(n)));\n        return (n >= 0) ? res : 1 / res;\n    }\n\nprivate:\n    double helper(double x, long n) {\n        if (n == 0) {\n            return 1;\n        }\n        double half = helper(x, n / 2);\n        return (n % 2 == 0) ? half * half : x * half * half;\n    }\n};\n","java":"class Solution {\n    \n    public double myPow(double x, int n) {\n        if (x == 0) {\n            return 0;\n        }\n        if (n == 0) {\n            return 1;\n        }\n\n        double res = helper(x, Math.abs((long) n));\n        return (n >= 0) ? res : 1 / res;\n    }\n\n    private double helper(double x, long n) {\n        if (n == 0) {\n            return 1;\n        }\n        double half = helper(x, n / 2);\n        return (n % 2 == 0) ? half * half : x * half * half;\n    }\n}\n","csharp":"public class Solution {\n    \n    public double MyPow(double x, int n) {\n        if (x == 0) {\n            return 0;\n        }\n        if (n == 0) {\n            return 1;\n        }\n\n        double res = Helper(x, Math.Abs((long) n));\n        return (n >= 0) ? res : 1 / res;\n    }\n\n    private double Helper(double x, long n) {\n        if (n == 0) {\n            return 1;\n        }\n        double half = Helper(x, n / 2);\n        return (n % 2 == 0) ? half * half : x * half * half;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def myPow(self, x: float, n: int) -> float:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} x\n     * @param {number} n\n     * @return {number}\n     */\n    myPow(x, n) {}\n}\n","cpp":"class Solution {\npublic:\n    double myPow(double x, int n) {\n        \n    }\n};\n","java":"class Solution {\n    public double myPow(double x, int n) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public double MyPow(double x, int n) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/g9YQyYi4IQQ"},{"id":"single-number","name":"Single Number","description":"You are given a **non-empty** array of integers `nums`. Every integer appears twice except for one.\n\nReturn the integer that appears only once.\n\nYou must implement a solution with $O(n)$ runtime complexity and use only $O(1)$ extra space.\n\n**Example 1:**\n\n```java\nInput: nums = [3,2,3]\n\nOutput: 2\n```\n\n**Example 2:**\n\n```java\nInput: nums = [7,6,6,7,8]\n\nOutput: 8\n```\n\n**Constraints:**\n* `1 <= nums.length <= 10000`\n* `-10000 <= nums[i] <= 10000`\n","difficulty":"Easy","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        res = 0\n        for n in nums:\n            res = n ^ res\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    singleNumber(nums) {\n        let res = 0;\n        for (const n of nums) {\n            res ^= n;\n        }\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        int res = 0;\n        for (int n : nums) {\n            res ^= n;\n        }\n        return res;\n    }\n};\n","java":"class Solution {\n    public int singleNumber(int[] nums) {\n        int res = 0;\n        for (int n : nums) {\n            res ^= n;\n        }\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int SingleNumber(int[] nums) {\n        int res = 0;\n        foreach (int n in nums) {\n            res ^= n;\n        }\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def singleNumber(self, nums: List[int]) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number[]} nums\n     * @return {number}\n     */\n    singleNumber(nums) {}\n}\n","cpp":"class Solution {\npublic:\n    int singleNumber(vector<int>& nums) {\n        \n    }\n};\n","java":"class Solution {\n    public int singleNumber(int[] nums) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int SingleNumber(int[] nums) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/qMPX1AOa83k"},{"id":"reverse-integer","name":"Reverse Integer","description":"You are given a signed 32-bit integer `x`.\n    \nReturn `x` after reversing each of its digits. After reversing, if `x` goes outside the signed 32-bit integer range `[-2^31, 2^31 - 1]`, then return `0` instead.\n\nSolve the problem without using integers that are outside the signed 32-bit integer range.\n\n**Example 1:**\n\n```java\nInput: x = 1234\n\nOutput: 4321\n```\n\n**Example 2:**\n\n```java\nInput: x = -1234\n\nOutput: -4321\n```\n\n**Example 3:**\n\n```java\nInput: x = 1234236467\n\nOutput: 0\n```\n\n**Constraints:**\n* `-2^31 <= x <= 2^31 - 1`\n","difficulty":"Medium","concepts":["Bit Operations"],"solutions":{"python":"class Solution:\n    def reverse(self, x: int) -> int:\n        MIN = -2147483648  # -2^31,\n        MAX = 2147483647  #  2^31 - 1\n\n        res = 0\n        while x:\n            digit = int(math.fmod(x, 10))\n            x = int(x / 10)\n\n            if res > MAX // 10 or (res == MAX // 10 and digit > MAX % 10):\n                return 0\n            if res < MIN // 10 or (res == MIN // 10 and digit < MIN % 10):\n                return 0\n            res = (res * 10) + digit\n\n        return res\n","javascript":"class Solution {\n    /**\n     * @param {number} x\n     * @return {number}\n     */\n    reverse(x) {\n        const MIN = -2147483648; // -2^31\n        const MAX = 2147483647; // 2^31 - 1\n\n        let res = 0;\n        while (x !== 0) {\n            const digit = x % 10;\n            x = Math.trunc(x / 10);\n\n            if (res > MAX / 10 || (res === MAX / 10 && digit > MAX % 10))\n                return 0;\n            if (res < MIN / 10 || (res === MIN / 10 && digit < MIN % 10))\n                return 0;\n            res = res * 10 + digit;\n        }\n\n        return res;\n    }\n}\n","cpp":"class Solution {\npublic:\n    int reverse(int x) {\n        const int MIN = -2147483648; // -2^31\n        const int MAX = 2147483647;  // 2^31 - 1\n\n        int res = 0;\n        while (x != 0) {\n            int digit = x % 10;\n            x /= 10;\n\n            if (res > MAX / 10 || (res == MAX / 10 && digit > MAX % 10))\n                return 0;\n            if (res < MIN / 10 || (res == MIN / 10 && digit < MIN % 10))\n                return 0;\n            res = (res * 10) + digit;\n        }\n\n        return res;\n    }\n};\n","java":"class Solution {\n    public int reverse(int x) {\n        final int MIN = -2147483648; // -2^31\n        final int MAX = 2147483647;  // 2^31 - 1\n\n        int res = 0;\n        while (x != 0) {\n            int digit = x % 10;\n            x /= 10;\n\n            if (res > MAX / 10 || (res == MAX / 10 && digit > MAX % 10))\n                return 0;\n            if (res < MIN / 10 || (res == MIN / 10 && digit < MIN % 10))\n                return 0;\n            res = (res * 10) + digit;\n        }\n\n        return res;\n    }\n}\n","csharp":"public class Solution {\n    public int Reverse(int x) {\n        const int MIN = -2147483648; // -2^31\n        const int MAX = 2147483647;  // 2^31 - 1\n\n        int res = 0;\n        while (x != 0) {\n            int digit = x % 10;\n            x /= 10;\n\n            if (res > MAX / 10 || (res == MAX / 10 && digit > MAX % 10))\n                return 0;\n            if (res < MIN / 10 || (res == MIN / 10 && digit < MIN % 10))\n                return 0;\n            res = (res * 10) + digit;\n        }\n\n        return res;\n    }\n}\n"},"starterCode":{"python":"class Solution:\n    def reverse(self, x: int) -> int:\n        ","javascript":"class Solution {\n    /**\n     * @param {number} x\n     * @return {number}\n     */\n    reverse(x) {}\n}\n","cpp":"class Solution {\npublic:\n    int reverse(int x) {\n        \n    }\n};\n","java":"class Solution {\n    public int reverse(int x) {\n        \n    }\n}\n","csharp":"public class Solution {\n    public int Reverse(int x) {\n        \n    }\n}\n"},"videoUrl":"https://www.youtube.com/embed/HAgLH58IgJQ"}]}